// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// * [Official documentation](https://help.zscaler.com/zia/about-traffic-capture-policy)
// * [API documentation](https://help.zscaler.com/zia/traffic-capture-policy#/trafficCaptureRules-get)
//
// The **zia_traffic_capture_rules** resource allows the creation and management of ZIA traffic capture rules in the Zscaler Internet Access.
//
// ## Example Usage
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
// Visit
//
// **zia_traffic_capture_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.
//
// For example:
//
// ```sh
// $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_id>
// ```
//
// or
//
// ```sh
// $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_name>
// ```
type TrafficCaptureRules struct {
	pulumi.CustomResourceState

	// The action to be enforced when the traffic matches the rule criteria
	Action pulumi.StringPtrOutput `pulumi:"action"`
	// list of application service groups
	AppServiceGroups TrafficCaptureRulesAppServiceGroupsPtrOutput `pulumi:"appServiceGroups"`
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrOutput `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments TrafficCaptureRulesDepartmentsPtrOutput `pulumi:"departments"`
	// Additional information about the rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayOutput `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	DestCountries    pulumi.StringArrayOutput `pulumi:"destCountries"`
	DestIpCategories pulumi.StringArrayOutput `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups TrafficCaptureRulesDestIpGroupsPtrOutput `pulumi:"destIpGroups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups TrafficCaptureRulesDeviceGroupsPtrOutput `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayOutput `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices TrafficCaptureRulesDevicesPtrOutput `pulumi:"devices"`
	// list of groups for which rule must be applied
	Groups TrafficCaptureRulesGroupsPtrOutput `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels TrafficCaptureRulesLabelsPtrOutput `pulumi:"labels"`
	// list of locations groups
	LocationGroups TrafficCaptureRulesLocationGroupsPtrOutput `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations TrafficCaptureRulesLocationsPtrOutput `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringOutput `pulumi:"name"`
	// list of nw application groups
	NwApplicationGroups TrafficCaptureRulesNwApplicationGroupsPtrOutput `pulumi:"nwApplicationGroups"`
	NwApplications      pulumi.StringArrayOutput                        `pulumi:"nwApplications"`
	// list of nw service groups
	NwServiceGroups TrafficCaptureRulesNwServiceGroupsPtrOutput `pulumi:"nwServiceGroups"`
	// list of nw services
	NwServices TrafficCaptureRulesNwServicesPtrOutput `pulumi:"nwServices"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntOutput `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrOutput `pulumi:"predefined"`
	// Admin rank of the Firewall Filtering policy rule
	Rank   pulumi.IntPtrOutput `pulumi:"rank"`
	RuleId pulumi.IntOutput    `pulumi:"ruleId"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	SourceCountries pulumi.StringArrayOutput `pulumi:"sourceCountries"`
	// list of source ip groups
	SrcIpGroups TrafficCaptureRulesSrcIpGroupsPtrOutput `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
	SrcIps pulumi.StringArrayOutput `pulumi:"srcIps"`
	// Determines whether the Firewall Filtering policy rule is enabled or disabled
	State pulumi.StringPtrOutput `pulumi:"state"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows TrafficCaptureRulesTimeWindowsPtrOutput `pulumi:"timeWindows"`
	// The percentage of connections sampled for capturing each time the rule is triggered
	TxnSampling pulumi.StringPtrOutput `pulumi:"txnSampling"`
	// The maximum size of traffic to capture per connection
	TxnSizeLimit pulumi.StringPtrOutput `pulumi:"txnSizeLimit"`
	// list of users for which rule must be applied
	Users TrafficCaptureRulesUsersPtrOutput `pulumi:"users"`
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups TrafficCaptureRulesWorkloadGroupArrayOutput `pulumi:"workloadGroups"`
}

// NewTrafficCaptureRules registers a new resource with the given unique name, arguments, and options.
func NewTrafficCaptureRules(ctx *pulumi.Context,
	name string, args *TrafficCaptureRulesArgs, opts ...pulumi.ResourceOption) (*TrafficCaptureRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TrafficCaptureRules
	err := ctx.RegisterResource("zia:index/trafficCaptureRules:TrafficCaptureRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTrafficCaptureRules gets an existing TrafficCaptureRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTrafficCaptureRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TrafficCaptureRulesState, opts ...pulumi.ResourceOption) (*TrafficCaptureRules, error) {
	var resource TrafficCaptureRules
	err := ctx.ReadResource("zia:index/trafficCaptureRules:TrafficCaptureRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TrafficCaptureRules resources.
type trafficCaptureRulesState struct {
	// The action to be enforced when the traffic matches the rule criteria
	Action *string `pulumi:"action"`
	// list of application service groups
	AppServiceGroups *TrafficCaptureRulesAppServiceGroups `pulumi:"appServiceGroups"`
	// If set to true, the default rule is applied
	DefaultRule *bool `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments *TrafficCaptureRulesDepartments `pulumi:"departments"`
	// Additional information about the rule
	Description *string `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses []string `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	DestCountries    []string `pulumi:"destCountries"`
	DestIpCategories []string `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups *TrafficCaptureRulesDestIpGroups `pulumi:"destIpGroups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *TrafficCaptureRulesDeviceGroups `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels []string `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *TrafficCaptureRulesDevices `pulumi:"devices"`
	// list of groups for which rule must be applied
	Groups *TrafficCaptureRulesGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *TrafficCaptureRulesLabels `pulumi:"labels"`
	// list of locations groups
	LocationGroups *TrafficCaptureRulesLocationGroups `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations *TrafficCaptureRulesLocations `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
	// list of nw application groups
	NwApplicationGroups *TrafficCaptureRulesNwApplicationGroups `pulumi:"nwApplicationGroups"`
	NwApplications      []string                                `pulumi:"nwApplications"`
	// list of nw service groups
	NwServiceGroups *TrafficCaptureRulesNwServiceGroups `pulumi:"nwServiceGroups"`
	// list of nw services
	NwServices *TrafficCaptureRulesNwServices `pulumi:"nwServices"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order *int `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined *bool `pulumi:"predefined"`
	// Admin rank of the Firewall Filtering policy rule
	Rank   *int `pulumi:"rank"`
	RuleId *int `pulumi:"ruleId"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	SourceCountries []string `pulumi:"sourceCountries"`
	// list of source ip groups
	SrcIpGroups *TrafficCaptureRulesSrcIpGroups `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
	SrcIps []string `pulumi:"srcIps"`
	// Determines whether the Firewall Filtering policy rule is enabled or disabled
	State *string `pulumi:"state"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows *TrafficCaptureRulesTimeWindows `pulumi:"timeWindows"`
	// The percentage of connections sampled for capturing each time the rule is triggered
	TxnSampling *string `pulumi:"txnSampling"`
	// The maximum size of traffic to capture per connection
	TxnSizeLimit *string `pulumi:"txnSizeLimit"`
	// list of users for which rule must be applied
	Users *TrafficCaptureRulesUsers `pulumi:"users"`
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups []TrafficCaptureRulesWorkloadGroup `pulumi:"workloadGroups"`
}

type TrafficCaptureRulesState struct {
	// The action to be enforced when the traffic matches the rule criteria
	Action pulumi.StringPtrInput
	// list of application service groups
	AppServiceGroups TrafficCaptureRulesAppServiceGroupsPtrInput
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrInput
	// list of departments for which rule must be applied
	Departments TrafficCaptureRulesDepartmentsPtrInput
	// Additional information about the rule
	Description pulumi.StringPtrInput
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	DestCountries    pulumi.StringArrayInput
	DestIpCategories pulumi.StringArrayInput
	// list of destination ip groups
	DestIpGroups TrafficCaptureRulesDestIpGroupsPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups TrafficCaptureRulesDeviceGroupsPtrInput
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices TrafficCaptureRulesDevicesPtrInput
	// list of groups for which rule must be applied
	Groups TrafficCaptureRulesGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels TrafficCaptureRulesLabelsPtrInput
	// list of locations groups
	LocationGroups TrafficCaptureRulesLocationGroupsPtrInput
	// list of locations for which rule must be applied
	Locations TrafficCaptureRulesLocationsPtrInput
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput
	// list of nw application groups
	NwApplicationGroups TrafficCaptureRulesNwApplicationGroupsPtrInput
	NwApplications      pulumi.StringArrayInput
	// list of nw service groups
	NwServiceGroups TrafficCaptureRulesNwServiceGroupsPtrInput
	// list of nw services
	NwServices TrafficCaptureRulesNwServicesPtrInput
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntPtrInput
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrInput
	// Admin rank of the Firewall Filtering policy rule
	Rank   pulumi.IntPtrInput
	RuleId pulumi.IntPtrInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	SourceCountries pulumi.StringArrayInput
	// list of source ip groups
	SrcIpGroups TrafficCaptureRulesSrcIpGroupsPtrInput
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
	SrcIps pulumi.StringArrayInput
	// Determines whether the Firewall Filtering policy rule is enabled or disabled
	State pulumi.StringPtrInput
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows TrafficCaptureRulesTimeWindowsPtrInput
	// The percentage of connections sampled for capturing each time the rule is triggered
	TxnSampling pulumi.StringPtrInput
	// The maximum size of traffic to capture per connection
	TxnSizeLimit pulumi.StringPtrInput
	// list of users for which rule must be applied
	Users TrafficCaptureRulesUsersPtrInput
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups TrafficCaptureRulesWorkloadGroupArrayInput
}

func (TrafficCaptureRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*trafficCaptureRulesState)(nil)).Elem()
}

type trafficCaptureRulesArgs struct {
	// The action to be enforced when the traffic matches the rule criteria
	Action *string `pulumi:"action"`
	// list of application service groups
	AppServiceGroups *TrafficCaptureRulesAppServiceGroups `pulumi:"appServiceGroups"`
	// If set to true, the default rule is applied
	DefaultRule *bool `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments *TrafficCaptureRulesDepartments `pulumi:"departments"`
	// Additional information about the rule
	Description *string `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses []string `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	DestCountries    []string `pulumi:"destCountries"`
	DestIpCategories []string `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups *TrafficCaptureRulesDestIpGroups `pulumi:"destIpGroups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *TrafficCaptureRulesDeviceGroups `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels []string `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *TrafficCaptureRulesDevices `pulumi:"devices"`
	// list of groups for which rule must be applied
	Groups *TrafficCaptureRulesGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *TrafficCaptureRulesLabels `pulumi:"labels"`
	// list of locations groups
	LocationGroups *TrafficCaptureRulesLocationGroups `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations *TrafficCaptureRulesLocations `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
	// list of nw application groups
	NwApplicationGroups *TrafficCaptureRulesNwApplicationGroups `pulumi:"nwApplicationGroups"`
	NwApplications      []string                                `pulumi:"nwApplications"`
	// list of nw service groups
	NwServiceGroups *TrafficCaptureRulesNwServiceGroups `pulumi:"nwServiceGroups"`
	// list of nw services
	NwServices *TrafficCaptureRulesNwServices `pulumi:"nwServices"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order int `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined *bool `pulumi:"predefined"`
	// Admin rank of the Firewall Filtering policy rule
	Rank *int `pulumi:"rank"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	SourceCountries []string `pulumi:"sourceCountries"`
	// list of source ip groups
	SrcIpGroups *TrafficCaptureRulesSrcIpGroups `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
	SrcIps []string `pulumi:"srcIps"`
	// Determines whether the Firewall Filtering policy rule is enabled or disabled
	State *string `pulumi:"state"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows *TrafficCaptureRulesTimeWindows `pulumi:"timeWindows"`
	// The percentage of connections sampled for capturing each time the rule is triggered
	TxnSampling *string `pulumi:"txnSampling"`
	// The maximum size of traffic to capture per connection
	TxnSizeLimit *string `pulumi:"txnSizeLimit"`
	// list of users for which rule must be applied
	Users *TrafficCaptureRulesUsers `pulumi:"users"`
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups []TrafficCaptureRulesWorkloadGroup `pulumi:"workloadGroups"`
}

// The set of arguments for constructing a TrafficCaptureRules resource.
type TrafficCaptureRulesArgs struct {
	// The action to be enforced when the traffic matches the rule criteria
	Action pulumi.StringPtrInput
	// list of application service groups
	AppServiceGroups TrafficCaptureRulesAppServiceGroupsPtrInput
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrInput
	// list of departments for which rule must be applied
	Departments TrafficCaptureRulesDepartmentsPtrInput
	// Additional information about the rule
	Description pulumi.StringPtrInput
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	DestCountries    pulumi.StringArrayInput
	DestIpCategories pulumi.StringArrayInput
	// list of destination ip groups
	DestIpGroups TrafficCaptureRulesDestIpGroupsPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups TrafficCaptureRulesDeviceGroupsPtrInput
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices TrafficCaptureRulesDevicesPtrInput
	// list of groups for which rule must be applied
	Groups TrafficCaptureRulesGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels TrafficCaptureRulesLabelsPtrInput
	// list of locations groups
	LocationGroups TrafficCaptureRulesLocationGroupsPtrInput
	// list of locations for which rule must be applied
	Locations TrafficCaptureRulesLocationsPtrInput
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput
	// list of nw application groups
	NwApplicationGroups TrafficCaptureRulesNwApplicationGroupsPtrInput
	NwApplications      pulumi.StringArrayInput
	// list of nw service groups
	NwServiceGroups TrafficCaptureRulesNwServiceGroupsPtrInput
	// list of nw services
	NwServices TrafficCaptureRulesNwServicesPtrInput
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntInput
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrInput
	// Admin rank of the Firewall Filtering policy rule
	Rank pulumi.IntPtrInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
	SourceCountries pulumi.StringArrayInput
	// list of source ip groups
	SrcIpGroups TrafficCaptureRulesSrcIpGroupsPtrInput
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
	SrcIps pulumi.StringArrayInput
	// Determines whether the Firewall Filtering policy rule is enabled or disabled
	State pulumi.StringPtrInput
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows TrafficCaptureRulesTimeWindowsPtrInput
	// The percentage of connections sampled for capturing each time the rule is triggered
	TxnSampling pulumi.StringPtrInput
	// The maximum size of traffic to capture per connection
	TxnSizeLimit pulumi.StringPtrInput
	// list of users for which rule must be applied
	Users TrafficCaptureRulesUsersPtrInput
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups TrafficCaptureRulesWorkloadGroupArrayInput
}

func (TrafficCaptureRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*trafficCaptureRulesArgs)(nil)).Elem()
}

type TrafficCaptureRulesInput interface {
	pulumi.Input

	ToTrafficCaptureRulesOutput() TrafficCaptureRulesOutput
	ToTrafficCaptureRulesOutputWithContext(ctx context.Context) TrafficCaptureRulesOutput
}

func (*TrafficCaptureRules) ElementType() reflect.Type {
	return reflect.TypeOf((**TrafficCaptureRules)(nil)).Elem()
}

func (i *TrafficCaptureRules) ToTrafficCaptureRulesOutput() TrafficCaptureRulesOutput {
	return i.ToTrafficCaptureRulesOutputWithContext(context.Background())
}

func (i *TrafficCaptureRules) ToTrafficCaptureRulesOutputWithContext(ctx context.Context) TrafficCaptureRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficCaptureRulesOutput)
}

// TrafficCaptureRulesArrayInput is an input type that accepts TrafficCaptureRulesArray and TrafficCaptureRulesArrayOutput values.
// You can construct a concrete instance of `TrafficCaptureRulesArrayInput` via:
//
//	TrafficCaptureRulesArray{ TrafficCaptureRulesArgs{...} }
type TrafficCaptureRulesArrayInput interface {
	pulumi.Input

	ToTrafficCaptureRulesArrayOutput() TrafficCaptureRulesArrayOutput
	ToTrafficCaptureRulesArrayOutputWithContext(context.Context) TrafficCaptureRulesArrayOutput
}

type TrafficCaptureRulesArray []TrafficCaptureRulesInput

func (TrafficCaptureRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TrafficCaptureRules)(nil)).Elem()
}

func (i TrafficCaptureRulesArray) ToTrafficCaptureRulesArrayOutput() TrafficCaptureRulesArrayOutput {
	return i.ToTrafficCaptureRulesArrayOutputWithContext(context.Background())
}

func (i TrafficCaptureRulesArray) ToTrafficCaptureRulesArrayOutputWithContext(ctx context.Context) TrafficCaptureRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficCaptureRulesArrayOutput)
}

// TrafficCaptureRulesMapInput is an input type that accepts TrafficCaptureRulesMap and TrafficCaptureRulesMapOutput values.
// You can construct a concrete instance of `TrafficCaptureRulesMapInput` via:
//
//	TrafficCaptureRulesMap{ "key": TrafficCaptureRulesArgs{...} }
type TrafficCaptureRulesMapInput interface {
	pulumi.Input

	ToTrafficCaptureRulesMapOutput() TrafficCaptureRulesMapOutput
	ToTrafficCaptureRulesMapOutputWithContext(context.Context) TrafficCaptureRulesMapOutput
}

type TrafficCaptureRulesMap map[string]TrafficCaptureRulesInput

func (TrafficCaptureRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TrafficCaptureRules)(nil)).Elem()
}

func (i TrafficCaptureRulesMap) ToTrafficCaptureRulesMapOutput() TrafficCaptureRulesMapOutput {
	return i.ToTrafficCaptureRulesMapOutputWithContext(context.Background())
}

func (i TrafficCaptureRulesMap) ToTrafficCaptureRulesMapOutputWithContext(ctx context.Context) TrafficCaptureRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficCaptureRulesMapOutput)
}

type TrafficCaptureRulesOutput struct{ *pulumi.OutputState }

func (TrafficCaptureRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TrafficCaptureRules)(nil)).Elem()
}

func (o TrafficCaptureRulesOutput) ToTrafficCaptureRulesOutput() TrafficCaptureRulesOutput {
	return o
}

func (o TrafficCaptureRulesOutput) ToTrafficCaptureRulesOutputWithContext(ctx context.Context) TrafficCaptureRulesOutput {
	return o
}

// The action to be enforced when the traffic matches the rule criteria
func (o TrafficCaptureRulesOutput) Action() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringPtrOutput { return v.Action }).(pulumi.StringPtrOutput)
}

// list of application service groups
func (o TrafficCaptureRulesOutput) AppServiceGroups() TrafficCaptureRulesAppServiceGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesAppServiceGroupsPtrOutput { return v.AppServiceGroups }).(TrafficCaptureRulesAppServiceGroupsPtrOutput)
}

// If set to true, the default rule is applied
func (o TrafficCaptureRulesOutput) DefaultRule() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.BoolPtrOutput { return v.DefaultRule }).(pulumi.BoolPtrOutput)
}

// list of departments for which rule must be applied
func (o TrafficCaptureRulesOutput) Departments() TrafficCaptureRulesDepartmentsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesDepartmentsPtrOutput { return v.Departments }).(TrafficCaptureRulesDepartmentsPtrOutput)
}

// Additional information about the rule
func (o TrafficCaptureRulesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
func (o TrafficCaptureRulesOutput) DestAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.DestAddresses }).(pulumi.StringArrayOutput)
}

// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
func (o TrafficCaptureRulesOutput) DestCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.DestCountries }).(pulumi.StringArrayOutput)
}

func (o TrafficCaptureRulesOutput) DestIpCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.DestIpCategories }).(pulumi.StringArrayOutput)
}

// list of destination ip groups
func (o TrafficCaptureRulesOutput) DestIpGroups() TrafficCaptureRulesDestIpGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesDestIpGroupsPtrOutput { return v.DestIpGroups }).(TrafficCaptureRulesDestIpGroupsPtrOutput)
}

// This field is applicable for devices that are managed using Zscaler Client Connector.
func (o TrafficCaptureRulesOutput) DeviceGroups() TrafficCaptureRulesDeviceGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesDeviceGroupsPtrOutput { return v.DeviceGroups }).(TrafficCaptureRulesDeviceGroupsPtrOutput)
}

// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
func (o TrafficCaptureRulesOutput) DeviceTrustLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.DeviceTrustLevels }).(pulumi.StringArrayOutput)
}

// Name-ID pairs of devices for which rule must be applied.
func (o TrafficCaptureRulesOutput) Devices() TrafficCaptureRulesDevicesPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesDevicesPtrOutput { return v.Devices }).(TrafficCaptureRulesDevicesPtrOutput)
}

// list of groups for which rule must be applied
func (o TrafficCaptureRulesOutput) Groups() TrafficCaptureRulesGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesGroupsPtrOutput { return v.Groups }).(TrafficCaptureRulesGroupsPtrOutput)
}

// list of Labels that are applicable to the rule.
func (o TrafficCaptureRulesOutput) Labels() TrafficCaptureRulesLabelsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesLabelsPtrOutput { return v.Labels }).(TrafficCaptureRulesLabelsPtrOutput)
}

// list of locations groups
func (o TrafficCaptureRulesOutput) LocationGroups() TrafficCaptureRulesLocationGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesLocationGroupsPtrOutput { return v.LocationGroups }).(TrafficCaptureRulesLocationGroupsPtrOutput)
}

// list of locations for which rule must be applied
func (o TrafficCaptureRulesOutput) Locations() TrafficCaptureRulesLocationsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesLocationsPtrOutput { return v.Locations }).(TrafficCaptureRulesLocationsPtrOutput)
}

// Name of the Firewall Filtering policy rule
func (o TrafficCaptureRulesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// list of nw application groups
func (o TrafficCaptureRulesOutput) NwApplicationGroups() TrafficCaptureRulesNwApplicationGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesNwApplicationGroupsPtrOutput {
		return v.NwApplicationGroups
	}).(TrafficCaptureRulesNwApplicationGroupsPtrOutput)
}

func (o TrafficCaptureRulesOutput) NwApplications() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.NwApplications }).(pulumi.StringArrayOutput)
}

// list of nw service groups
func (o TrafficCaptureRulesOutput) NwServiceGroups() TrafficCaptureRulesNwServiceGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesNwServiceGroupsPtrOutput { return v.NwServiceGroups }).(TrafficCaptureRulesNwServiceGroupsPtrOutput)
}

// list of nw services
func (o TrafficCaptureRulesOutput) NwServices() TrafficCaptureRulesNwServicesPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesNwServicesPtrOutput { return v.NwServices }).(TrafficCaptureRulesNwServicesPtrOutput)
}

// Rule order number. If omitted, the rule will be added to the end of the rule set.
func (o TrafficCaptureRulesOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// If set to true, a predefined rule is applied
func (o TrafficCaptureRulesOutput) Predefined() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.BoolPtrOutput { return v.Predefined }).(pulumi.BoolPtrOutput)
}

// Admin rank of the Firewall Filtering policy rule
func (o TrafficCaptureRulesOutput) Rank() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.IntPtrOutput { return v.Rank }).(pulumi.IntPtrOutput)
}

func (o TrafficCaptureRulesOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
func (o TrafficCaptureRulesOutput) SourceCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.SourceCountries }).(pulumi.StringArrayOutput)
}

// list of source ip groups
func (o TrafficCaptureRulesOutput) SrcIpGroups() TrafficCaptureRulesSrcIpGroupsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesSrcIpGroupsPtrOutput { return v.SrcIpGroups }).(TrafficCaptureRulesSrcIpGroupsPtrOutput)
}

// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
func (o TrafficCaptureRulesOutput) SrcIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringArrayOutput { return v.SrcIps }).(pulumi.StringArrayOutput)
}

// Determines whether the Firewall Filtering policy rule is enabled or disabled
func (o TrafficCaptureRulesOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// The time interval in which the Firewall Filtering policy rule applies
func (o TrafficCaptureRulesOutput) TimeWindows() TrafficCaptureRulesTimeWindowsPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesTimeWindowsPtrOutput { return v.TimeWindows }).(TrafficCaptureRulesTimeWindowsPtrOutput)
}

// The percentage of connections sampled for capturing each time the rule is triggered
func (o TrafficCaptureRulesOutput) TxnSampling() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringPtrOutput { return v.TxnSampling }).(pulumi.StringPtrOutput)
}

// The maximum size of traffic to capture per connection
func (o TrafficCaptureRulesOutput) TxnSizeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) pulumi.StringPtrOutput { return v.TxnSizeLimit }).(pulumi.StringPtrOutput)
}

// list of users for which rule must be applied
func (o TrafficCaptureRulesOutput) Users() TrafficCaptureRulesUsersPtrOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesUsersPtrOutput { return v.Users }).(TrafficCaptureRulesUsersPtrOutput)
}

// The list of preconfigured workload groups to which the policy must be applied
func (o TrafficCaptureRulesOutput) WorkloadGroups() TrafficCaptureRulesWorkloadGroupArrayOutput {
	return o.ApplyT(func(v *TrafficCaptureRules) TrafficCaptureRulesWorkloadGroupArrayOutput { return v.WorkloadGroups }).(TrafficCaptureRulesWorkloadGroupArrayOutput)
}

type TrafficCaptureRulesArrayOutput struct{ *pulumi.OutputState }

func (TrafficCaptureRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TrafficCaptureRules)(nil)).Elem()
}

func (o TrafficCaptureRulesArrayOutput) ToTrafficCaptureRulesArrayOutput() TrafficCaptureRulesArrayOutput {
	return o
}

func (o TrafficCaptureRulesArrayOutput) ToTrafficCaptureRulesArrayOutputWithContext(ctx context.Context) TrafficCaptureRulesArrayOutput {
	return o
}

func (o TrafficCaptureRulesArrayOutput) Index(i pulumi.IntInput) TrafficCaptureRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TrafficCaptureRules {
		return vs[0].([]*TrafficCaptureRules)[vs[1].(int)]
	}).(TrafficCaptureRulesOutput)
}

type TrafficCaptureRulesMapOutput struct{ *pulumi.OutputState }

func (TrafficCaptureRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TrafficCaptureRules)(nil)).Elem()
}

func (o TrafficCaptureRulesMapOutput) ToTrafficCaptureRulesMapOutput() TrafficCaptureRulesMapOutput {
	return o
}

func (o TrafficCaptureRulesMapOutput) ToTrafficCaptureRulesMapOutputWithContext(ctx context.Context) TrafficCaptureRulesMapOutput {
	return o
}

func (o TrafficCaptureRulesMapOutput) MapIndex(k pulumi.StringInput) TrafficCaptureRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TrafficCaptureRules {
		return vs[0].(map[string]*TrafficCaptureRules)[vs[1].(string)]
	}).(TrafficCaptureRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TrafficCaptureRulesInput)(nil)).Elem(), &TrafficCaptureRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*TrafficCaptureRulesArrayInput)(nil)).Elem(), TrafficCaptureRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TrafficCaptureRulesMapInput)(nil)).Elem(), TrafficCaptureRulesMap{})
	pulumi.RegisterOutputType(TrafficCaptureRulesOutput{})
	pulumi.RegisterOutputType(TrafficCaptureRulesArrayOutput{})
	pulumi.RegisterOutputType(TrafficCaptureRulesMapOutput{})
}

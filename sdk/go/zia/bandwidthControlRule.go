// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// * [Official documentation](https://help.zscaler.com/zia/adding-rules-bandwidth-control-policy)
// * [API documentation](https://help.zscaler.com/zia/bandwidth-control-classes#/)
//
// Use the **zia_bandwidth_control_rule** resource allows the creation and management of ZIA Bandwidth Control Rules in the Zscaler Internet Access cloud or via the API.
//
// **NOTE**: Bandwidth control rule resource is only supported via Zscaler OneAPI.
//
// ## Example Usage
//
// ### By Name
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
// Visit
//
// **zia_bandwidth_control_rule** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.
//
// For example:
//
// ```sh
// $ pulumi import zia:index/bandwidthControlRule:BandwidthControlRule this <rule_id>
// ```
//
// ```sh
// $ pulumi import zia:index/bandwidthControlRule:BandwidthControlRule this <"rule_name">
// ```
type BandwidthControlRule struct {
	pulumi.CustomResourceState

	// The bandwidth control rulees to which you want to apply this rule
	BandwidthClasses BandwidthControlRuleBandwidthClassesPtrOutput `pulumi:"bandwidthClasses"`
	// (Optional) Additional information about the rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Labels that are applicable to the rule
	Labels BandwidthControlRuleLabelsPtrOutput `pulumi:"labels"`
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups BandwidthControlRuleLocationGroupsPtrOutput `pulumi:"locationGroups"`
	// Name-ID pairs of locations for which rule must be applied
	Locations BandwidthControlRuleLocationsPtrOutput `pulumi:"locations"`
	// (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MaxBandwidth pulumi.IntPtrOutput `pulumi:"maxBandwidth"`
	// (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MinBandwidth pulumi.IntPtrOutput `pulumi:"minBandwidth"`
	// The bandwidth control rule name
	Name pulumi.StringOutput `pulumi:"name"`
	// The order of the bandwidth control rule
	Order pulumi.IntOutput `pulumi:"order"`
	// (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
	Protocols pulumi.StringArrayOutput `pulumi:"protocols"`
	// (Optional) Admin rank of the Bandwidth Control policy rule
	Rank   pulumi.IntPtrOutput `pulumi:"rank"`
	RuleId pulumi.IntOutput    `pulumi:"ruleId"`
	// (Optional) Administrative state of the rule.
	State pulumi.StringPtrOutput `pulumi:"state"`
	// The Name-ID pairs of time windows to which the bandwidth control rule must be applied
	TimeWindows BandwidthControlRuleTimeWindowsPtrOutput `pulumi:"timeWindows"`
}

// NewBandwidthControlRule registers a new resource with the given unique name, arguments, and options.
func NewBandwidthControlRule(ctx *pulumi.Context,
	name string, args *BandwidthControlRuleArgs, opts ...pulumi.ResourceOption) (*BandwidthControlRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	if args.Protocols == nil {
		return nil, errors.New("invalid value for required argument 'Protocols'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BandwidthControlRule
	err := ctx.RegisterResource("zia:index/bandwidthControlRule:BandwidthControlRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBandwidthControlRule gets an existing BandwidthControlRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBandwidthControlRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BandwidthControlRuleState, opts ...pulumi.ResourceOption) (*BandwidthControlRule, error) {
	var resource BandwidthControlRule
	err := ctx.ReadResource("zia:index/bandwidthControlRule:BandwidthControlRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BandwidthControlRule resources.
type bandwidthControlRuleState struct {
	// The bandwidth control rulees to which you want to apply this rule
	BandwidthClasses *BandwidthControlRuleBandwidthClasses `pulumi:"bandwidthClasses"`
	// (Optional) Additional information about the rule
	Description *string `pulumi:"description"`
	// Labels that are applicable to the rule
	Labels *BandwidthControlRuleLabels `pulumi:"labels"`
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups *BandwidthControlRuleLocationGroups `pulumi:"locationGroups"`
	// Name-ID pairs of locations for which rule must be applied
	Locations *BandwidthControlRuleLocations `pulumi:"locations"`
	// (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MaxBandwidth *int `pulumi:"maxBandwidth"`
	// (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MinBandwidth *int `pulumi:"minBandwidth"`
	// The bandwidth control rule name
	Name *string `pulumi:"name"`
	// The order of the bandwidth control rule
	Order *int `pulumi:"order"`
	// (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
	Protocols []string `pulumi:"protocols"`
	// (Optional) Admin rank of the Bandwidth Control policy rule
	Rank   *int `pulumi:"rank"`
	RuleId *int `pulumi:"ruleId"`
	// (Optional) Administrative state of the rule.
	State *string `pulumi:"state"`
	// The Name-ID pairs of time windows to which the bandwidth control rule must be applied
	TimeWindows *BandwidthControlRuleTimeWindows `pulumi:"timeWindows"`
}

type BandwidthControlRuleState struct {
	// The bandwidth control rulees to which you want to apply this rule
	BandwidthClasses BandwidthControlRuleBandwidthClassesPtrInput
	// (Optional) Additional information about the rule
	Description pulumi.StringPtrInput
	// Labels that are applicable to the rule
	Labels BandwidthControlRuleLabelsPtrInput
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups BandwidthControlRuleLocationGroupsPtrInput
	// Name-ID pairs of locations for which rule must be applied
	Locations BandwidthControlRuleLocationsPtrInput
	// (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MaxBandwidth pulumi.IntPtrInput
	// (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MinBandwidth pulumi.IntPtrInput
	// The bandwidth control rule name
	Name pulumi.StringPtrInput
	// The order of the bandwidth control rule
	Order pulumi.IntPtrInput
	// (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
	Protocols pulumi.StringArrayInput
	// (Optional) Admin rank of the Bandwidth Control policy rule
	Rank   pulumi.IntPtrInput
	RuleId pulumi.IntPtrInput
	// (Optional) Administrative state of the rule.
	State pulumi.StringPtrInput
	// The Name-ID pairs of time windows to which the bandwidth control rule must be applied
	TimeWindows BandwidthControlRuleTimeWindowsPtrInput
}

func (BandwidthControlRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*bandwidthControlRuleState)(nil)).Elem()
}

type bandwidthControlRuleArgs struct {
	// The bandwidth control rulees to which you want to apply this rule
	BandwidthClasses *BandwidthControlRuleBandwidthClasses `pulumi:"bandwidthClasses"`
	// (Optional) Additional information about the rule
	Description *string `pulumi:"description"`
	// Labels that are applicable to the rule
	Labels *BandwidthControlRuleLabels `pulumi:"labels"`
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups *BandwidthControlRuleLocationGroups `pulumi:"locationGroups"`
	// Name-ID pairs of locations for which rule must be applied
	Locations *BandwidthControlRuleLocations `pulumi:"locations"`
	// (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MaxBandwidth *int `pulumi:"maxBandwidth"`
	// (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MinBandwidth *int `pulumi:"minBandwidth"`
	// The bandwidth control rule name
	Name *string `pulumi:"name"`
	// The order of the bandwidth control rule
	Order int `pulumi:"order"`
	// (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
	Protocols []string `pulumi:"protocols"`
	// (Optional) Admin rank of the Bandwidth Control policy rule
	Rank *int `pulumi:"rank"`
	// (Optional) Administrative state of the rule.
	State *string `pulumi:"state"`
	// The Name-ID pairs of time windows to which the bandwidth control rule must be applied
	TimeWindows *BandwidthControlRuleTimeWindows `pulumi:"timeWindows"`
}

// The set of arguments for constructing a BandwidthControlRule resource.
type BandwidthControlRuleArgs struct {
	// The bandwidth control rulees to which you want to apply this rule
	BandwidthClasses BandwidthControlRuleBandwidthClassesPtrInput
	// (Optional) Additional information about the rule
	Description pulumi.StringPtrInput
	// Labels that are applicable to the rule
	Labels BandwidthControlRuleLabelsPtrInput
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups BandwidthControlRuleLocationGroupsPtrInput
	// Name-ID pairs of locations for which rule must be applied
	Locations BandwidthControlRuleLocationsPtrInput
	// (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MaxBandwidth pulumi.IntPtrInput
	// (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
	MinBandwidth pulumi.IntPtrInput
	// The bandwidth control rule name
	Name pulumi.StringPtrInput
	// The order of the bandwidth control rule
	Order pulumi.IntInput
	// (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
	Protocols pulumi.StringArrayInput
	// (Optional) Admin rank of the Bandwidth Control policy rule
	Rank pulumi.IntPtrInput
	// (Optional) Administrative state of the rule.
	State pulumi.StringPtrInput
	// The Name-ID pairs of time windows to which the bandwidth control rule must be applied
	TimeWindows BandwidthControlRuleTimeWindowsPtrInput
}

func (BandwidthControlRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*bandwidthControlRuleArgs)(nil)).Elem()
}

type BandwidthControlRuleInput interface {
	pulumi.Input

	ToBandwidthControlRuleOutput() BandwidthControlRuleOutput
	ToBandwidthControlRuleOutputWithContext(ctx context.Context) BandwidthControlRuleOutput
}

func (*BandwidthControlRule) ElementType() reflect.Type {
	return reflect.TypeOf((**BandwidthControlRule)(nil)).Elem()
}

func (i *BandwidthControlRule) ToBandwidthControlRuleOutput() BandwidthControlRuleOutput {
	return i.ToBandwidthControlRuleOutputWithContext(context.Background())
}

func (i *BandwidthControlRule) ToBandwidthControlRuleOutputWithContext(ctx context.Context) BandwidthControlRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BandwidthControlRuleOutput)
}

// BandwidthControlRuleArrayInput is an input type that accepts BandwidthControlRuleArray and BandwidthControlRuleArrayOutput values.
// You can construct a concrete instance of `BandwidthControlRuleArrayInput` via:
//
//	BandwidthControlRuleArray{ BandwidthControlRuleArgs{...} }
type BandwidthControlRuleArrayInput interface {
	pulumi.Input

	ToBandwidthControlRuleArrayOutput() BandwidthControlRuleArrayOutput
	ToBandwidthControlRuleArrayOutputWithContext(context.Context) BandwidthControlRuleArrayOutput
}

type BandwidthControlRuleArray []BandwidthControlRuleInput

func (BandwidthControlRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BandwidthControlRule)(nil)).Elem()
}

func (i BandwidthControlRuleArray) ToBandwidthControlRuleArrayOutput() BandwidthControlRuleArrayOutput {
	return i.ToBandwidthControlRuleArrayOutputWithContext(context.Background())
}

func (i BandwidthControlRuleArray) ToBandwidthControlRuleArrayOutputWithContext(ctx context.Context) BandwidthControlRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BandwidthControlRuleArrayOutput)
}

// BandwidthControlRuleMapInput is an input type that accepts BandwidthControlRuleMap and BandwidthControlRuleMapOutput values.
// You can construct a concrete instance of `BandwidthControlRuleMapInput` via:
//
//	BandwidthControlRuleMap{ "key": BandwidthControlRuleArgs{...} }
type BandwidthControlRuleMapInput interface {
	pulumi.Input

	ToBandwidthControlRuleMapOutput() BandwidthControlRuleMapOutput
	ToBandwidthControlRuleMapOutputWithContext(context.Context) BandwidthControlRuleMapOutput
}

type BandwidthControlRuleMap map[string]BandwidthControlRuleInput

func (BandwidthControlRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BandwidthControlRule)(nil)).Elem()
}

func (i BandwidthControlRuleMap) ToBandwidthControlRuleMapOutput() BandwidthControlRuleMapOutput {
	return i.ToBandwidthControlRuleMapOutputWithContext(context.Background())
}

func (i BandwidthControlRuleMap) ToBandwidthControlRuleMapOutputWithContext(ctx context.Context) BandwidthControlRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BandwidthControlRuleMapOutput)
}

type BandwidthControlRuleOutput struct{ *pulumi.OutputState }

func (BandwidthControlRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BandwidthControlRule)(nil)).Elem()
}

func (o BandwidthControlRuleOutput) ToBandwidthControlRuleOutput() BandwidthControlRuleOutput {
	return o
}

func (o BandwidthControlRuleOutput) ToBandwidthControlRuleOutputWithContext(ctx context.Context) BandwidthControlRuleOutput {
	return o
}

// The bandwidth control rulees to which you want to apply this rule
func (o BandwidthControlRuleOutput) BandwidthClasses() BandwidthControlRuleBandwidthClassesPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) BandwidthControlRuleBandwidthClassesPtrOutput { return v.BandwidthClasses }).(BandwidthControlRuleBandwidthClassesPtrOutput)
}

// (Optional) Additional information about the rule
func (o BandwidthControlRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Labels that are applicable to the rule
func (o BandwidthControlRuleOutput) Labels() BandwidthControlRuleLabelsPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) BandwidthControlRuleLabelsPtrOutput { return v.Labels }).(BandwidthControlRuleLabelsPtrOutput)
}

// Name-ID pairs of the location groups to which the rule must be applied.
func (o BandwidthControlRuleOutput) LocationGroups() BandwidthControlRuleLocationGroupsPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) BandwidthControlRuleLocationGroupsPtrOutput { return v.LocationGroups }).(BandwidthControlRuleLocationGroupsPtrOutput)
}

// Name-ID pairs of locations for which rule must be applied
func (o BandwidthControlRuleOutput) Locations() BandwidthControlRuleLocationsPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) BandwidthControlRuleLocationsPtrOutput { return v.Locations }).(BandwidthControlRuleLocationsPtrOutput)
}

// (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
func (o BandwidthControlRuleOutput) MaxBandwidth() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.IntPtrOutput { return v.MaxBandwidth }).(pulumi.IntPtrOutput)
}

// (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
func (o BandwidthControlRuleOutput) MinBandwidth() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.IntPtrOutput { return v.MinBandwidth }).(pulumi.IntPtrOutput)
}

// The bandwidth control rule name
func (o BandwidthControlRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The order of the bandwidth control rule
func (o BandwidthControlRuleOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
func (o BandwidthControlRuleOutput) Protocols() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.StringArrayOutput { return v.Protocols }).(pulumi.StringArrayOutput)
}

// (Optional) Admin rank of the Bandwidth Control policy rule
func (o BandwidthControlRuleOutput) Rank() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.IntPtrOutput { return v.Rank }).(pulumi.IntPtrOutput)
}

func (o BandwidthControlRuleOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// (Optional) Administrative state of the rule.
func (o BandwidthControlRuleOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// The Name-ID pairs of time windows to which the bandwidth control rule must be applied
func (o BandwidthControlRuleOutput) TimeWindows() BandwidthControlRuleTimeWindowsPtrOutput {
	return o.ApplyT(func(v *BandwidthControlRule) BandwidthControlRuleTimeWindowsPtrOutput { return v.TimeWindows }).(BandwidthControlRuleTimeWindowsPtrOutput)
}

type BandwidthControlRuleArrayOutput struct{ *pulumi.OutputState }

func (BandwidthControlRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BandwidthControlRule)(nil)).Elem()
}

func (o BandwidthControlRuleArrayOutput) ToBandwidthControlRuleArrayOutput() BandwidthControlRuleArrayOutput {
	return o
}

func (o BandwidthControlRuleArrayOutput) ToBandwidthControlRuleArrayOutputWithContext(ctx context.Context) BandwidthControlRuleArrayOutput {
	return o
}

func (o BandwidthControlRuleArrayOutput) Index(i pulumi.IntInput) BandwidthControlRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BandwidthControlRule {
		return vs[0].([]*BandwidthControlRule)[vs[1].(int)]
	}).(BandwidthControlRuleOutput)
}

type BandwidthControlRuleMapOutput struct{ *pulumi.OutputState }

func (BandwidthControlRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BandwidthControlRule)(nil)).Elem()
}

func (o BandwidthControlRuleMapOutput) ToBandwidthControlRuleMapOutput() BandwidthControlRuleMapOutput {
	return o
}

func (o BandwidthControlRuleMapOutput) ToBandwidthControlRuleMapOutputWithContext(ctx context.Context) BandwidthControlRuleMapOutput {
	return o
}

func (o BandwidthControlRuleMapOutput) MapIndex(k pulumi.StringInput) BandwidthControlRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BandwidthControlRule {
		return vs[0].(map[string]*BandwidthControlRule)[vs[1].(string)]
	}).(BandwidthControlRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BandwidthControlRuleInput)(nil)).Elem(), &BandwidthControlRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*BandwidthControlRuleArrayInput)(nil)).Elem(), BandwidthControlRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BandwidthControlRuleMapInput)(nil)).Elem(), BandwidthControlRuleMap{})
	pulumi.RegisterOutputType(BandwidthControlRuleOutput{})
	pulumi.RegisterOutputType(BandwidthControlRuleArrayOutput{})
	pulumi.RegisterOutputType(BandwidthControlRuleMapOutput{})
}

// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// The **zia_file_type_control_rules** resource allows the creation and management of ZIA file type control rules in the Zscaler Internet Access.
//
// ## Example Usage
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
//
// # Visit
//
// **zia_file_type_control_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.
//
// For example:
//
// ```sh
// $ pulumi import zia:index/fileTypeControlRules:FileTypeControlRules example <rule_id>
// ```
//
// or
//
// ```sh
// $ pulumi import zia:index/fileTypeControlRules:FileTypeControlRules example <rule_name>
// ```
type FileTypeControlRules struct {
	pulumi.CustomResourceState

	// Flag to check whether a file has active content or not
	ActiveContent pulumi.BoolOutput `pulumi:"activeContent"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolOutput `pulumi:"capturePcap"`
	// The list of cloud applications to which the File Type Control rule must be applied.
	CloudApplications pulumi.StringArrayOutput `pulumi:"cloudApplications"`
	// The Name-ID pairs of departments to which the File Type Control rule must be applied.
	Departments FileTypeControlRulesDepartmentsPtrOutput `pulumi:"departments"`
	// The description of the File Type Control rule.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FileTypeControlRulesDeviceGroupsPtrOutput `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayOutput `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices FileTypeControlRulesDevicesPtrOutput `pulumi:"devices"`
	// File type categories for which the policy is applied. If not set, the rule is applied across all file types.
	FileTypes pulumi.StringArrayOutput `pulumi:"fileTypes"`
	// Action taken when traffic matches policy. This field is not applicable to the Lite API.
	FilteringAction pulumi.StringOutput `pulumi:"filteringAction"`
	// The Name-ID pairs of groups to which the File Type Control rule must be applied.
	Groups FileTypeControlRulesGroupsPtrOutput `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels FileTypeControlRulesLabelsPtrOutput `pulumi:"labels"`
	// Name-ID pairs of locations groups for which rule must be applied.
	LocationGroups FileTypeControlRulesLocationGroupsPtrOutput `pulumi:"locationGroups"`
	// Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
	Locations FileTypeControlRulesLocationsPtrOutput `pulumi:"locations"`
	// Maximum file size (in KB) used for evaluation of the FTP rule
	MaxSize pulumi.IntOutput `pulumi:"maxSize"`
	// Minimum file size (in KB) used for evaluation of the FTP rule
	MinSize pulumi.IntOutput `pulumi:"minSize"`
	// The File Type Control policy rule name.
	Name pulumi.StringOutput `pulumi:"name"`
	// File operation performed. This field is not applicable to the Lite API.
	Operation pulumi.StringOutput `pulumi:"operation"`
	// The rule order of execution for the File Type Control rule with respect to other rules.
	Order pulumi.IntOutput `pulumi:"order"`
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols pulumi.StringArrayOutput `pulumi:"protocols"`
	// Admin rank of the admin who creates this rule
	Rank   pulumi.IntOutput `pulumi:"rank"`
	RuleId pulumi.IntOutput `pulumi:"ruleId"`
	// Enables or disables the File Type Control rule.
	State pulumi.StringOutput `pulumi:"state"`
	// list of time interval during which rule must be enforced.
	TimeWindows FileTypeControlRulesTimeWindowsPtrOutput `pulumi:"timeWindows"`
	// Flag to check whether a file has active content or not
	Unscannable pulumi.BoolOutput `pulumi:"unscannable"`
	// List of URL categories for which rule must be applied
	UrlCategories pulumi.StringArrayOutput `pulumi:"urlCategories"`
	// The Name-ID pairs of users to which the File Type Control rule must be applied.
	Users FileTypeControlRulesUsersPtrOutput `pulumi:"users"`
	// List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
	ZpaAppSegments FileTypeControlRulesZpaAppSegmentArrayOutput `pulumi:"zpaAppSegments"`
}

// NewFileTypeControlRules registers a new resource with the given unique name, arguments, and options.
func NewFileTypeControlRules(ctx *pulumi.Context,
	name string, args *FileTypeControlRulesArgs, opts ...pulumi.ResourceOption) (*FileTypeControlRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	if args.Protocols == nil {
		return nil, errors.New("invalid value for required argument 'Protocols'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FileTypeControlRules
	err := ctx.RegisterResource("zia:index/fileTypeControlRules:FileTypeControlRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFileTypeControlRules gets an existing FileTypeControlRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFileTypeControlRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FileTypeControlRulesState, opts ...pulumi.ResourceOption) (*FileTypeControlRules, error) {
	var resource FileTypeControlRules
	err := ctx.ReadResource("zia:index/fileTypeControlRules:FileTypeControlRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FileTypeControlRules resources.
type fileTypeControlRulesState struct {
	// Flag to check whether a file has active content or not
	ActiveContent *bool `pulumi:"activeContent"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// The list of cloud applications to which the File Type Control rule must be applied.
	CloudApplications []string `pulumi:"cloudApplications"`
	// The Name-ID pairs of departments to which the File Type Control rule must be applied.
	Departments *FileTypeControlRulesDepartments `pulumi:"departments"`
	// The description of the File Type Control rule.
	Description *string `pulumi:"description"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *FileTypeControlRulesDeviceGroups `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels []string `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *FileTypeControlRulesDevices `pulumi:"devices"`
	// File type categories for which the policy is applied. If not set, the rule is applied across all file types.
	FileTypes []string `pulumi:"fileTypes"`
	// Action taken when traffic matches policy. This field is not applicable to the Lite API.
	FilteringAction *string `pulumi:"filteringAction"`
	// The Name-ID pairs of groups to which the File Type Control rule must be applied.
	Groups *FileTypeControlRulesGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *FileTypeControlRulesLabels `pulumi:"labels"`
	// Name-ID pairs of locations groups for which rule must be applied.
	LocationGroups *FileTypeControlRulesLocationGroups `pulumi:"locationGroups"`
	// Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
	Locations *FileTypeControlRulesLocations `pulumi:"locations"`
	// Maximum file size (in KB) used for evaluation of the FTP rule
	MaxSize *int `pulumi:"maxSize"`
	// Minimum file size (in KB) used for evaluation of the FTP rule
	MinSize *int `pulumi:"minSize"`
	// The File Type Control policy rule name.
	Name *string `pulumi:"name"`
	// File operation performed. This field is not applicable to the Lite API.
	Operation *string `pulumi:"operation"`
	// The rule order of execution for the File Type Control rule with respect to other rules.
	Order *int `pulumi:"order"`
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols []string `pulumi:"protocols"`
	// Admin rank of the admin who creates this rule
	Rank   *int `pulumi:"rank"`
	RuleId *int `pulumi:"ruleId"`
	// Enables or disables the File Type Control rule.
	State *string `pulumi:"state"`
	// list of time interval during which rule must be enforced.
	TimeWindows *FileTypeControlRulesTimeWindows `pulumi:"timeWindows"`
	// Flag to check whether a file has active content or not
	Unscannable *bool `pulumi:"unscannable"`
	// List of URL categories for which rule must be applied
	UrlCategories []string `pulumi:"urlCategories"`
	// The Name-ID pairs of users to which the File Type Control rule must be applied.
	Users *FileTypeControlRulesUsers `pulumi:"users"`
	// List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
	ZpaAppSegments []FileTypeControlRulesZpaAppSegment `pulumi:"zpaAppSegments"`
}

type FileTypeControlRulesState struct {
	// Flag to check whether a file has active content or not
	ActiveContent pulumi.BoolPtrInput
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// The list of cloud applications to which the File Type Control rule must be applied.
	CloudApplications pulumi.StringArrayInput
	// The Name-ID pairs of departments to which the File Type Control rule must be applied.
	Departments FileTypeControlRulesDepartmentsPtrInput
	// The description of the File Type Control rule.
	Description pulumi.StringPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FileTypeControlRulesDeviceGroupsPtrInput
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices FileTypeControlRulesDevicesPtrInput
	// File type categories for which the policy is applied. If not set, the rule is applied across all file types.
	FileTypes pulumi.StringArrayInput
	// Action taken when traffic matches policy. This field is not applicable to the Lite API.
	FilteringAction pulumi.StringPtrInput
	// The Name-ID pairs of groups to which the File Type Control rule must be applied.
	Groups FileTypeControlRulesGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels FileTypeControlRulesLabelsPtrInput
	// Name-ID pairs of locations groups for which rule must be applied.
	LocationGroups FileTypeControlRulesLocationGroupsPtrInput
	// Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
	Locations FileTypeControlRulesLocationsPtrInput
	// Maximum file size (in KB) used for evaluation of the FTP rule
	MaxSize pulumi.IntPtrInput
	// Minimum file size (in KB) used for evaluation of the FTP rule
	MinSize pulumi.IntPtrInput
	// The File Type Control policy rule name.
	Name pulumi.StringPtrInput
	// File operation performed. This field is not applicable to the Lite API.
	Operation pulumi.StringPtrInput
	// The rule order of execution for the File Type Control rule with respect to other rules.
	Order pulumi.IntPtrInput
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols pulumi.StringArrayInput
	// Admin rank of the admin who creates this rule
	Rank   pulumi.IntPtrInput
	RuleId pulumi.IntPtrInput
	// Enables or disables the File Type Control rule.
	State pulumi.StringPtrInput
	// list of time interval during which rule must be enforced.
	TimeWindows FileTypeControlRulesTimeWindowsPtrInput
	// Flag to check whether a file has active content or not
	Unscannable pulumi.BoolPtrInput
	// List of URL categories for which rule must be applied
	UrlCategories pulumi.StringArrayInput
	// The Name-ID pairs of users to which the File Type Control rule must be applied.
	Users FileTypeControlRulesUsersPtrInput
	// List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
	ZpaAppSegments FileTypeControlRulesZpaAppSegmentArrayInput
}

func (FileTypeControlRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*fileTypeControlRulesState)(nil)).Elem()
}

type fileTypeControlRulesArgs struct {
	// Flag to check whether a file has active content or not
	ActiveContent *bool `pulumi:"activeContent"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// The list of cloud applications to which the File Type Control rule must be applied.
	CloudApplications []string `pulumi:"cloudApplications"`
	// The Name-ID pairs of departments to which the File Type Control rule must be applied.
	Departments *FileTypeControlRulesDepartments `pulumi:"departments"`
	// The description of the File Type Control rule.
	Description *string `pulumi:"description"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *FileTypeControlRulesDeviceGroups `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels []string `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *FileTypeControlRulesDevices `pulumi:"devices"`
	// File type categories for which the policy is applied. If not set, the rule is applied across all file types.
	FileTypes []string `pulumi:"fileTypes"`
	// Action taken when traffic matches policy. This field is not applicable to the Lite API.
	FilteringAction *string `pulumi:"filteringAction"`
	// The Name-ID pairs of groups to which the File Type Control rule must be applied.
	Groups *FileTypeControlRulesGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *FileTypeControlRulesLabels `pulumi:"labels"`
	// Name-ID pairs of locations groups for which rule must be applied.
	LocationGroups *FileTypeControlRulesLocationGroups `pulumi:"locationGroups"`
	// Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
	Locations *FileTypeControlRulesLocations `pulumi:"locations"`
	// Maximum file size (in KB) used for evaluation of the FTP rule
	MaxSize *int `pulumi:"maxSize"`
	// Minimum file size (in KB) used for evaluation of the FTP rule
	MinSize *int `pulumi:"minSize"`
	// The File Type Control policy rule name.
	Name *string `pulumi:"name"`
	// File operation performed. This field is not applicable to the Lite API.
	Operation *string `pulumi:"operation"`
	// The rule order of execution for the File Type Control rule with respect to other rules.
	Order int `pulumi:"order"`
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols []string `pulumi:"protocols"`
	// Admin rank of the admin who creates this rule
	Rank *int `pulumi:"rank"`
	// Enables or disables the File Type Control rule.
	State *string `pulumi:"state"`
	// list of time interval during which rule must be enforced.
	TimeWindows *FileTypeControlRulesTimeWindows `pulumi:"timeWindows"`
	// Flag to check whether a file has active content or not
	Unscannable *bool `pulumi:"unscannable"`
	// List of URL categories for which rule must be applied
	UrlCategories []string `pulumi:"urlCategories"`
	// The Name-ID pairs of users to which the File Type Control rule must be applied.
	Users *FileTypeControlRulesUsers `pulumi:"users"`
	// List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
	ZpaAppSegments []FileTypeControlRulesZpaAppSegment `pulumi:"zpaAppSegments"`
}

// The set of arguments for constructing a FileTypeControlRules resource.
type FileTypeControlRulesArgs struct {
	// Flag to check whether a file has active content or not
	ActiveContent pulumi.BoolPtrInput
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// The list of cloud applications to which the File Type Control rule must be applied.
	CloudApplications pulumi.StringArrayInput
	// The Name-ID pairs of departments to which the File Type Control rule must be applied.
	Departments FileTypeControlRulesDepartmentsPtrInput
	// The description of the File Type Control rule.
	Description pulumi.StringPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FileTypeControlRulesDeviceGroupsPtrInput
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices FileTypeControlRulesDevicesPtrInput
	// File type categories for which the policy is applied. If not set, the rule is applied across all file types.
	FileTypes pulumi.StringArrayInput
	// Action taken when traffic matches policy. This field is not applicable to the Lite API.
	FilteringAction pulumi.StringPtrInput
	// The Name-ID pairs of groups to which the File Type Control rule must be applied.
	Groups FileTypeControlRulesGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels FileTypeControlRulesLabelsPtrInput
	// Name-ID pairs of locations groups for which rule must be applied.
	LocationGroups FileTypeControlRulesLocationGroupsPtrInput
	// Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
	Locations FileTypeControlRulesLocationsPtrInput
	// Maximum file size (in KB) used for evaluation of the FTP rule
	MaxSize pulumi.IntPtrInput
	// Minimum file size (in KB) used for evaluation of the FTP rule
	MinSize pulumi.IntPtrInput
	// The File Type Control policy rule name.
	Name pulumi.StringPtrInput
	// File operation performed. This field is not applicable to the Lite API.
	Operation pulumi.StringPtrInput
	// The rule order of execution for the File Type Control rule with respect to other rules.
	Order pulumi.IntInput
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols pulumi.StringArrayInput
	// Admin rank of the admin who creates this rule
	Rank pulumi.IntPtrInput
	// Enables or disables the File Type Control rule.
	State pulumi.StringPtrInput
	// list of time interval during which rule must be enforced.
	TimeWindows FileTypeControlRulesTimeWindowsPtrInput
	// Flag to check whether a file has active content or not
	Unscannable pulumi.BoolPtrInput
	// List of URL categories for which rule must be applied
	UrlCategories pulumi.StringArrayInput
	// The Name-ID pairs of users to which the File Type Control rule must be applied.
	Users FileTypeControlRulesUsersPtrInput
	// List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
	ZpaAppSegments FileTypeControlRulesZpaAppSegmentArrayInput
}

func (FileTypeControlRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fileTypeControlRulesArgs)(nil)).Elem()
}

type FileTypeControlRulesInput interface {
	pulumi.Input

	ToFileTypeControlRulesOutput() FileTypeControlRulesOutput
	ToFileTypeControlRulesOutputWithContext(ctx context.Context) FileTypeControlRulesOutput
}

func (*FileTypeControlRules) ElementType() reflect.Type {
	return reflect.TypeOf((**FileTypeControlRules)(nil)).Elem()
}

func (i *FileTypeControlRules) ToFileTypeControlRulesOutput() FileTypeControlRulesOutput {
	return i.ToFileTypeControlRulesOutputWithContext(context.Background())
}

func (i *FileTypeControlRules) ToFileTypeControlRulesOutputWithContext(ctx context.Context) FileTypeControlRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileTypeControlRulesOutput)
}

// FileTypeControlRulesArrayInput is an input type that accepts FileTypeControlRulesArray and FileTypeControlRulesArrayOutput values.
// You can construct a concrete instance of `FileTypeControlRulesArrayInput` via:
//
//	FileTypeControlRulesArray{ FileTypeControlRulesArgs{...} }
type FileTypeControlRulesArrayInput interface {
	pulumi.Input

	ToFileTypeControlRulesArrayOutput() FileTypeControlRulesArrayOutput
	ToFileTypeControlRulesArrayOutputWithContext(context.Context) FileTypeControlRulesArrayOutput
}

type FileTypeControlRulesArray []FileTypeControlRulesInput

func (FileTypeControlRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FileTypeControlRules)(nil)).Elem()
}

func (i FileTypeControlRulesArray) ToFileTypeControlRulesArrayOutput() FileTypeControlRulesArrayOutput {
	return i.ToFileTypeControlRulesArrayOutputWithContext(context.Background())
}

func (i FileTypeControlRulesArray) ToFileTypeControlRulesArrayOutputWithContext(ctx context.Context) FileTypeControlRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileTypeControlRulesArrayOutput)
}

// FileTypeControlRulesMapInput is an input type that accepts FileTypeControlRulesMap and FileTypeControlRulesMapOutput values.
// You can construct a concrete instance of `FileTypeControlRulesMapInput` via:
//
//	FileTypeControlRulesMap{ "key": FileTypeControlRulesArgs{...} }
type FileTypeControlRulesMapInput interface {
	pulumi.Input

	ToFileTypeControlRulesMapOutput() FileTypeControlRulesMapOutput
	ToFileTypeControlRulesMapOutputWithContext(context.Context) FileTypeControlRulesMapOutput
}

type FileTypeControlRulesMap map[string]FileTypeControlRulesInput

func (FileTypeControlRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FileTypeControlRules)(nil)).Elem()
}

func (i FileTypeControlRulesMap) ToFileTypeControlRulesMapOutput() FileTypeControlRulesMapOutput {
	return i.ToFileTypeControlRulesMapOutputWithContext(context.Background())
}

func (i FileTypeControlRulesMap) ToFileTypeControlRulesMapOutputWithContext(ctx context.Context) FileTypeControlRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileTypeControlRulesMapOutput)
}

type FileTypeControlRulesOutput struct{ *pulumi.OutputState }

func (FileTypeControlRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileTypeControlRules)(nil)).Elem()
}

func (o FileTypeControlRulesOutput) ToFileTypeControlRulesOutput() FileTypeControlRulesOutput {
	return o
}

func (o FileTypeControlRulesOutput) ToFileTypeControlRulesOutputWithContext(ctx context.Context) FileTypeControlRulesOutput {
	return o
}

// Flag to check whether a file has active content or not
func (o FileTypeControlRulesOutput) ActiveContent() pulumi.BoolOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.BoolOutput { return v.ActiveContent }).(pulumi.BoolOutput)
}

// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
func (o FileTypeControlRulesOutput) CapturePcap() pulumi.BoolOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.BoolOutput { return v.CapturePcap }).(pulumi.BoolOutput)
}

// The list of cloud applications to which the File Type Control rule must be applied.
func (o FileTypeControlRulesOutput) CloudApplications() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringArrayOutput { return v.CloudApplications }).(pulumi.StringArrayOutput)
}

// The Name-ID pairs of departments to which the File Type Control rule must be applied.
func (o FileTypeControlRulesOutput) Departments() FileTypeControlRulesDepartmentsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesDepartmentsPtrOutput { return v.Departments }).(FileTypeControlRulesDepartmentsPtrOutput)
}

// The description of the File Type Control rule.
func (o FileTypeControlRulesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// This field is applicable for devices that are managed using Zscaler Client Connector.
func (o FileTypeControlRulesOutput) DeviceGroups() FileTypeControlRulesDeviceGroupsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesDeviceGroupsPtrOutput { return v.DeviceGroups }).(FileTypeControlRulesDeviceGroupsPtrOutput)
}

// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
func (o FileTypeControlRulesOutput) DeviceTrustLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringArrayOutput { return v.DeviceTrustLevels }).(pulumi.StringArrayOutput)
}

// Name-ID pairs of devices for which rule must be applied.
func (o FileTypeControlRulesOutput) Devices() FileTypeControlRulesDevicesPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesDevicesPtrOutput { return v.Devices }).(FileTypeControlRulesDevicesPtrOutput)
}

// File type categories for which the policy is applied. If not set, the rule is applied across all file types.
func (o FileTypeControlRulesOutput) FileTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringArrayOutput { return v.FileTypes }).(pulumi.StringArrayOutput)
}

// Action taken when traffic matches policy. This field is not applicable to the Lite API.
func (o FileTypeControlRulesOutput) FilteringAction() pulumi.StringOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringOutput { return v.FilteringAction }).(pulumi.StringOutput)
}

// The Name-ID pairs of groups to which the File Type Control rule must be applied.
func (o FileTypeControlRulesOutput) Groups() FileTypeControlRulesGroupsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesGroupsPtrOutput { return v.Groups }).(FileTypeControlRulesGroupsPtrOutput)
}

// list of Labels that are applicable to the rule.
func (o FileTypeControlRulesOutput) Labels() FileTypeControlRulesLabelsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesLabelsPtrOutput { return v.Labels }).(FileTypeControlRulesLabelsPtrOutput)
}

// Name-ID pairs of locations groups for which rule must be applied.
func (o FileTypeControlRulesOutput) LocationGroups() FileTypeControlRulesLocationGroupsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesLocationGroupsPtrOutput { return v.LocationGroups }).(FileTypeControlRulesLocationGroupsPtrOutput)
}

// Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
func (o FileTypeControlRulesOutput) Locations() FileTypeControlRulesLocationsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesLocationsPtrOutput { return v.Locations }).(FileTypeControlRulesLocationsPtrOutput)
}

// Maximum file size (in KB) used for evaluation of the FTP rule
func (o FileTypeControlRulesOutput) MaxSize() pulumi.IntOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.IntOutput { return v.MaxSize }).(pulumi.IntOutput)
}

// Minimum file size (in KB) used for evaluation of the FTP rule
func (o FileTypeControlRulesOutput) MinSize() pulumi.IntOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.IntOutput { return v.MinSize }).(pulumi.IntOutput)
}

// The File Type Control policy rule name.
func (o FileTypeControlRulesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// File operation performed. This field is not applicable to the Lite API.
func (o FileTypeControlRulesOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringOutput { return v.Operation }).(pulumi.StringOutput)
}

// The rule order of execution for the File Type Control rule with respect to other rules.
func (o FileTypeControlRulesOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// Protocol for the given rule. This field is not applicable to the Lite API.
func (o FileTypeControlRulesOutput) Protocols() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringArrayOutput { return v.Protocols }).(pulumi.StringArrayOutput)
}

// Admin rank of the admin who creates this rule
func (o FileTypeControlRulesOutput) Rank() pulumi.IntOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.IntOutput { return v.Rank }).(pulumi.IntOutput)
}

func (o FileTypeControlRulesOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// Enables or disables the File Type Control rule.
func (o FileTypeControlRulesOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// list of time interval during which rule must be enforced.
func (o FileTypeControlRulesOutput) TimeWindows() FileTypeControlRulesTimeWindowsPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesTimeWindowsPtrOutput { return v.TimeWindows }).(FileTypeControlRulesTimeWindowsPtrOutput)
}

// Flag to check whether a file has active content or not
func (o FileTypeControlRulesOutput) Unscannable() pulumi.BoolOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.BoolOutput { return v.Unscannable }).(pulumi.BoolOutput)
}

// List of URL categories for which rule must be applied
func (o FileTypeControlRulesOutput) UrlCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileTypeControlRules) pulumi.StringArrayOutput { return v.UrlCategories }).(pulumi.StringArrayOutput)
}

// The Name-ID pairs of users to which the File Type Control rule must be applied.
func (o FileTypeControlRulesOutput) Users() FileTypeControlRulesUsersPtrOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesUsersPtrOutput { return v.Users }).(FileTypeControlRulesUsersPtrOutput)
}

// List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
func (o FileTypeControlRulesOutput) ZpaAppSegments() FileTypeControlRulesZpaAppSegmentArrayOutput {
	return o.ApplyT(func(v *FileTypeControlRules) FileTypeControlRulesZpaAppSegmentArrayOutput { return v.ZpaAppSegments }).(FileTypeControlRulesZpaAppSegmentArrayOutput)
}

type FileTypeControlRulesArrayOutput struct{ *pulumi.OutputState }

func (FileTypeControlRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FileTypeControlRules)(nil)).Elem()
}

func (o FileTypeControlRulesArrayOutput) ToFileTypeControlRulesArrayOutput() FileTypeControlRulesArrayOutput {
	return o
}

func (o FileTypeControlRulesArrayOutput) ToFileTypeControlRulesArrayOutputWithContext(ctx context.Context) FileTypeControlRulesArrayOutput {
	return o
}

func (o FileTypeControlRulesArrayOutput) Index(i pulumi.IntInput) FileTypeControlRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FileTypeControlRules {
		return vs[0].([]*FileTypeControlRules)[vs[1].(int)]
	}).(FileTypeControlRulesOutput)
}

type FileTypeControlRulesMapOutput struct{ *pulumi.OutputState }

func (FileTypeControlRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FileTypeControlRules)(nil)).Elem()
}

func (o FileTypeControlRulesMapOutput) ToFileTypeControlRulesMapOutput() FileTypeControlRulesMapOutput {
	return o
}

func (o FileTypeControlRulesMapOutput) ToFileTypeControlRulesMapOutputWithContext(ctx context.Context) FileTypeControlRulesMapOutput {
	return o
}

func (o FileTypeControlRulesMapOutput) MapIndex(k pulumi.StringInput) FileTypeControlRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FileTypeControlRules {
		return vs[0].(map[string]*FileTypeControlRules)[vs[1].(string)]
	}).(FileTypeControlRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FileTypeControlRulesInput)(nil)).Elem(), &FileTypeControlRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileTypeControlRulesArrayInput)(nil)).Elem(), FileTypeControlRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileTypeControlRulesMapInput)(nil)).Elem(), FileTypeControlRulesMap{})
	pulumi.RegisterOutputType(FileTypeControlRulesOutput{})
	pulumi.RegisterOutputType(FileTypeControlRulesArrayOutput{})
	pulumi.RegisterOutputType(FileTypeControlRulesMapOutput{})
}

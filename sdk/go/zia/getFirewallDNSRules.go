// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// Use the **zia_firewall_dns_rule** data source to get information about a cloud firewall DNS rule available in the Zscaler Internet Access.
//
// ## Example Usage
func GetFirewallDNSRules(ctx *pulumi.Context, args *GetFirewallDNSRulesArgs, opts ...pulumi.InvokeOption) (*GetFirewallDNSRulesResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv GetFirewallDNSRulesResult
	err := ctx.Invoke("zia:index/getFirewallDNSRules:getFirewallDNSRules", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking getFirewallDNSRules.
type GetFirewallDNSRulesArgs struct {
	// Unique identifier for the Firewall Filtering policy rule
	Id *int `pulumi:"id"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
}

// A collection of values returned by getFirewallDNSRules.
type GetFirewallDNSRulesResult struct {
	// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
	Action string `pulumi:"action"`
	// (List of Objects) DNS application groups to which the rule applies
	ApplicationGroups []GetFirewallDNSRulesApplicationGroup `pulumi:"applicationGroups"`
	// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
	Applications []string `pulumi:"applications"`
	// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
	// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
	BlockResponseCode string `pulumi:"blockResponseCode"`
	// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap bool `pulumi:"capturePcap"`
	// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
	DefaultRule bool `pulumi:"defaultRule"`
	// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
	Departments []GetFirewallDNSRulesDepartment `pulumi:"departments"`
	// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
	Description string `pulumi:"description"`
	// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	DestAddresses []string `pulumi:"destAddresses"`
	// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	DestCountries []string `pulumi:"destCountries"`
	// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
	DestIpCategories []string `pulumi:"destIpCategories"`
	// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
	DestIpGroups   []GetFirewallDNSRulesDestIpGroup   `pulumi:"destIpGroups"`
	DestIpv6Groups []GetFirewallDNSRulesDestIpv6Group `pulumi:"destIpv6Groups"`
	// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	DeviceGroups []GetFirewallDNSRulesDeviceGroup `pulumi:"deviceGroups"`
	// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	Devices []GetFirewallDNSRulesDevice `pulumi:"devices"`
	// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
	// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
	// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
	// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
	// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
	// `ZONEMD`, `SVCB`, `HTTPS`,
	DnsRuleRequestTypes []string `pulumi:"dnsRuleRequestTypes"`
	// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
	Groups []GetFirewallDNSRulesGroup `pulumi:"groups"`
	// (Integer) Identifier that uniquely identifies an entity
	Id int `pulumi:"id"`
	// (List of Objects) Labels that are applicable to the rule.
	Labels           []GetFirewallDNSRulesLabel          `pulumi:"labels"`
	LastModifiedBies []GetFirewallDNSRulesLastModifiedBy `pulumi:"lastModifiedBies"`
	LastModifiedTime int                                 `pulumi:"lastModifiedTime"`
	// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
	LocationGroups []GetFirewallDNSRulesLocationGroup `pulumi:"locationGroups"`
	// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
	Locations []GetFirewallDNSRulesLocation `pulumi:"locations"`
	// (string) The configured name of the entity
	Name string `pulumi:"name"`
	// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
	Order int `pulumi:"order"`
	// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
	Predefined bool `pulumi:"predefined"`
	// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
	Protocols []string `pulumi:"protocols"`
	// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
	Rank int `pulumi:"rank"`
	// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
	RedirectIp string `pulumi:"redirectIp"`
	// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	SourceCountries []string `pulumi:"sourceCountries"`
	// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
	SrcIpGroups []GetFirewallDNSRulesSrcIpGroup `pulumi:"srcIpGroups"`
	// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	SrcIps []string `pulumi:"srcIps"`
	// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
	SrcIpv6Groups []GetFirewallDNSRulesSrcIpv6Group `pulumi:"srcIpv6Groups"`
	// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
	State string `pulumi:"state"`
	// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
	TimeWindows []GetFirewallDNSRulesTimeWindow `pulumi:"timeWindows"`
	// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
	Users []GetFirewallDNSRulesUser `pulumi:"users"`
}

func GetFirewallDNSRulesOutput(ctx *pulumi.Context, args GetFirewallDNSRulesOutputArgs, opts ...pulumi.InvokeOption) GetFirewallDNSRulesResultOutput {
	return pulumi.ToOutputWithContext(ctx.Context(), args).
		ApplyT(func(v interface{}) (GetFirewallDNSRulesResultOutput, error) {
			args := v.(GetFirewallDNSRulesArgs)
			options := pulumi.InvokeOutputOptions{InvokeOptions: internal.PkgInvokeDefaultOpts(opts)}
			return ctx.InvokeOutput("zia:index/getFirewallDNSRules:getFirewallDNSRules", args, GetFirewallDNSRulesResultOutput{}, options).(GetFirewallDNSRulesResultOutput), nil
		}).(GetFirewallDNSRulesResultOutput)
}

// A collection of arguments for invoking getFirewallDNSRules.
type GetFirewallDNSRulesOutputArgs struct {
	// Unique identifier for the Firewall Filtering policy rule
	Id pulumi.IntPtrInput `pulumi:"id"`
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (GetFirewallDNSRulesOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetFirewallDNSRulesArgs)(nil)).Elem()
}

// A collection of values returned by getFirewallDNSRules.
type GetFirewallDNSRulesResultOutput struct{ *pulumi.OutputState }

func (GetFirewallDNSRulesResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetFirewallDNSRulesResult)(nil)).Elem()
}

func (o GetFirewallDNSRulesResultOutput) ToGetFirewallDNSRulesResultOutput() GetFirewallDNSRulesResultOutput {
	return o
}

func (o GetFirewallDNSRulesResultOutput) ToGetFirewallDNSRulesResultOutputWithContext(ctx context.Context) GetFirewallDNSRulesResultOutput {
	return o
}

// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
func (o GetFirewallDNSRulesResultOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) string { return v.Action }).(pulumi.StringOutput)
}

// (List of Objects) DNS application groups to which the rule applies
func (o GetFirewallDNSRulesResultOutput) ApplicationGroups() GetFirewallDNSRulesApplicationGroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesApplicationGroup { return v.ApplicationGroups }).(GetFirewallDNSRulesApplicationGroupArrayOutput)
}

// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
func (o GetFirewallDNSRulesResultOutput) Applications() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.Applications }).(pulumi.StringArrayOutput)
}

// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
func (o GetFirewallDNSRulesResultOutput) BlockResponseCode() pulumi.StringOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) string { return v.BlockResponseCode }).(pulumi.StringOutput)
}

// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
func (o GetFirewallDNSRulesResultOutput) CapturePcap() pulumi.BoolOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) bool { return v.CapturePcap }).(pulumi.BoolOutput)
}

// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
func (o GetFirewallDNSRulesResultOutput) DefaultRule() pulumi.BoolOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) bool { return v.DefaultRule }).(pulumi.BoolOutput)
}

// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
func (o GetFirewallDNSRulesResultOutput) Departments() GetFirewallDNSRulesDepartmentArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesDepartment { return v.Departments }).(GetFirewallDNSRulesDepartmentArrayOutput)
}

// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
func (o GetFirewallDNSRulesResultOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) string { return v.Description }).(pulumi.StringOutput)
}

// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
func (o GetFirewallDNSRulesResultOutput) DestAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.DestAddresses }).(pulumi.StringArrayOutput)
}

// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e “"US"“, “"CA"“
func (o GetFirewallDNSRulesResultOutput) DestCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.DestCountries }).(pulumi.StringArrayOutput)
}

// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
func (o GetFirewallDNSRulesResultOutput) DestIpCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.DestIpCategories }).(pulumi.StringArrayOutput)
}

// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
func (o GetFirewallDNSRulesResultOutput) DestIpGroups() GetFirewallDNSRulesDestIpGroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesDestIpGroup { return v.DestIpGroups }).(GetFirewallDNSRulesDestIpGroupArrayOutput)
}

func (o GetFirewallDNSRulesResultOutput) DestIpv6Groups() GetFirewallDNSRulesDestIpv6GroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesDestIpv6Group { return v.DestIpv6Groups }).(GetFirewallDNSRulesDestIpv6GroupArrayOutput)
}

// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
func (o GetFirewallDNSRulesResultOutput) DeviceGroups() GetFirewallDNSRulesDeviceGroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesDeviceGroup { return v.DeviceGroups }).(GetFirewallDNSRulesDeviceGroupArrayOutput)
}

// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
func (o GetFirewallDNSRulesResultOutput) Devices() GetFirewallDNSRulesDeviceArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesDevice { return v.Devices }).(GetFirewallDNSRulesDeviceArrayOutput)
}

// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
// `ZONEMD`, `SVCB`, `HTTPS`,
func (o GetFirewallDNSRulesResultOutput) DnsRuleRequestTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.DnsRuleRequestTypes }).(pulumi.StringArrayOutput)
}

// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
func (o GetFirewallDNSRulesResultOutput) Groups() GetFirewallDNSRulesGroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesGroup { return v.Groups }).(GetFirewallDNSRulesGroupArrayOutput)
}

// (Integer) Identifier that uniquely identifies an entity
func (o GetFirewallDNSRulesResultOutput) Id() pulumi.IntOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) int { return v.Id }).(pulumi.IntOutput)
}

// (List of Objects) Labels that are applicable to the rule.
func (o GetFirewallDNSRulesResultOutput) Labels() GetFirewallDNSRulesLabelArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesLabel { return v.Labels }).(GetFirewallDNSRulesLabelArrayOutput)
}

func (o GetFirewallDNSRulesResultOutput) LastModifiedBies() GetFirewallDNSRulesLastModifiedByArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesLastModifiedBy { return v.LastModifiedBies }).(GetFirewallDNSRulesLastModifiedByArrayOutput)
}

func (o GetFirewallDNSRulesResultOutput) LastModifiedTime() pulumi.IntOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) int { return v.LastModifiedTime }).(pulumi.IntOutput)
}

// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
func (o GetFirewallDNSRulesResultOutput) LocationGroups() GetFirewallDNSRulesLocationGroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesLocationGroup { return v.LocationGroups }).(GetFirewallDNSRulesLocationGroupArrayOutput)
}

// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
func (o GetFirewallDNSRulesResultOutput) Locations() GetFirewallDNSRulesLocationArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesLocation { return v.Locations }).(GetFirewallDNSRulesLocationArrayOutput)
}

// (string) The configured name of the entity
func (o GetFirewallDNSRulesResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) string { return v.Name }).(pulumi.StringOutput)
}

// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
func (o GetFirewallDNSRulesResultOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) int { return v.Order }).(pulumi.IntOutput)
}

// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
func (o GetFirewallDNSRulesResultOutput) Predefined() pulumi.BoolOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) bool { return v.Predefined }).(pulumi.BoolOutput)
}

// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
func (o GetFirewallDNSRulesResultOutput) Protocols() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.Protocols }).(pulumi.StringArrayOutput)
}

// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
func (o GetFirewallDNSRulesResultOutput) Rank() pulumi.IntOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) int { return v.Rank }).(pulumi.IntOutput)
}

// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
func (o GetFirewallDNSRulesResultOutput) RedirectIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) string { return v.RedirectIp }).(pulumi.StringOutput)
}

// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
func (o GetFirewallDNSRulesResultOutput) ResCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.ResCategories }).(pulumi.StringArrayOutput)
}

// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e “"US"“, “"CA"“
func (o GetFirewallDNSRulesResultOutput) SourceCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.SourceCountries }).(pulumi.StringArrayOutput)
}

// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
func (o GetFirewallDNSRulesResultOutput) SrcIpGroups() GetFirewallDNSRulesSrcIpGroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesSrcIpGroup { return v.SrcIpGroups }).(GetFirewallDNSRulesSrcIpGroupArrayOutput)
}

// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
func (o GetFirewallDNSRulesResultOutput) SrcIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []string { return v.SrcIps }).(pulumi.StringArrayOutput)
}

// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
func (o GetFirewallDNSRulesResultOutput) SrcIpv6Groups() GetFirewallDNSRulesSrcIpv6GroupArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesSrcIpv6Group { return v.SrcIpv6Groups }).(GetFirewallDNSRulesSrcIpv6GroupArrayOutput)
}

// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
func (o GetFirewallDNSRulesResultOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) string { return v.State }).(pulumi.StringOutput)
}

// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
func (o GetFirewallDNSRulesResultOutput) TimeWindows() GetFirewallDNSRulesTimeWindowArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesTimeWindow { return v.TimeWindows }).(GetFirewallDNSRulesTimeWindowArrayOutput)
}

// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
func (o GetFirewallDNSRulesResultOutput) Users() GetFirewallDNSRulesUserArrayOutput {
	return o.ApplyT(func(v GetFirewallDNSRulesResult) []GetFirewallDNSRulesUser { return v.Users }).(GetFirewallDNSRulesUserArrayOutput)
}

func init() {
	pulumi.RegisterOutputType(GetFirewallDNSRulesResultOutput{})
}

// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

type FirewallIPSRule struct {
	pulumi.CustomResourceState

	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or
	// blocking the traffic or bypassing the rule.
	Action pulumi.StringPtrOutput `pulumi:"action"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolOutput `pulumi:"capturePcap"`
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrOutput `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments FirewallIPSRuleDepartmentsPtrOutput `pulumi:"departments"`
	// Additional information about the rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayOutput `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries    pulumi.StringArrayOutput `pulumi:"destCountries"`
	DestIpCategories pulumi.StringArrayOutput `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups FirewallIPSRuleDestIpGroupsPtrOutput `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups FirewallIPSRuleDestIpv6GroupsPtrOutput `pulumi:"destIpv6Groups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FirewallIPSRuleDeviceGroupsPtrOutput `pulumi:"deviceGroups"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices FirewallIPSRuleDevicesPtrOutput `pulumi:"devices"`
	// A Boolean value that indicates whether full logging is enabled. A true value indicates that full logging is enabled,
	// whereas a false value indicates that aggregate logging is enabled.
	EnableFullLogging pulumi.BoolPtrOutput `pulumi:"enableFullLogging"`
	// list of groups for which rule must be applied
	Groups FirewallIPSRuleGroupsPtrOutput `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels FirewallIPSRuleLabelsPtrOutput `pulumi:"labels"`
	// list of locations groups
	LocationGroups FirewallIPSRuleLocationGroupsPtrOutput `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations FirewallIPSRuleLocationsPtrOutput `pulumi:"locations"`
	// The name of the IPS Control rule
	Name pulumi.StringOutput `pulumi:"name"`
	// list of nw service groups
	NwServiceGroups FirewallIPSRuleNwServiceGroupsPtrOutput `pulumi:"nwServiceGroups"`
	// list of nw services
	NwServices FirewallIPSRuleNwServicesPtrOutput `pulumi:"nwServices"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntOutput `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrOutput `pulumi:"predefined"`
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank pulumi.IntPtrOutput `pulumi:"rank"`
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories pulumi.StringArrayOutput `pulumi:"resCategories"`
	RuleId        pulumi.IntOutput         `pulumi:"ruleId"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries pulumi.StringArrayOutput `pulumi:"sourceCountries"`
	// list of source ip groups
	SrcIpGroups FirewallIPSRuleSrcIpGroupsPtrOutput `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps pulumi.StringArrayOutput `pulumi:"srcIps"`
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups FirewallIPSRuleSrcIpv6GroupsPtrOutput `pulumi:"srcIpv6Groups"`
	// The state of the rule indicating whether it is enabled or disabled
	State pulumi.StringPtrOutput `pulumi:"state"`
	// list of Advanced threat categories to which the rule applies
	ThreatCategories FirewallIPSRuleThreatCategoriesPtrOutput `pulumi:"threatCategories"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows FirewallIPSRuleTimeWindowsPtrOutput `pulumi:"timeWindows"`
	// list of users for which rule must be applied
	Users FirewallIPSRuleUsersPtrOutput `pulumi:"users"`
	// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
	// Gateway forwarding method.
	ZpaAppSegments FirewallIPSRuleZpaAppSegmentArrayOutput `pulumi:"zpaAppSegments"`
}

// NewFirewallIPSRule registers a new resource with the given unique name, arguments, and options.
func NewFirewallIPSRule(ctx *pulumi.Context,
	name string, args *FirewallIPSRuleArgs, opts ...pulumi.ResourceOption) (*FirewallIPSRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FirewallIPSRule
	err := ctx.RegisterResource("zia:index/firewallIPSRule:FirewallIPSRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirewallIPSRule gets an existing FirewallIPSRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirewallIPSRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirewallIPSRuleState, opts ...pulumi.ResourceOption) (*FirewallIPSRule, error) {
	var resource FirewallIPSRule
	err := ctx.ReadResource("zia:index/firewallIPSRule:FirewallIPSRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FirewallIPSRule resources.
type firewallIPSRuleState struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or
	// blocking the traffic or bypassing the rule.
	Action *string `pulumi:"action"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// If set to true, the default rule is applied
	DefaultRule *bool `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments *FirewallIPSRuleDepartments `pulumi:"departments"`
	// Additional information about the rule
	Description *string `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses []string `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries    []string `pulumi:"destCountries"`
	DestIpCategories []string `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups *FirewallIPSRuleDestIpGroups `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups *FirewallIPSRuleDestIpv6Groups `pulumi:"destIpv6Groups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *FirewallIPSRuleDeviceGroups `pulumi:"deviceGroups"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *FirewallIPSRuleDevices `pulumi:"devices"`
	// A Boolean value that indicates whether full logging is enabled. A true value indicates that full logging is enabled,
	// whereas a false value indicates that aggregate logging is enabled.
	EnableFullLogging *bool `pulumi:"enableFullLogging"`
	// list of groups for which rule must be applied
	Groups *FirewallIPSRuleGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *FirewallIPSRuleLabels `pulumi:"labels"`
	// list of locations groups
	LocationGroups *FirewallIPSRuleLocationGroups `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations *FirewallIPSRuleLocations `pulumi:"locations"`
	// The name of the IPS Control rule
	Name *string `pulumi:"name"`
	// list of nw service groups
	NwServiceGroups *FirewallIPSRuleNwServiceGroups `pulumi:"nwServiceGroups"`
	// list of nw services
	NwServices *FirewallIPSRuleNwServices `pulumi:"nwServices"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order *int `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined *bool `pulumi:"predefined"`
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank *int `pulumi:"rank"`
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	RuleId        *int     `pulumi:"ruleId"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries []string `pulumi:"sourceCountries"`
	// list of source ip groups
	SrcIpGroups *FirewallIPSRuleSrcIpGroups `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps []string `pulumi:"srcIps"`
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups *FirewallIPSRuleSrcIpv6Groups `pulumi:"srcIpv6Groups"`
	// The state of the rule indicating whether it is enabled or disabled
	State *string `pulumi:"state"`
	// list of Advanced threat categories to which the rule applies
	ThreatCategories *FirewallIPSRuleThreatCategories `pulumi:"threatCategories"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows *FirewallIPSRuleTimeWindows `pulumi:"timeWindows"`
	// list of users for which rule must be applied
	Users *FirewallIPSRuleUsers `pulumi:"users"`
	// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
	// Gateway forwarding method.
	ZpaAppSegments []FirewallIPSRuleZpaAppSegment `pulumi:"zpaAppSegments"`
}

type FirewallIPSRuleState struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or
	// blocking the traffic or bypassing the rule.
	Action pulumi.StringPtrInput
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrInput
	// list of departments for which rule must be applied
	Departments FirewallIPSRuleDepartmentsPtrInput
	// Additional information about the rule
	Description pulumi.StringPtrInput
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries    pulumi.StringArrayInput
	DestIpCategories pulumi.StringArrayInput
	// list of destination ip groups
	DestIpGroups FirewallIPSRuleDestIpGroupsPtrInput
	// list of destination ip groups
	DestIpv6Groups FirewallIPSRuleDestIpv6GroupsPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FirewallIPSRuleDeviceGroupsPtrInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices FirewallIPSRuleDevicesPtrInput
	// A Boolean value that indicates whether full logging is enabled. A true value indicates that full logging is enabled,
	// whereas a false value indicates that aggregate logging is enabled.
	EnableFullLogging pulumi.BoolPtrInput
	// list of groups for which rule must be applied
	Groups FirewallIPSRuleGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels FirewallIPSRuleLabelsPtrInput
	// list of locations groups
	LocationGroups FirewallIPSRuleLocationGroupsPtrInput
	// list of locations for which rule must be applied
	Locations FirewallIPSRuleLocationsPtrInput
	// The name of the IPS Control rule
	Name pulumi.StringPtrInput
	// list of nw service groups
	NwServiceGroups FirewallIPSRuleNwServiceGroupsPtrInput
	// list of nw services
	NwServices FirewallIPSRuleNwServicesPtrInput
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntPtrInput
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrInput
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank pulumi.IntPtrInput
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories pulumi.StringArrayInput
	RuleId        pulumi.IntPtrInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries pulumi.StringArrayInput
	// list of source ip groups
	SrcIpGroups FirewallIPSRuleSrcIpGroupsPtrInput
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps pulumi.StringArrayInput
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups FirewallIPSRuleSrcIpv6GroupsPtrInput
	// The state of the rule indicating whether it is enabled or disabled
	State pulumi.StringPtrInput
	// list of Advanced threat categories to which the rule applies
	ThreatCategories FirewallIPSRuleThreatCategoriesPtrInput
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows FirewallIPSRuleTimeWindowsPtrInput
	// list of users for which rule must be applied
	Users FirewallIPSRuleUsersPtrInput
	// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
	// Gateway forwarding method.
	ZpaAppSegments FirewallIPSRuleZpaAppSegmentArrayInput
}

func (FirewallIPSRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallIPSRuleState)(nil)).Elem()
}

type firewallIPSRuleArgs struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or
	// blocking the traffic or bypassing the rule.
	Action *string `pulumi:"action"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// If set to true, the default rule is applied
	DefaultRule *bool `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments *FirewallIPSRuleDepartments `pulumi:"departments"`
	// Additional information about the rule
	Description *string `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses []string `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries    []string `pulumi:"destCountries"`
	DestIpCategories []string `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups *FirewallIPSRuleDestIpGroups `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups *FirewallIPSRuleDestIpv6Groups `pulumi:"destIpv6Groups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *FirewallIPSRuleDeviceGroups `pulumi:"deviceGroups"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *FirewallIPSRuleDevices `pulumi:"devices"`
	// A Boolean value that indicates whether full logging is enabled. A true value indicates that full logging is enabled,
	// whereas a false value indicates that aggregate logging is enabled.
	EnableFullLogging *bool `pulumi:"enableFullLogging"`
	// list of groups for which rule must be applied
	Groups *FirewallIPSRuleGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *FirewallIPSRuleLabels `pulumi:"labels"`
	// list of locations groups
	LocationGroups *FirewallIPSRuleLocationGroups `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations *FirewallIPSRuleLocations `pulumi:"locations"`
	// The name of the IPS Control rule
	Name *string `pulumi:"name"`
	// list of nw service groups
	NwServiceGroups *FirewallIPSRuleNwServiceGroups `pulumi:"nwServiceGroups"`
	// list of nw services
	NwServices *FirewallIPSRuleNwServices `pulumi:"nwServices"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order int `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined *bool `pulumi:"predefined"`
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank *int `pulumi:"rank"`
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries []string `pulumi:"sourceCountries"`
	// list of source ip groups
	SrcIpGroups *FirewallIPSRuleSrcIpGroups `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps []string `pulumi:"srcIps"`
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups *FirewallIPSRuleSrcIpv6Groups `pulumi:"srcIpv6Groups"`
	// The state of the rule indicating whether it is enabled or disabled
	State *string `pulumi:"state"`
	// list of Advanced threat categories to which the rule applies
	ThreatCategories *FirewallIPSRuleThreatCategories `pulumi:"threatCategories"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows *FirewallIPSRuleTimeWindows `pulumi:"timeWindows"`
	// list of users for which rule must be applied
	Users *FirewallIPSRuleUsers `pulumi:"users"`
	// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
	// Gateway forwarding method.
	ZpaAppSegments []FirewallIPSRuleZpaAppSegment `pulumi:"zpaAppSegments"`
}

// The set of arguments for constructing a FirewallIPSRule resource.
type FirewallIPSRuleArgs struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or
	// blocking the traffic or bypassing the rule.
	Action pulumi.StringPtrInput
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrInput
	// list of departments for which rule must be applied
	Departments FirewallIPSRuleDepartmentsPtrInput
	// Additional information about the rule
	Description pulumi.StringPtrInput
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries    pulumi.StringArrayInput
	DestIpCategories pulumi.StringArrayInput
	// list of destination ip groups
	DestIpGroups FirewallIPSRuleDestIpGroupsPtrInput
	// list of destination ip groups
	DestIpv6Groups FirewallIPSRuleDestIpv6GroupsPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FirewallIPSRuleDeviceGroupsPtrInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices FirewallIPSRuleDevicesPtrInput
	// A Boolean value that indicates whether full logging is enabled. A true value indicates that full logging is enabled,
	// whereas a false value indicates that aggregate logging is enabled.
	EnableFullLogging pulumi.BoolPtrInput
	// list of groups for which rule must be applied
	Groups FirewallIPSRuleGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels FirewallIPSRuleLabelsPtrInput
	// list of locations groups
	LocationGroups FirewallIPSRuleLocationGroupsPtrInput
	// list of locations for which rule must be applied
	Locations FirewallIPSRuleLocationsPtrInput
	// The name of the IPS Control rule
	Name pulumi.StringPtrInput
	// list of nw service groups
	NwServiceGroups FirewallIPSRuleNwServiceGroupsPtrInput
	// list of nw services
	NwServices FirewallIPSRuleNwServicesPtrInput
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntInput
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrInput
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank pulumi.IntPtrInput
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries pulumi.StringArrayInput
	// list of source ip groups
	SrcIpGroups FirewallIPSRuleSrcIpGroupsPtrInput
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps pulumi.StringArrayInput
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups FirewallIPSRuleSrcIpv6GroupsPtrInput
	// The state of the rule indicating whether it is enabled or disabled
	State pulumi.StringPtrInput
	// list of Advanced threat categories to which the rule applies
	ThreatCategories FirewallIPSRuleThreatCategoriesPtrInput
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows FirewallIPSRuleTimeWindowsPtrInput
	// list of users for which rule must be applied
	Users FirewallIPSRuleUsersPtrInput
	// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
	// Gateway forwarding method.
	ZpaAppSegments FirewallIPSRuleZpaAppSegmentArrayInput
}

func (FirewallIPSRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallIPSRuleArgs)(nil)).Elem()
}

type FirewallIPSRuleInput interface {
	pulumi.Input

	ToFirewallIPSRuleOutput() FirewallIPSRuleOutput
	ToFirewallIPSRuleOutputWithContext(ctx context.Context) FirewallIPSRuleOutput
}

func (*FirewallIPSRule) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallIPSRule)(nil)).Elem()
}

func (i *FirewallIPSRule) ToFirewallIPSRuleOutput() FirewallIPSRuleOutput {
	return i.ToFirewallIPSRuleOutputWithContext(context.Background())
}

func (i *FirewallIPSRule) ToFirewallIPSRuleOutputWithContext(ctx context.Context) FirewallIPSRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallIPSRuleOutput)
}

// FirewallIPSRuleArrayInput is an input type that accepts FirewallIPSRuleArray and FirewallIPSRuleArrayOutput values.
// You can construct a concrete instance of `FirewallIPSRuleArrayInput` via:
//
//	FirewallIPSRuleArray{ FirewallIPSRuleArgs{...} }
type FirewallIPSRuleArrayInput interface {
	pulumi.Input

	ToFirewallIPSRuleArrayOutput() FirewallIPSRuleArrayOutput
	ToFirewallIPSRuleArrayOutputWithContext(context.Context) FirewallIPSRuleArrayOutput
}

type FirewallIPSRuleArray []FirewallIPSRuleInput

func (FirewallIPSRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallIPSRule)(nil)).Elem()
}

func (i FirewallIPSRuleArray) ToFirewallIPSRuleArrayOutput() FirewallIPSRuleArrayOutput {
	return i.ToFirewallIPSRuleArrayOutputWithContext(context.Background())
}

func (i FirewallIPSRuleArray) ToFirewallIPSRuleArrayOutputWithContext(ctx context.Context) FirewallIPSRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallIPSRuleArrayOutput)
}

// FirewallIPSRuleMapInput is an input type that accepts FirewallIPSRuleMap and FirewallIPSRuleMapOutput values.
// You can construct a concrete instance of `FirewallIPSRuleMapInput` via:
//
//	FirewallIPSRuleMap{ "key": FirewallIPSRuleArgs{...} }
type FirewallIPSRuleMapInput interface {
	pulumi.Input

	ToFirewallIPSRuleMapOutput() FirewallIPSRuleMapOutput
	ToFirewallIPSRuleMapOutputWithContext(context.Context) FirewallIPSRuleMapOutput
}

type FirewallIPSRuleMap map[string]FirewallIPSRuleInput

func (FirewallIPSRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallIPSRule)(nil)).Elem()
}

func (i FirewallIPSRuleMap) ToFirewallIPSRuleMapOutput() FirewallIPSRuleMapOutput {
	return i.ToFirewallIPSRuleMapOutputWithContext(context.Background())
}

func (i FirewallIPSRuleMap) ToFirewallIPSRuleMapOutputWithContext(ctx context.Context) FirewallIPSRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallIPSRuleMapOutput)
}

type FirewallIPSRuleOutput struct{ *pulumi.OutputState }

func (FirewallIPSRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallIPSRule)(nil)).Elem()
}

func (o FirewallIPSRuleOutput) ToFirewallIPSRuleOutput() FirewallIPSRuleOutput {
	return o
}

func (o FirewallIPSRuleOutput) ToFirewallIPSRuleOutputWithContext(ctx context.Context) FirewallIPSRuleOutput {
	return o
}

// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or
// blocking the traffic or bypassing the rule.
func (o FirewallIPSRuleOutput) Action() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringPtrOutput { return v.Action }).(pulumi.StringPtrOutput)
}

// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
func (o FirewallIPSRuleOutput) CapturePcap() pulumi.BoolOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.BoolOutput { return v.CapturePcap }).(pulumi.BoolOutput)
}

// If set to true, the default rule is applied
func (o FirewallIPSRuleOutput) DefaultRule() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.BoolPtrOutput { return v.DefaultRule }).(pulumi.BoolPtrOutput)
}

// list of departments for which rule must be applied
func (o FirewallIPSRuleOutput) Departments() FirewallIPSRuleDepartmentsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleDepartmentsPtrOutput { return v.Departments }).(FirewallIPSRuleDepartmentsPtrOutput)
}

// Additional information about the rule
func (o FirewallIPSRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
func (o FirewallIPSRuleOutput) DestAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringArrayOutput { return v.DestAddresses }).(pulumi.StringArrayOutput)
}

// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
// countries.
func (o FirewallIPSRuleOutput) DestCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringArrayOutput { return v.DestCountries }).(pulumi.StringArrayOutput)
}

func (o FirewallIPSRuleOutput) DestIpCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringArrayOutput { return v.DestIpCategories }).(pulumi.StringArrayOutput)
}

// list of destination ip groups
func (o FirewallIPSRuleOutput) DestIpGroups() FirewallIPSRuleDestIpGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleDestIpGroupsPtrOutput { return v.DestIpGroups }).(FirewallIPSRuleDestIpGroupsPtrOutput)
}

// list of destination ip groups
func (o FirewallIPSRuleOutput) DestIpv6Groups() FirewallIPSRuleDestIpv6GroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleDestIpv6GroupsPtrOutput { return v.DestIpv6Groups }).(FirewallIPSRuleDestIpv6GroupsPtrOutput)
}

// This field is applicable for devices that are managed using Zscaler Client Connector.
func (o FirewallIPSRuleOutput) DeviceGroups() FirewallIPSRuleDeviceGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleDeviceGroupsPtrOutput { return v.DeviceGroups }).(FirewallIPSRuleDeviceGroupsPtrOutput)
}

// Name-ID pairs of devices for which rule must be applied.
func (o FirewallIPSRuleOutput) Devices() FirewallIPSRuleDevicesPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleDevicesPtrOutput { return v.Devices }).(FirewallIPSRuleDevicesPtrOutput)
}

// A Boolean value that indicates whether full logging is enabled. A true value indicates that full logging is enabled,
// whereas a false value indicates that aggregate logging is enabled.
func (o FirewallIPSRuleOutput) EnableFullLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.BoolPtrOutput { return v.EnableFullLogging }).(pulumi.BoolPtrOutput)
}

// list of groups for which rule must be applied
func (o FirewallIPSRuleOutput) Groups() FirewallIPSRuleGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleGroupsPtrOutput { return v.Groups }).(FirewallIPSRuleGroupsPtrOutput)
}

// list of Labels that are applicable to the rule.
func (o FirewallIPSRuleOutput) Labels() FirewallIPSRuleLabelsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleLabelsPtrOutput { return v.Labels }).(FirewallIPSRuleLabelsPtrOutput)
}

// list of locations groups
func (o FirewallIPSRuleOutput) LocationGroups() FirewallIPSRuleLocationGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleLocationGroupsPtrOutput { return v.LocationGroups }).(FirewallIPSRuleLocationGroupsPtrOutput)
}

// list of locations for which rule must be applied
func (o FirewallIPSRuleOutput) Locations() FirewallIPSRuleLocationsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleLocationsPtrOutput { return v.Locations }).(FirewallIPSRuleLocationsPtrOutput)
}

// The name of the IPS Control rule
func (o FirewallIPSRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// list of nw service groups
func (o FirewallIPSRuleOutput) NwServiceGroups() FirewallIPSRuleNwServiceGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleNwServiceGroupsPtrOutput { return v.NwServiceGroups }).(FirewallIPSRuleNwServiceGroupsPtrOutput)
}

// list of nw services
func (o FirewallIPSRuleOutput) NwServices() FirewallIPSRuleNwServicesPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleNwServicesPtrOutput { return v.NwServices }).(FirewallIPSRuleNwServicesPtrOutput)
}

// Rule order number. If omitted, the rule will be added to the end of the rule set.
func (o FirewallIPSRuleOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// If set to true, a predefined rule is applied
func (o FirewallIPSRuleOutput) Predefined() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.BoolPtrOutput { return v.Predefined }).(pulumi.BoolPtrOutput)
}

// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
// be specified for the rule.
func (o FirewallIPSRuleOutput) Rank() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.IntPtrOutput { return v.Rank }).(pulumi.IntPtrOutput)
}

// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
// to a specific URL category.
func (o FirewallIPSRuleOutput) ResCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringArrayOutput { return v.ResCategories }).(pulumi.StringArrayOutput)
}

func (o FirewallIPSRuleOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
// countries.
func (o FirewallIPSRuleOutput) SourceCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringArrayOutput { return v.SourceCountries }).(pulumi.StringArrayOutput)
}

// list of source ip groups
func (o FirewallIPSRuleOutput) SrcIpGroups() FirewallIPSRuleSrcIpGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleSrcIpGroupsPtrOutput { return v.SrcIpGroups }).(FirewallIPSRuleSrcIpGroupsPtrOutput)
}

// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
// source IP address.
func (o FirewallIPSRuleOutput) SrcIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringArrayOutput { return v.SrcIps }).(pulumi.StringArrayOutput)
}

// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
// specific source IPv6 address group.
func (o FirewallIPSRuleOutput) SrcIpv6Groups() FirewallIPSRuleSrcIpv6GroupsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleSrcIpv6GroupsPtrOutput { return v.SrcIpv6Groups }).(FirewallIPSRuleSrcIpv6GroupsPtrOutput)
}

// The state of the rule indicating whether it is enabled or disabled
func (o FirewallIPSRuleOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// list of Advanced threat categories to which the rule applies
func (o FirewallIPSRuleOutput) ThreatCategories() FirewallIPSRuleThreatCategoriesPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleThreatCategoriesPtrOutput { return v.ThreatCategories }).(FirewallIPSRuleThreatCategoriesPtrOutput)
}

// The time interval in which the Firewall Filtering policy rule applies
func (o FirewallIPSRuleOutput) TimeWindows() FirewallIPSRuleTimeWindowsPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleTimeWindowsPtrOutput { return v.TimeWindows }).(FirewallIPSRuleTimeWindowsPtrOutput)
}

// list of users for which rule must be applied
func (o FirewallIPSRuleOutput) Users() FirewallIPSRuleUsersPtrOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleUsersPtrOutput { return v.Users }).(FirewallIPSRuleUsersPtrOutput)
}

// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
// Gateway forwarding method.
func (o FirewallIPSRuleOutput) ZpaAppSegments() FirewallIPSRuleZpaAppSegmentArrayOutput {
	return o.ApplyT(func(v *FirewallIPSRule) FirewallIPSRuleZpaAppSegmentArrayOutput { return v.ZpaAppSegments }).(FirewallIPSRuleZpaAppSegmentArrayOutput)
}

type FirewallIPSRuleArrayOutput struct{ *pulumi.OutputState }

func (FirewallIPSRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallIPSRule)(nil)).Elem()
}

func (o FirewallIPSRuleArrayOutput) ToFirewallIPSRuleArrayOutput() FirewallIPSRuleArrayOutput {
	return o
}

func (o FirewallIPSRuleArrayOutput) ToFirewallIPSRuleArrayOutputWithContext(ctx context.Context) FirewallIPSRuleArrayOutput {
	return o
}

func (o FirewallIPSRuleArrayOutput) Index(i pulumi.IntInput) FirewallIPSRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FirewallIPSRule {
		return vs[0].([]*FirewallIPSRule)[vs[1].(int)]
	}).(FirewallIPSRuleOutput)
}

type FirewallIPSRuleMapOutput struct{ *pulumi.OutputState }

func (FirewallIPSRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallIPSRule)(nil)).Elem()
}

func (o FirewallIPSRuleMapOutput) ToFirewallIPSRuleMapOutput() FirewallIPSRuleMapOutput {
	return o
}

func (o FirewallIPSRuleMapOutput) ToFirewallIPSRuleMapOutputWithContext(ctx context.Context) FirewallIPSRuleMapOutput {
	return o
}

func (o FirewallIPSRuleMapOutput) MapIndex(k pulumi.StringInput) FirewallIPSRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FirewallIPSRule {
		return vs[0].(map[string]*FirewallIPSRule)[vs[1].(string)]
	}).(FirewallIPSRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallIPSRuleInput)(nil)).Elem(), &FirewallIPSRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallIPSRuleArrayInput)(nil)).Elem(), FirewallIPSRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallIPSRuleMapInput)(nil)).Elem(), FirewallIPSRuleMap{})
	pulumi.RegisterOutputType(FirewallIPSRuleOutput{})
	pulumi.RegisterOutputType(FirewallIPSRuleArrayOutput{})
	pulumi.RegisterOutputType(FirewallIPSRuleMapOutput{})
}

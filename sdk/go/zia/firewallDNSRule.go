// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// ## Example Usage
//
// ### Create Firewall DNS Rules - Redirect Action
//
// ### Create Firewall DNS Rules - Redirect Request DOH
//
// ### Create Firewall DNS Rules - Redirect TCP Request
//
//	resource "FirewallDNSRule" "this3" {
//	    name = "Example_DNS_Rule03"
//	    description = "Example_DNS_Rule03"
//	    action = "REDIR_REQ_TCP"
//	    state = "ENABLED"
//	    order = 13
//	    rank = 7
//	    destCountries = ["CA", "US"]
//	    sourceCountries = ["CA", "US"]
//	    protocols = ["ANY_RULE"]
//	    dnsGateway {
//	      id = 18207342
//	      name = "DNS_GW01"
//	    }
//	}
type FirewallDNSRule struct {
	pulumi.CustomResourceState

	// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
	Action pulumi.StringPtrOutput `pulumi:"action"`
	// (List of Objects) DNS application groups to which the rule applies
	ApplicationGroups FirewallDNSRuleApplicationGroupsPtrOutput `pulumi:"applicationGroups"`
	// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
	Applications pulumi.StringArrayOutput `pulumi:"applications"`
	// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
	// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
	BlockResponseCode pulumi.StringPtrOutput `pulumi:"blockResponseCode"`
	// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolOutput `pulumi:"capturePcap"`
	// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
	DefaultRule pulumi.BoolPtrOutput `pulumi:"defaultRule"`
	// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
	Departments FirewallDNSRuleDepartmentsPtrOutput `pulumi:"departments"`
	// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	DestAddresses pulumi.StringArrayOutput `pulumi:"destAddresses"`
	// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	DestCountries pulumi.StringArrayOutput `pulumi:"destCountries"`
	// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
	DestIpCategories pulumi.StringArrayOutput `pulumi:"destIpCategories"`
	// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
	DestIpGroups FirewallDNSRuleDestIpGroupsPtrOutput `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups FirewallDNSRuleDestIpv6GroupsPtrOutput `pulumi:"destIpv6Groups"`
	// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	DeviceGroups FirewallDNSRuleDeviceGroupsPtrOutput `pulumi:"deviceGroups"`
	// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	Devices FirewallDNSRuleDevicesPtrOutput `pulumi:"devices"`
	// (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
	DnsGateway FirewallDNSRuleDnsGatewayOutput `pulumi:"dnsGateway"`
	// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
	// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
	// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
	// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
	// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
	// `ZONEMD`, `SVCB`, `HTTPS`,
	DnsRuleRequestTypes pulumi.StringArrayOutput `pulumi:"dnsRuleRequestTypes"`
	// (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
	EdnsEcsObject FirewallDNSRuleEdnsEcsObjectOutput `pulumi:"ednsEcsObject"`
	// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
	Groups FirewallDNSRuleGroupsPtrOutput `pulumi:"groups"`
	// (List of Objects) Labels that are applicable to the rule.
	Labels FirewallDNSRuleLabelsPtrOutput `pulumi:"labels"`
	// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
	LocationGroups FirewallDNSRuleLocationGroupsPtrOutput `pulumi:"locationGroups"`
	// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
	Locations FirewallDNSRuleLocationsPtrOutput `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringOutput `pulumi:"name"`
	// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
	Order pulumi.IntOutput `pulumi:"order"`
	// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
	Predefined pulumi.BoolPtrOutput `pulumi:"predefined"`
	// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
	Protocols pulumi.StringArrayOutput `pulumi:"protocols"`
	// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
	Rank pulumi.IntPtrOutput `pulumi:"rank"`
	// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
	RedirectIp pulumi.StringPtrOutput `pulumi:"redirectIp"`
	// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
	ResCategories pulumi.StringArrayOutput `pulumi:"resCategories"`
	RuleId        pulumi.IntOutput         `pulumi:"ruleId"`
	// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	SourceCountries pulumi.StringArrayOutput `pulumi:"sourceCountries"`
	// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
	SrcIpGroups FirewallDNSRuleSrcIpGroupsPtrOutput `pulumi:"srcIpGroups"`
	// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	SrcIps pulumi.StringArrayOutput `pulumi:"srcIps"`
	// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
	SrcIpv6Groups FirewallDNSRuleSrcIpv6GroupsPtrOutput `pulumi:"srcIpv6Groups"`
	// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
	State pulumi.StringPtrOutput `pulumi:"state"`
	// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
	TimeWindows FirewallDNSRuleTimeWindowsPtrOutput `pulumi:"timeWindows"`
	// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
	Users FirewallDNSRuleUsersPtrOutput `pulumi:"users"`
	// (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
	ZpaIpGroup FirewallDNSRuleZpaIpGroupOutput `pulumi:"zpaIpGroup"`
}

// NewFirewallDNSRule registers a new resource with the given unique name, arguments, and options.
func NewFirewallDNSRule(ctx *pulumi.Context,
	name string, args *FirewallDNSRuleArgs, opts ...pulumi.ResourceOption) (*FirewallDNSRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FirewallDNSRule
	err := ctx.RegisterResource("zia:index/firewallDNSRule:FirewallDNSRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirewallDNSRule gets an existing FirewallDNSRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirewallDNSRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirewallDNSRuleState, opts ...pulumi.ResourceOption) (*FirewallDNSRule, error) {
	var resource FirewallDNSRule
	err := ctx.ReadResource("zia:index/firewallDNSRule:FirewallDNSRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FirewallDNSRule resources.
type firewallDNSRuleState struct {
	// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
	Action *string `pulumi:"action"`
	// (List of Objects) DNS application groups to which the rule applies
	ApplicationGroups *FirewallDNSRuleApplicationGroups `pulumi:"applicationGroups"`
	// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
	Applications []string `pulumi:"applications"`
	// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
	// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
	BlockResponseCode *string `pulumi:"blockResponseCode"`
	// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
	DefaultRule *bool `pulumi:"defaultRule"`
	// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
	Departments *FirewallDNSRuleDepartments `pulumi:"departments"`
	// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
	Description *string `pulumi:"description"`
	// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	DestAddresses []string `pulumi:"destAddresses"`
	// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	DestCountries []string `pulumi:"destCountries"`
	// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
	DestIpCategories []string `pulumi:"destIpCategories"`
	// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
	DestIpGroups *FirewallDNSRuleDestIpGroups `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups *FirewallDNSRuleDestIpv6Groups `pulumi:"destIpv6Groups"`
	// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	DeviceGroups *FirewallDNSRuleDeviceGroups `pulumi:"deviceGroups"`
	// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	Devices *FirewallDNSRuleDevices `pulumi:"devices"`
	// (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
	DnsGateway *FirewallDNSRuleDnsGateway `pulumi:"dnsGateway"`
	// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
	// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
	// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
	// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
	// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
	// `ZONEMD`, `SVCB`, `HTTPS`,
	DnsRuleRequestTypes []string `pulumi:"dnsRuleRequestTypes"`
	// (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
	EdnsEcsObject *FirewallDNSRuleEdnsEcsObject `pulumi:"ednsEcsObject"`
	// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
	Groups *FirewallDNSRuleGroups `pulumi:"groups"`
	// (List of Objects) Labels that are applicable to the rule.
	Labels *FirewallDNSRuleLabels `pulumi:"labels"`
	// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
	LocationGroups *FirewallDNSRuleLocationGroups `pulumi:"locationGroups"`
	// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
	Locations *FirewallDNSRuleLocations `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
	// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
	Order *int `pulumi:"order"`
	// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
	Predefined *bool `pulumi:"predefined"`
	// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
	Protocols []string `pulumi:"protocols"`
	// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
	Rank *int `pulumi:"rank"`
	// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
	RedirectIp *string `pulumi:"redirectIp"`
	// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	RuleId        *int     `pulumi:"ruleId"`
	// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	SourceCountries []string `pulumi:"sourceCountries"`
	// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
	SrcIpGroups *FirewallDNSRuleSrcIpGroups `pulumi:"srcIpGroups"`
	// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	SrcIps []string `pulumi:"srcIps"`
	// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
	SrcIpv6Groups *FirewallDNSRuleSrcIpv6Groups `pulumi:"srcIpv6Groups"`
	// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
	State *string `pulumi:"state"`
	// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
	TimeWindows *FirewallDNSRuleTimeWindows `pulumi:"timeWindows"`
	// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
	Users *FirewallDNSRuleUsers `pulumi:"users"`
	// (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
	ZpaIpGroup *FirewallDNSRuleZpaIpGroup `pulumi:"zpaIpGroup"`
}

type FirewallDNSRuleState struct {
	// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
	Action pulumi.StringPtrInput
	// (List of Objects) DNS application groups to which the rule applies
	ApplicationGroups FirewallDNSRuleApplicationGroupsPtrInput
	// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
	Applications pulumi.StringArrayInput
	// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
	// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
	BlockResponseCode pulumi.StringPtrInput
	// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
	DefaultRule pulumi.BoolPtrInput
	// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
	Departments FirewallDNSRuleDepartmentsPtrInput
	// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
	Description pulumi.StringPtrInput
	// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	DestAddresses pulumi.StringArrayInput
	// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	DestCountries pulumi.StringArrayInput
	// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
	DestIpCategories pulumi.StringArrayInput
	// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
	DestIpGroups FirewallDNSRuleDestIpGroupsPtrInput
	// list of destination ip groups
	DestIpv6Groups FirewallDNSRuleDestIpv6GroupsPtrInput
	// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	DeviceGroups FirewallDNSRuleDeviceGroupsPtrInput
	// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	Devices FirewallDNSRuleDevicesPtrInput
	// (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
	DnsGateway FirewallDNSRuleDnsGatewayPtrInput
	// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
	// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
	// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
	// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
	// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
	// `ZONEMD`, `SVCB`, `HTTPS`,
	DnsRuleRequestTypes pulumi.StringArrayInput
	// (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
	EdnsEcsObject FirewallDNSRuleEdnsEcsObjectPtrInput
	// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
	Groups FirewallDNSRuleGroupsPtrInput
	// (List of Objects) Labels that are applicable to the rule.
	Labels FirewallDNSRuleLabelsPtrInput
	// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
	LocationGroups FirewallDNSRuleLocationGroupsPtrInput
	// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
	Locations FirewallDNSRuleLocationsPtrInput
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput
	// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
	Order pulumi.IntPtrInput
	// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
	Predefined pulumi.BoolPtrInput
	// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
	Protocols pulumi.StringArrayInput
	// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
	Rank pulumi.IntPtrInput
	// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
	RedirectIp pulumi.StringPtrInput
	// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
	ResCategories pulumi.StringArrayInput
	RuleId        pulumi.IntPtrInput
	// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	SourceCountries pulumi.StringArrayInput
	// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
	SrcIpGroups FirewallDNSRuleSrcIpGroupsPtrInput
	// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	SrcIps pulumi.StringArrayInput
	// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
	SrcIpv6Groups FirewallDNSRuleSrcIpv6GroupsPtrInput
	// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
	State pulumi.StringPtrInput
	// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
	TimeWindows FirewallDNSRuleTimeWindowsPtrInput
	// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
	Users FirewallDNSRuleUsersPtrInput
	// (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
	ZpaIpGroup FirewallDNSRuleZpaIpGroupPtrInput
}

func (FirewallDNSRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallDNSRuleState)(nil)).Elem()
}

type firewallDNSRuleArgs struct {
	// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
	Action *string `pulumi:"action"`
	// (List of Objects) DNS application groups to which the rule applies
	ApplicationGroups *FirewallDNSRuleApplicationGroups `pulumi:"applicationGroups"`
	// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
	Applications []string `pulumi:"applications"`
	// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
	// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
	BlockResponseCode *string `pulumi:"blockResponseCode"`
	// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
	DefaultRule *bool `pulumi:"defaultRule"`
	// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
	Departments *FirewallDNSRuleDepartments `pulumi:"departments"`
	// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
	Description *string `pulumi:"description"`
	// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	DestAddresses []string `pulumi:"destAddresses"`
	// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	DestCountries []string `pulumi:"destCountries"`
	// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
	DestIpCategories []string `pulumi:"destIpCategories"`
	// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
	DestIpGroups *FirewallDNSRuleDestIpGroups `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups *FirewallDNSRuleDestIpv6Groups `pulumi:"destIpv6Groups"`
	// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	DeviceGroups *FirewallDNSRuleDeviceGroups `pulumi:"deviceGroups"`
	// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	Devices *FirewallDNSRuleDevices `pulumi:"devices"`
	// (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
	DnsGateway *FirewallDNSRuleDnsGateway `pulumi:"dnsGateway"`
	// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
	// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
	// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
	// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
	// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
	// `ZONEMD`, `SVCB`, `HTTPS`,
	DnsRuleRequestTypes []string `pulumi:"dnsRuleRequestTypes"`
	// (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
	EdnsEcsObject *FirewallDNSRuleEdnsEcsObject `pulumi:"ednsEcsObject"`
	// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
	Groups *FirewallDNSRuleGroups `pulumi:"groups"`
	// (List of Objects) Labels that are applicable to the rule.
	Labels *FirewallDNSRuleLabels `pulumi:"labels"`
	// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
	LocationGroups *FirewallDNSRuleLocationGroups `pulumi:"locationGroups"`
	// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
	Locations *FirewallDNSRuleLocations `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
	// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
	Order int `pulumi:"order"`
	// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
	Predefined *bool `pulumi:"predefined"`
	// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
	Protocols []string `pulumi:"protocols"`
	// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
	Rank *int `pulumi:"rank"`
	// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
	RedirectIp *string `pulumi:"redirectIp"`
	// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	SourceCountries []string `pulumi:"sourceCountries"`
	// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
	SrcIpGroups *FirewallDNSRuleSrcIpGroups `pulumi:"srcIpGroups"`
	// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	SrcIps []string `pulumi:"srcIps"`
	// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
	SrcIpv6Groups *FirewallDNSRuleSrcIpv6Groups `pulumi:"srcIpv6Groups"`
	// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
	State *string `pulumi:"state"`
	// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
	TimeWindows *FirewallDNSRuleTimeWindows `pulumi:"timeWindows"`
	// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
	Users *FirewallDNSRuleUsers `pulumi:"users"`
	// (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
	ZpaIpGroup *FirewallDNSRuleZpaIpGroup `pulumi:"zpaIpGroup"`
}

// The set of arguments for constructing a FirewallDNSRule resource.
type FirewallDNSRuleArgs struct {
	// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
	Action pulumi.StringPtrInput
	// (List of Objects) DNS application groups to which the rule applies
	ApplicationGroups FirewallDNSRuleApplicationGroupsPtrInput
	// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
	Applications pulumi.StringArrayInput
	// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
	// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
	BlockResponseCode pulumi.StringPtrInput
	// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
	DefaultRule pulumi.BoolPtrInput
	// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
	Departments FirewallDNSRuleDepartmentsPtrInput
	// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
	Description pulumi.StringPtrInput
	// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	DestAddresses pulumi.StringArrayInput
	// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	DestCountries pulumi.StringArrayInput
	// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
	DestIpCategories pulumi.StringArrayInput
	// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
	DestIpGroups FirewallDNSRuleDestIpGroupsPtrInput
	// list of destination ip groups
	DestIpv6Groups FirewallDNSRuleDestIpv6GroupsPtrInput
	// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	DeviceGroups FirewallDNSRuleDeviceGroupsPtrInput
	// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
	Devices FirewallDNSRuleDevicesPtrInput
	// (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
	DnsGateway FirewallDNSRuleDnsGatewayPtrInput
	// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
	// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
	// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
	// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
	// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
	// `ZONEMD`, `SVCB`, `HTTPS`,
	DnsRuleRequestTypes pulumi.StringArrayInput
	// (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
	EdnsEcsObject FirewallDNSRuleEdnsEcsObjectPtrInput
	// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
	Groups FirewallDNSRuleGroupsPtrInput
	// (List of Objects) Labels that are applicable to the rule.
	Labels FirewallDNSRuleLabelsPtrInput
	// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
	LocationGroups FirewallDNSRuleLocationGroupsPtrInput
	// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
	Locations FirewallDNSRuleLocationsPtrInput
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput
	// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
	Order pulumi.IntInput
	// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
	Predefined pulumi.BoolPtrInput
	// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
	Protocols pulumi.StringArrayInput
	// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
	Rank pulumi.IntPtrInput
	// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
	RedirectIp pulumi.StringPtrInput
	// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
	ResCategories pulumi.StringArrayInput
	// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
	// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
	SourceCountries pulumi.StringArrayInput
	// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
	SrcIpGroups FirewallDNSRuleSrcIpGroupsPtrInput
	// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
	SrcIps pulumi.StringArrayInput
	// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
	SrcIpv6Groups FirewallDNSRuleSrcIpv6GroupsPtrInput
	// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
	State pulumi.StringPtrInput
	// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
	TimeWindows FirewallDNSRuleTimeWindowsPtrInput
	// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
	Users FirewallDNSRuleUsersPtrInput
	// (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
	ZpaIpGroup FirewallDNSRuleZpaIpGroupPtrInput
}

func (FirewallDNSRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallDNSRuleArgs)(nil)).Elem()
}

type FirewallDNSRuleInput interface {
	pulumi.Input

	ToFirewallDNSRuleOutput() FirewallDNSRuleOutput
	ToFirewallDNSRuleOutputWithContext(ctx context.Context) FirewallDNSRuleOutput
}

func (*FirewallDNSRule) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallDNSRule)(nil)).Elem()
}

func (i *FirewallDNSRule) ToFirewallDNSRuleOutput() FirewallDNSRuleOutput {
	return i.ToFirewallDNSRuleOutputWithContext(context.Background())
}

func (i *FirewallDNSRule) ToFirewallDNSRuleOutputWithContext(ctx context.Context) FirewallDNSRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallDNSRuleOutput)
}

// FirewallDNSRuleArrayInput is an input type that accepts FirewallDNSRuleArray and FirewallDNSRuleArrayOutput values.
// You can construct a concrete instance of `FirewallDNSRuleArrayInput` via:
//
//	FirewallDNSRuleArray{ FirewallDNSRuleArgs{...} }
type FirewallDNSRuleArrayInput interface {
	pulumi.Input

	ToFirewallDNSRuleArrayOutput() FirewallDNSRuleArrayOutput
	ToFirewallDNSRuleArrayOutputWithContext(context.Context) FirewallDNSRuleArrayOutput
}

type FirewallDNSRuleArray []FirewallDNSRuleInput

func (FirewallDNSRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallDNSRule)(nil)).Elem()
}

func (i FirewallDNSRuleArray) ToFirewallDNSRuleArrayOutput() FirewallDNSRuleArrayOutput {
	return i.ToFirewallDNSRuleArrayOutputWithContext(context.Background())
}

func (i FirewallDNSRuleArray) ToFirewallDNSRuleArrayOutputWithContext(ctx context.Context) FirewallDNSRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallDNSRuleArrayOutput)
}

// FirewallDNSRuleMapInput is an input type that accepts FirewallDNSRuleMap and FirewallDNSRuleMapOutput values.
// You can construct a concrete instance of `FirewallDNSRuleMapInput` via:
//
//	FirewallDNSRuleMap{ "key": FirewallDNSRuleArgs{...} }
type FirewallDNSRuleMapInput interface {
	pulumi.Input

	ToFirewallDNSRuleMapOutput() FirewallDNSRuleMapOutput
	ToFirewallDNSRuleMapOutputWithContext(context.Context) FirewallDNSRuleMapOutput
}

type FirewallDNSRuleMap map[string]FirewallDNSRuleInput

func (FirewallDNSRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallDNSRule)(nil)).Elem()
}

func (i FirewallDNSRuleMap) ToFirewallDNSRuleMapOutput() FirewallDNSRuleMapOutput {
	return i.ToFirewallDNSRuleMapOutputWithContext(context.Background())
}

func (i FirewallDNSRuleMap) ToFirewallDNSRuleMapOutputWithContext(ctx context.Context) FirewallDNSRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallDNSRuleMapOutput)
}

type FirewallDNSRuleOutput struct{ *pulumi.OutputState }

func (FirewallDNSRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallDNSRule)(nil)).Elem()
}

func (o FirewallDNSRuleOutput) ToFirewallDNSRuleOutput() FirewallDNSRuleOutput {
	return o
}

func (o FirewallDNSRuleOutput) ToFirewallDNSRuleOutputWithContext(ctx context.Context) FirewallDNSRuleOutput {
	return o
}

// (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
func (o FirewallDNSRuleOutput) Action() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.Action }).(pulumi.StringPtrOutput)
}

// (List of Objects) DNS application groups to which the rule applies
func (o FirewallDNSRuleOutput) ApplicationGroups() FirewallDNSRuleApplicationGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleApplicationGroupsPtrOutput { return v.ApplicationGroups }).(FirewallDNSRuleApplicationGroupsPtrOutput)
}

// (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `getCloudApplications` with the `appClass` value `DNS_OVER_HTTPS`. See example:
func (o FirewallDNSRuleOutput) Applications() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.Applications }).(pulumi.StringArrayOutput)
}

// (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
// `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
func (o FirewallDNSRuleOutput) BlockResponseCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.BlockResponseCode }).(pulumi.StringPtrOutput)
}

// (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
func (o FirewallDNSRuleOutput) CapturePcap() pulumi.BoolOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.BoolOutput { return v.CapturePcap }).(pulumi.BoolOutput)
}

// (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
func (o FirewallDNSRuleOutput) DefaultRule() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.BoolPtrOutput { return v.DefaultRule }).(pulumi.BoolPtrOutput)
}

// (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
func (o FirewallDNSRuleOutput) Departments() FirewallDNSRuleDepartmentsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDepartmentsPtrOutput { return v.Departments }).(FirewallDNSRuleDepartmentsPtrOutput)
}

// (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
func (o FirewallDNSRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
func (o FirewallDNSRuleOutput) DestAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DestAddresses }).(pulumi.StringArrayOutput)
}

// (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e “"US"“, “"CA"“
func (o FirewallDNSRuleOutput) DestCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DestCountries }).(pulumi.StringArrayOutput)
}

// (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
func (o FirewallDNSRuleOutput) DestIpCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DestIpCategories }).(pulumi.StringArrayOutput)
}

// ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
func (o FirewallDNSRuleOutput) DestIpGroups() FirewallDNSRuleDestIpGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDestIpGroupsPtrOutput { return v.DestIpGroups }).(FirewallDNSRuleDestIpGroupsPtrOutput)
}

// list of destination ip groups
func (o FirewallDNSRuleOutput) DestIpv6Groups() FirewallDNSRuleDestIpv6GroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDestIpv6GroupsPtrOutput { return v.DestIpv6Groups }).(FirewallDNSRuleDestIpv6GroupsPtrOutput)
}

// (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
func (o FirewallDNSRuleOutput) DeviceGroups() FirewallDNSRuleDeviceGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDeviceGroupsPtrOutput { return v.DeviceGroups }).(FirewallDNSRuleDeviceGroupsPtrOutput)
}

// (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
func (o FirewallDNSRuleOutput) Devices() FirewallDNSRuleDevicesPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDevicesPtrOutput { return v.Devices }).(FirewallDNSRuleDevicesPtrOutput)
}

// (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
func (o FirewallDNSRuleOutput) DnsGateway() FirewallDNSRuleDnsGatewayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDnsGatewayOutput { return v.DnsGateway }).(FirewallDNSRuleDnsGatewayOutput)
}

// (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
// `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
// `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
// `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
// `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
// `ZONEMD`, `SVCB`, `HTTPS`,
func (o FirewallDNSRuleOutput) DnsRuleRequestTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DnsRuleRequestTypes }).(pulumi.StringArrayOutput)
}

// (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
func (o FirewallDNSRuleOutput) EdnsEcsObject() FirewallDNSRuleEdnsEcsObjectOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleEdnsEcsObjectOutput { return v.EdnsEcsObject }).(FirewallDNSRuleEdnsEcsObjectOutput)
}

// (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
func (o FirewallDNSRuleOutput) Groups() FirewallDNSRuleGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleGroupsPtrOutput { return v.Groups }).(FirewallDNSRuleGroupsPtrOutput)
}

// (List of Objects) Labels that are applicable to the rule.
func (o FirewallDNSRuleOutput) Labels() FirewallDNSRuleLabelsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleLabelsPtrOutput { return v.Labels }).(FirewallDNSRuleLabelsPtrOutput)
}

// (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
func (o FirewallDNSRuleOutput) LocationGroups() FirewallDNSRuleLocationGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleLocationGroupsPtrOutput { return v.LocationGroups }).(FirewallDNSRuleLocationGroupsPtrOutput)
}

// (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
func (o FirewallDNSRuleOutput) Locations() FirewallDNSRuleLocationsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleLocationsPtrOutput { return v.Locations }).(FirewallDNSRuleLocationsPtrOutput)
}

// Name of the Firewall Filtering policy rule
func (o FirewallDNSRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
func (o FirewallDNSRuleOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
func (o FirewallDNSRuleOutput) Predefined() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.BoolPtrOutput { return v.Predefined }).(pulumi.BoolPtrOutput)
}

// (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
func (o FirewallDNSRuleOutput) Protocols() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.Protocols }).(pulumi.StringArrayOutput)
}

// (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
func (o FirewallDNSRuleOutput) Rank() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.IntPtrOutput { return v.Rank }).(pulumi.IntPtrOutput)
}

// (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
func (o FirewallDNSRuleOutput) RedirectIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.RedirectIp }).(pulumi.StringPtrOutput)
}

// (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
func (o FirewallDNSRuleOutput) ResCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.ResCategories }).(pulumi.StringArrayOutput)
}

func (o FirewallDNSRuleOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
// **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e “"US"“, “"CA"“
func (o FirewallDNSRuleOutput) SourceCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.SourceCountries }).(pulumi.StringArrayOutput)
}

// (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
func (o FirewallDNSRuleOutput) SrcIpGroups() FirewallDNSRuleSrcIpGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleSrcIpGroupsPtrOutput { return v.SrcIpGroups }).(FirewallDNSRuleSrcIpGroupsPtrOutput)
}

// (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
func (o FirewallDNSRuleOutput) SrcIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.SrcIps }).(pulumi.StringArrayOutput)
}

// (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
func (o FirewallDNSRuleOutput) SrcIpv6Groups() FirewallDNSRuleSrcIpv6GroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleSrcIpv6GroupsPtrOutput { return v.SrcIpv6Groups }).(FirewallDNSRuleSrcIpv6GroupsPtrOutput)
}

// (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
func (o FirewallDNSRuleOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
func (o FirewallDNSRuleOutput) TimeWindows() FirewallDNSRuleTimeWindowsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleTimeWindowsPtrOutput { return v.TimeWindows }).(FirewallDNSRuleTimeWindowsPtrOutput)
}

// (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
func (o FirewallDNSRuleOutput) Users() FirewallDNSRuleUsersPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleUsersPtrOutput { return v.Users }).(FirewallDNSRuleUsersPtrOutput)
}

// (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
func (o FirewallDNSRuleOutput) ZpaIpGroup() FirewallDNSRuleZpaIpGroupOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleZpaIpGroupOutput { return v.ZpaIpGroup }).(FirewallDNSRuleZpaIpGroupOutput)
}

type FirewallDNSRuleArrayOutput struct{ *pulumi.OutputState }

func (FirewallDNSRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallDNSRule)(nil)).Elem()
}

func (o FirewallDNSRuleArrayOutput) ToFirewallDNSRuleArrayOutput() FirewallDNSRuleArrayOutput {
	return o
}

func (o FirewallDNSRuleArrayOutput) ToFirewallDNSRuleArrayOutputWithContext(ctx context.Context) FirewallDNSRuleArrayOutput {
	return o
}

func (o FirewallDNSRuleArrayOutput) Index(i pulumi.IntInput) FirewallDNSRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FirewallDNSRule {
		return vs[0].([]*FirewallDNSRule)[vs[1].(int)]
	}).(FirewallDNSRuleOutput)
}

type FirewallDNSRuleMapOutput struct{ *pulumi.OutputState }

func (FirewallDNSRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallDNSRule)(nil)).Elem()
}

func (o FirewallDNSRuleMapOutput) ToFirewallDNSRuleMapOutput() FirewallDNSRuleMapOutput {
	return o
}

func (o FirewallDNSRuleMapOutput) ToFirewallDNSRuleMapOutputWithContext(ctx context.Context) FirewallDNSRuleMapOutput {
	return o
}

func (o FirewallDNSRuleMapOutput) MapIndex(k pulumi.StringInput) FirewallDNSRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FirewallDNSRule {
		return vs[0].(map[string]*FirewallDNSRule)[vs[1].(string)]
	}).(FirewallDNSRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallDNSRuleInput)(nil)).Elem(), &FirewallDNSRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallDNSRuleArrayInput)(nil)).Elem(), FirewallDNSRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallDNSRuleMapInput)(nil)).Elem(), FirewallDNSRuleMap{})
	pulumi.RegisterOutputType(FirewallDNSRuleOutput{})
	pulumi.RegisterOutputType(FirewallDNSRuleArrayOutput{})
	pulumi.RegisterOutputType(FirewallDNSRuleMapOutput{})
}

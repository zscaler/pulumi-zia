// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

type FirewallDNSRule struct {
	pulumi.CustomResourceState

	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing,
	// blocking, or redirecting the traffic.
	Action pulumi.StringPtrOutput `pulumi:"action"`
	// list of nw application groups
	ApplicationGroups FirewallDNSRuleApplicationGroupsPtrOutput `pulumi:"applicationGroups"`
	// User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a
	// specific network service application.
	Applications pulumi.StringArrayOutput `pulumi:"applications"`
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	BlockResponseCode pulumi.StringPtrOutput `pulumi:"blockResponseCode"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolOutput `pulumi:"capturePcap"`
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrOutput `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments FirewallDNSRuleDepartmentsPtrOutput `pulumi:"departments"`
	// Additional information about the rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayOutput `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries pulumi.StringArrayOutput `pulumi:"destCountries"`
	// Destination IP categories to which the rule applies. If not set, the rule is not restricted to specific categories.
	DestIpCategories pulumi.StringArrayOutput `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups FirewallDNSRuleDestIpGroupsPtrOutput `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups FirewallDNSRuleDestIpv6GroupsPtrOutput `pulumi:"destIpv6Groups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FirewallDNSRuleDeviceGroupsPtrOutput `pulumi:"deviceGroups"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices FirewallDNSRuleDevicesPtrOutput `pulumi:"devices"`
	// The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS
	// service
	DnsGateway FirewallDNSRuleDnsGatewayOutput `pulumi:"dnsGateway"`
	// DNS request types to which the rule applies
	DnsRuleRequestTypes pulumi.StringArrayOutput `pulumi:"dnsRuleRequestTypes"`
	// The EDNS ECS object which resolves DNS request
	EdnsEcsObject FirewallDNSRuleEdnsEcsObjectOutput `pulumi:"ednsEcsObject"`
	// list of groups for which rule must be applied
	Groups FirewallDNSRuleGroupsPtrOutput `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels FirewallDNSRuleLabelsPtrOutput `pulumi:"labels"`
	// list of locations groups
	LocationGroups FirewallDNSRuleLocationGroupsPtrOutput `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations FirewallDNSRuleLocationsPtrOutput `pulumi:"locations"`
	// The name of the IPS Control rule
	Name pulumi.StringOutput `pulumi:"name"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntOutput `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrOutput `pulumi:"predefined"`
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols pulumi.StringArrayOutput `pulumi:"protocols"`
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank pulumi.IntPtrOutput `pulumi:"rank"`
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	RedirectIp pulumi.StringPtrOutput `pulumi:"redirectIp"`
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories pulumi.StringArrayOutput `pulumi:"resCategories"`
	RuleId        pulumi.IntOutput         `pulumi:"ruleId"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries pulumi.StringArrayOutput `pulumi:"sourceCountries"`
	// list of Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address group.
	SrcIpGroups FirewallDNSRuleSrcIpGroupsPtrOutput `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps pulumi.StringArrayOutput `pulumi:"srcIps"`
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups FirewallDNSRuleSrcIpv6GroupsPtrOutput `pulumi:"srcIpv6Groups"`
	// The state of the rule indicating whether it is enabled or disabled
	State pulumi.StringPtrOutput `pulumi:"state"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows FirewallDNSRuleTimeWindowsPtrOutput `pulumi:"timeWindows"`
	// list of users for which rule must be applied
	Users FirewallDNSRuleUsersPtrOutput `pulumi:"users"`
	// The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address
	// from a preconfigured IP pool
	ZpaIpGroup FirewallDNSRuleZpaIpGroupOutput `pulumi:"zpaIpGroup"`
}

// NewFirewallDNSRule registers a new resource with the given unique name, arguments, and options.
func NewFirewallDNSRule(ctx *pulumi.Context,
	name string, args *FirewallDNSRuleArgs, opts ...pulumi.ResourceOption) (*FirewallDNSRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FirewallDNSRule
	err := ctx.RegisterResource("zia:index/firewallDNSRule:FirewallDNSRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirewallDNSRule gets an existing FirewallDNSRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirewallDNSRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirewallDNSRuleState, opts ...pulumi.ResourceOption) (*FirewallDNSRule, error) {
	var resource FirewallDNSRule
	err := ctx.ReadResource("zia:index/firewallDNSRule:FirewallDNSRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FirewallDNSRule resources.
type firewallDNSRuleState struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing,
	// blocking, or redirecting the traffic.
	Action *string `pulumi:"action"`
	// list of nw application groups
	ApplicationGroups *FirewallDNSRuleApplicationGroups `pulumi:"applicationGroups"`
	// User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a
	// specific network service application.
	Applications []string `pulumi:"applications"`
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	BlockResponseCode *string `pulumi:"blockResponseCode"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// If set to true, the default rule is applied
	DefaultRule *bool `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments *FirewallDNSRuleDepartments `pulumi:"departments"`
	// Additional information about the rule
	Description *string `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses []string `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries []string `pulumi:"destCountries"`
	// Destination IP categories to which the rule applies. If not set, the rule is not restricted to specific categories.
	DestIpCategories []string `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups *FirewallDNSRuleDestIpGroups `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups *FirewallDNSRuleDestIpv6Groups `pulumi:"destIpv6Groups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *FirewallDNSRuleDeviceGroups `pulumi:"deviceGroups"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *FirewallDNSRuleDevices `pulumi:"devices"`
	// The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS
	// service
	DnsGateway *FirewallDNSRuleDnsGateway `pulumi:"dnsGateway"`
	// DNS request types to which the rule applies
	DnsRuleRequestTypes []string `pulumi:"dnsRuleRequestTypes"`
	// The EDNS ECS object which resolves DNS request
	EdnsEcsObject *FirewallDNSRuleEdnsEcsObject `pulumi:"ednsEcsObject"`
	// list of groups for which rule must be applied
	Groups *FirewallDNSRuleGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *FirewallDNSRuleLabels `pulumi:"labels"`
	// list of locations groups
	LocationGroups *FirewallDNSRuleLocationGroups `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations *FirewallDNSRuleLocations `pulumi:"locations"`
	// The name of the IPS Control rule
	Name *string `pulumi:"name"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order *int `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined *bool `pulumi:"predefined"`
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols []string `pulumi:"protocols"`
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank *int `pulumi:"rank"`
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	RedirectIp *string `pulumi:"redirectIp"`
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	RuleId        *int     `pulumi:"ruleId"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries []string `pulumi:"sourceCountries"`
	// list of Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address group.
	SrcIpGroups *FirewallDNSRuleSrcIpGroups `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps []string `pulumi:"srcIps"`
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups *FirewallDNSRuleSrcIpv6Groups `pulumi:"srcIpv6Groups"`
	// The state of the rule indicating whether it is enabled or disabled
	State *string `pulumi:"state"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows *FirewallDNSRuleTimeWindows `pulumi:"timeWindows"`
	// list of users for which rule must be applied
	Users *FirewallDNSRuleUsers `pulumi:"users"`
	// The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address
	// from a preconfigured IP pool
	ZpaIpGroup *FirewallDNSRuleZpaIpGroup `pulumi:"zpaIpGroup"`
}

type FirewallDNSRuleState struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing,
	// blocking, or redirecting the traffic.
	Action pulumi.StringPtrInput
	// list of nw application groups
	ApplicationGroups FirewallDNSRuleApplicationGroupsPtrInput
	// User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a
	// specific network service application.
	Applications pulumi.StringArrayInput
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	BlockResponseCode pulumi.StringPtrInput
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrInput
	// list of departments for which rule must be applied
	Departments FirewallDNSRuleDepartmentsPtrInput
	// Additional information about the rule
	Description pulumi.StringPtrInput
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries pulumi.StringArrayInput
	// Destination IP categories to which the rule applies. If not set, the rule is not restricted to specific categories.
	DestIpCategories pulumi.StringArrayInput
	// list of destination ip groups
	DestIpGroups FirewallDNSRuleDestIpGroupsPtrInput
	// list of destination ip groups
	DestIpv6Groups FirewallDNSRuleDestIpv6GroupsPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FirewallDNSRuleDeviceGroupsPtrInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices FirewallDNSRuleDevicesPtrInput
	// The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS
	// service
	DnsGateway FirewallDNSRuleDnsGatewayPtrInput
	// DNS request types to which the rule applies
	DnsRuleRequestTypes pulumi.StringArrayInput
	// The EDNS ECS object which resolves DNS request
	EdnsEcsObject FirewallDNSRuleEdnsEcsObjectPtrInput
	// list of groups for which rule must be applied
	Groups FirewallDNSRuleGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels FirewallDNSRuleLabelsPtrInput
	// list of locations groups
	LocationGroups FirewallDNSRuleLocationGroupsPtrInput
	// list of locations for which rule must be applied
	Locations FirewallDNSRuleLocationsPtrInput
	// The name of the IPS Control rule
	Name pulumi.StringPtrInput
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntPtrInput
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrInput
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols pulumi.StringArrayInput
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank pulumi.IntPtrInput
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	RedirectIp pulumi.StringPtrInput
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories pulumi.StringArrayInput
	RuleId        pulumi.IntPtrInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries pulumi.StringArrayInput
	// list of Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address group.
	SrcIpGroups FirewallDNSRuleSrcIpGroupsPtrInput
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps pulumi.StringArrayInput
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups FirewallDNSRuleSrcIpv6GroupsPtrInput
	// The state of the rule indicating whether it is enabled or disabled
	State pulumi.StringPtrInput
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows FirewallDNSRuleTimeWindowsPtrInput
	// list of users for which rule must be applied
	Users FirewallDNSRuleUsersPtrInput
	// The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address
	// from a preconfigured IP pool
	ZpaIpGroup FirewallDNSRuleZpaIpGroupPtrInput
}

func (FirewallDNSRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallDNSRuleState)(nil)).Elem()
}

type firewallDNSRuleArgs struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing,
	// blocking, or redirecting the traffic.
	Action *string `pulumi:"action"`
	// list of nw application groups
	ApplicationGroups *FirewallDNSRuleApplicationGroups `pulumi:"applicationGroups"`
	// User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a
	// specific network service application.
	Applications []string `pulumi:"applications"`
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	BlockResponseCode *string `pulumi:"blockResponseCode"`
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap *bool `pulumi:"capturePcap"`
	// If set to true, the default rule is applied
	DefaultRule *bool `pulumi:"defaultRule"`
	// list of departments for which rule must be applied
	Departments *FirewallDNSRuleDepartments `pulumi:"departments"`
	// Additional information about the rule
	Description *string `pulumi:"description"`
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses []string `pulumi:"destAddresses"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries []string `pulumi:"destCountries"`
	// Destination IP categories to which the rule applies. If not set, the rule is not restricted to specific categories.
	DestIpCategories []string `pulumi:"destIpCategories"`
	// list of destination ip groups
	DestIpGroups *FirewallDNSRuleDestIpGroups `pulumi:"destIpGroups"`
	// list of destination ip groups
	DestIpv6Groups *FirewallDNSRuleDestIpv6Groups `pulumi:"destIpv6Groups"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *FirewallDNSRuleDeviceGroups `pulumi:"deviceGroups"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *FirewallDNSRuleDevices `pulumi:"devices"`
	// The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS
	// service
	DnsGateway *FirewallDNSRuleDnsGateway `pulumi:"dnsGateway"`
	// DNS request types to which the rule applies
	DnsRuleRequestTypes []string `pulumi:"dnsRuleRequestTypes"`
	// The EDNS ECS object which resolves DNS request
	EdnsEcsObject *FirewallDNSRuleEdnsEcsObject `pulumi:"ednsEcsObject"`
	// list of groups for which rule must be applied
	Groups *FirewallDNSRuleGroups `pulumi:"groups"`
	// list of Labels that are applicable to the rule.
	Labels *FirewallDNSRuleLabels `pulumi:"labels"`
	// list of locations groups
	LocationGroups *FirewallDNSRuleLocationGroups `pulumi:"locationGroups"`
	// list of locations for which rule must be applied
	Locations *FirewallDNSRuleLocations `pulumi:"locations"`
	// The name of the IPS Control rule
	Name *string `pulumi:"name"`
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order int `pulumi:"order"`
	// If set to true, a predefined rule is applied
	Predefined *bool `pulumi:"predefined"`
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols []string `pulumi:"protocols"`
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank *int `pulumi:"rank"`
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	RedirectIp *string `pulumi:"redirectIp"`
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories []string `pulumi:"resCategories"`
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries []string `pulumi:"sourceCountries"`
	// list of Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address group.
	SrcIpGroups *FirewallDNSRuleSrcIpGroups `pulumi:"srcIpGroups"`
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps []string `pulumi:"srcIps"`
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups *FirewallDNSRuleSrcIpv6Groups `pulumi:"srcIpv6Groups"`
	// The state of the rule indicating whether it is enabled or disabled
	State *string `pulumi:"state"`
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows *FirewallDNSRuleTimeWindows `pulumi:"timeWindows"`
	// list of users for which rule must be applied
	Users *FirewallDNSRuleUsers `pulumi:"users"`
	// The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address
	// from a preconfigured IP pool
	ZpaIpGroup *FirewallDNSRuleZpaIpGroup `pulumi:"zpaIpGroup"`
}

// The set of arguments for constructing a FirewallDNSRule resource.
type FirewallDNSRuleArgs struct {
	// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing,
	// blocking, or redirecting the traffic.
	Action pulumi.StringPtrInput
	// list of nw application groups
	ApplicationGroups FirewallDNSRuleApplicationGroupsPtrInput
	// User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a
	// specific network service application.
	Applications pulumi.StringArrayInput
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	BlockResponseCode pulumi.StringPtrInput
	// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
	CapturePcap pulumi.BoolPtrInput
	// If set to true, the default rule is applied
	DefaultRule pulumi.BoolPtrInput
	// list of departments for which rule must be applied
	Departments FirewallDNSRuleDepartmentsPtrInput
	// Additional information about the rule
	Description pulumi.StringPtrInput
	// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
	DestAddresses pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	DestCountries pulumi.StringArrayInput
	// Destination IP categories to which the rule applies. If not set, the rule is not restricted to specific categories.
	DestIpCategories pulumi.StringArrayInput
	// list of destination ip groups
	DestIpGroups FirewallDNSRuleDestIpGroupsPtrInput
	// list of destination ip groups
	DestIpv6Groups FirewallDNSRuleDestIpv6GroupsPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups FirewallDNSRuleDeviceGroupsPtrInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices FirewallDNSRuleDevicesPtrInput
	// The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS
	// service
	DnsGateway FirewallDNSRuleDnsGatewayPtrInput
	// DNS request types to which the rule applies
	DnsRuleRequestTypes pulumi.StringArrayInput
	// The EDNS ECS object which resolves DNS request
	EdnsEcsObject FirewallDNSRuleEdnsEcsObjectPtrInput
	// list of groups for which rule must be applied
	Groups FirewallDNSRuleGroupsPtrInput
	// list of Labels that are applicable to the rule.
	Labels FirewallDNSRuleLabelsPtrInput
	// list of locations groups
	LocationGroups FirewallDNSRuleLocationGroupsPtrInput
	// list of locations for which rule must be applied
	Locations FirewallDNSRuleLocationsPtrInput
	// The name of the IPS Control rule
	Name pulumi.StringPtrInput
	// Rule order number. If omitted, the rule will be added to the end of the rule set.
	Order pulumi.IntInput
	// If set to true, a predefined rule is applied
	Predefined pulumi.BoolPtrInput
	// Protocol for the given rule. This field is not applicable to the Lite API.
	Protocols pulumi.StringArrayInput
	// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
	// be specified for the rule.
	Rank pulumi.IntPtrInput
	// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
	// done to specific IP addresses.
	RedirectIp pulumi.StringPtrInput
	// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
	// to a specific URL category.
	ResCategories pulumi.StringArrayInput
	// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
	// countries.
	SourceCountries pulumi.StringArrayInput
	// list of Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address group.
	SrcIpGroups FirewallDNSRuleSrcIpGroupsPtrInput
	// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
	// source IP address.
	SrcIps pulumi.StringArrayInput
	// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
	// specific source IPv6 address group.
	SrcIpv6Groups FirewallDNSRuleSrcIpv6GroupsPtrInput
	// The state of the rule indicating whether it is enabled or disabled
	State pulumi.StringPtrInput
	// The time interval in which the Firewall Filtering policy rule applies
	TimeWindows FirewallDNSRuleTimeWindowsPtrInput
	// list of users for which rule must be applied
	Users FirewallDNSRuleUsersPtrInput
	// The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address
	// from a preconfigured IP pool
	ZpaIpGroup FirewallDNSRuleZpaIpGroupPtrInput
}

func (FirewallDNSRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallDNSRuleArgs)(nil)).Elem()
}

type FirewallDNSRuleInput interface {
	pulumi.Input

	ToFirewallDNSRuleOutput() FirewallDNSRuleOutput
	ToFirewallDNSRuleOutputWithContext(ctx context.Context) FirewallDNSRuleOutput
}

func (*FirewallDNSRule) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallDNSRule)(nil)).Elem()
}

func (i *FirewallDNSRule) ToFirewallDNSRuleOutput() FirewallDNSRuleOutput {
	return i.ToFirewallDNSRuleOutputWithContext(context.Background())
}

func (i *FirewallDNSRule) ToFirewallDNSRuleOutputWithContext(ctx context.Context) FirewallDNSRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallDNSRuleOutput)
}

// FirewallDNSRuleArrayInput is an input type that accepts FirewallDNSRuleArray and FirewallDNSRuleArrayOutput values.
// You can construct a concrete instance of `FirewallDNSRuleArrayInput` via:
//
//	FirewallDNSRuleArray{ FirewallDNSRuleArgs{...} }
type FirewallDNSRuleArrayInput interface {
	pulumi.Input

	ToFirewallDNSRuleArrayOutput() FirewallDNSRuleArrayOutput
	ToFirewallDNSRuleArrayOutputWithContext(context.Context) FirewallDNSRuleArrayOutput
}

type FirewallDNSRuleArray []FirewallDNSRuleInput

func (FirewallDNSRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallDNSRule)(nil)).Elem()
}

func (i FirewallDNSRuleArray) ToFirewallDNSRuleArrayOutput() FirewallDNSRuleArrayOutput {
	return i.ToFirewallDNSRuleArrayOutputWithContext(context.Background())
}

func (i FirewallDNSRuleArray) ToFirewallDNSRuleArrayOutputWithContext(ctx context.Context) FirewallDNSRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallDNSRuleArrayOutput)
}

// FirewallDNSRuleMapInput is an input type that accepts FirewallDNSRuleMap and FirewallDNSRuleMapOutput values.
// You can construct a concrete instance of `FirewallDNSRuleMapInput` via:
//
//	FirewallDNSRuleMap{ "key": FirewallDNSRuleArgs{...} }
type FirewallDNSRuleMapInput interface {
	pulumi.Input

	ToFirewallDNSRuleMapOutput() FirewallDNSRuleMapOutput
	ToFirewallDNSRuleMapOutputWithContext(context.Context) FirewallDNSRuleMapOutput
}

type FirewallDNSRuleMap map[string]FirewallDNSRuleInput

func (FirewallDNSRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallDNSRule)(nil)).Elem()
}

func (i FirewallDNSRuleMap) ToFirewallDNSRuleMapOutput() FirewallDNSRuleMapOutput {
	return i.ToFirewallDNSRuleMapOutputWithContext(context.Background())
}

func (i FirewallDNSRuleMap) ToFirewallDNSRuleMapOutputWithContext(ctx context.Context) FirewallDNSRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallDNSRuleMapOutput)
}

type FirewallDNSRuleOutput struct{ *pulumi.OutputState }

func (FirewallDNSRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallDNSRule)(nil)).Elem()
}

func (o FirewallDNSRuleOutput) ToFirewallDNSRuleOutput() FirewallDNSRuleOutput {
	return o
}

func (o FirewallDNSRuleOutput) ToFirewallDNSRuleOutputWithContext(ctx context.Context) FirewallDNSRuleOutput {
	return o
}

// The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing,
// blocking, or redirecting the traffic.
func (o FirewallDNSRuleOutput) Action() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.Action }).(pulumi.StringPtrOutput)
}

// list of nw application groups
func (o FirewallDNSRuleOutput) ApplicationGroups() FirewallDNSRuleApplicationGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleApplicationGroupsPtrOutput { return v.ApplicationGroups }).(FirewallDNSRuleApplicationGroupsPtrOutput)
}

// User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a
// specific network service application.
func (o FirewallDNSRuleOutput) Applications() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.Applications }).(pulumi.StringArrayOutput)
}

// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
// done to specific IP addresses.
func (o FirewallDNSRuleOutput) BlockResponseCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.BlockResponseCode }).(pulumi.StringPtrOutput)
}

// A Boolean value that indicates whether packet capture (PCAP) is enabled or not
func (o FirewallDNSRuleOutput) CapturePcap() pulumi.BoolOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.BoolOutput { return v.CapturePcap }).(pulumi.BoolOutput)
}

// If set to true, the default rule is applied
func (o FirewallDNSRuleOutput) DefaultRule() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.BoolPtrOutput { return v.DefaultRule }).(pulumi.BoolPtrOutput)
}

// list of departments for which rule must be applied
func (o FirewallDNSRuleOutput) Departments() FirewallDNSRuleDepartmentsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDepartmentsPtrOutput { return v.Departments }).(FirewallDNSRuleDepartmentsPtrOutput)
}

// Additional information about the rule
func (o FirewallDNSRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
func (o FirewallDNSRuleOutput) DestAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DestAddresses }).(pulumi.StringArrayOutput)
}

// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
// countries.
func (o FirewallDNSRuleOutput) DestCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DestCountries }).(pulumi.StringArrayOutput)
}

// Destination IP categories to which the rule applies. If not set, the rule is not restricted to specific categories.
func (o FirewallDNSRuleOutput) DestIpCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DestIpCategories }).(pulumi.StringArrayOutput)
}

// list of destination ip groups
func (o FirewallDNSRuleOutput) DestIpGroups() FirewallDNSRuleDestIpGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDestIpGroupsPtrOutput { return v.DestIpGroups }).(FirewallDNSRuleDestIpGroupsPtrOutput)
}

// list of destination ip groups
func (o FirewallDNSRuleOutput) DestIpv6Groups() FirewallDNSRuleDestIpv6GroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDestIpv6GroupsPtrOutput { return v.DestIpv6Groups }).(FirewallDNSRuleDestIpv6GroupsPtrOutput)
}

// This field is applicable for devices that are managed using Zscaler Client Connector.
func (o FirewallDNSRuleOutput) DeviceGroups() FirewallDNSRuleDeviceGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDeviceGroupsPtrOutput { return v.DeviceGroups }).(FirewallDNSRuleDeviceGroupsPtrOutput)
}

// Name-ID pairs of devices for which rule must be applied.
func (o FirewallDNSRuleOutput) Devices() FirewallDNSRuleDevicesPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDevicesPtrOutput { return v.Devices }).(FirewallDNSRuleDevicesPtrOutput)
}

// The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS
// service
func (o FirewallDNSRuleOutput) DnsGateway() FirewallDNSRuleDnsGatewayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleDnsGatewayOutput { return v.DnsGateway }).(FirewallDNSRuleDnsGatewayOutput)
}

// DNS request types to which the rule applies
func (o FirewallDNSRuleOutput) DnsRuleRequestTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.DnsRuleRequestTypes }).(pulumi.StringArrayOutput)
}

// The EDNS ECS object which resolves DNS request
func (o FirewallDNSRuleOutput) EdnsEcsObject() FirewallDNSRuleEdnsEcsObjectOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleEdnsEcsObjectOutput { return v.EdnsEcsObject }).(FirewallDNSRuleEdnsEcsObjectOutput)
}

// list of groups for which rule must be applied
func (o FirewallDNSRuleOutput) Groups() FirewallDNSRuleGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleGroupsPtrOutput { return v.Groups }).(FirewallDNSRuleGroupsPtrOutput)
}

// list of Labels that are applicable to the rule.
func (o FirewallDNSRuleOutput) Labels() FirewallDNSRuleLabelsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleLabelsPtrOutput { return v.Labels }).(FirewallDNSRuleLabelsPtrOutput)
}

// list of locations groups
func (o FirewallDNSRuleOutput) LocationGroups() FirewallDNSRuleLocationGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleLocationGroupsPtrOutput { return v.LocationGroups }).(FirewallDNSRuleLocationGroupsPtrOutput)
}

// list of locations for which rule must be applied
func (o FirewallDNSRuleOutput) Locations() FirewallDNSRuleLocationsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleLocationsPtrOutput { return v.Locations }).(FirewallDNSRuleLocationsPtrOutput)
}

// The name of the IPS Control rule
func (o FirewallDNSRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Rule order number. If omitted, the rule will be added to the end of the rule set.
func (o FirewallDNSRuleOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// If set to true, a predefined rule is applied
func (o FirewallDNSRuleOutput) Predefined() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.BoolPtrOutput { return v.Predefined }).(pulumi.BoolPtrOutput)
}

// Protocol for the given rule. This field is not applicable to the Lite API.
func (o FirewallDNSRuleOutput) Protocols() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.Protocols }).(pulumi.StringArrayOutput)
}

// The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can
// be specified for the rule.
func (o FirewallDNSRuleOutput) Rank() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.IntPtrOutput { return v.Rank }).(pulumi.IntPtrOutput)
}

// The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is
// done to specific IP addresses.
func (o FirewallDNSRuleOutput) RedirectIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.RedirectIp }).(pulumi.StringPtrOutput)
}

// URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted
// to a specific URL category.
func (o FirewallDNSRuleOutput) ResCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.ResCategories }).(pulumi.StringArrayOutput)
}

func (o FirewallDNSRuleOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination
// countries.
func (o FirewallDNSRuleOutput) SourceCountries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.SourceCountries }).(pulumi.StringArrayOutput)
}

// list of Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific
// source IP address group.
func (o FirewallDNSRuleOutput) SrcIpGroups() FirewallDNSRuleSrcIpGroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleSrcIpGroupsPtrOutput { return v.SrcIpGroups }).(FirewallDNSRuleSrcIpGroupsPtrOutput)
}

// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific
// source IP address.
func (o FirewallDNSRuleOutput) SrcIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringArrayOutput { return v.SrcIps }).(pulumi.StringArrayOutput)
}

// list of Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a
// specific source IPv6 address group.
func (o FirewallDNSRuleOutput) SrcIpv6Groups() FirewallDNSRuleSrcIpv6GroupsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleSrcIpv6GroupsPtrOutput { return v.SrcIpv6Groups }).(FirewallDNSRuleSrcIpv6GroupsPtrOutput)
}

// The state of the rule indicating whether it is enabled or disabled
func (o FirewallDNSRuleOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// The time interval in which the Firewall Filtering policy rule applies
func (o FirewallDNSRuleOutput) TimeWindows() FirewallDNSRuleTimeWindowsPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleTimeWindowsPtrOutput { return v.TimeWindows }).(FirewallDNSRuleTimeWindowsPtrOutput)
}

// list of users for which rule must be applied
func (o FirewallDNSRuleOutput) Users() FirewallDNSRuleUsersPtrOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleUsersPtrOutput { return v.Users }).(FirewallDNSRuleUsersPtrOutput)
}

// The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address
// from a preconfigured IP pool
func (o FirewallDNSRuleOutput) ZpaIpGroup() FirewallDNSRuleZpaIpGroupOutput {
	return o.ApplyT(func(v *FirewallDNSRule) FirewallDNSRuleZpaIpGroupOutput { return v.ZpaIpGroup }).(FirewallDNSRuleZpaIpGroupOutput)
}

type FirewallDNSRuleArrayOutput struct{ *pulumi.OutputState }

func (FirewallDNSRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallDNSRule)(nil)).Elem()
}

func (o FirewallDNSRuleArrayOutput) ToFirewallDNSRuleArrayOutput() FirewallDNSRuleArrayOutput {
	return o
}

func (o FirewallDNSRuleArrayOutput) ToFirewallDNSRuleArrayOutputWithContext(ctx context.Context) FirewallDNSRuleArrayOutput {
	return o
}

func (o FirewallDNSRuleArrayOutput) Index(i pulumi.IntInput) FirewallDNSRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FirewallDNSRule {
		return vs[0].([]*FirewallDNSRule)[vs[1].(int)]
	}).(FirewallDNSRuleOutput)
}

type FirewallDNSRuleMapOutput struct{ *pulumi.OutputState }

func (FirewallDNSRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallDNSRule)(nil)).Elem()
}

func (o FirewallDNSRuleMapOutput) ToFirewallDNSRuleMapOutput() FirewallDNSRuleMapOutput {
	return o
}

func (o FirewallDNSRuleMapOutput) ToFirewallDNSRuleMapOutputWithContext(ctx context.Context) FirewallDNSRuleMapOutput {
	return o
}

func (o FirewallDNSRuleMapOutput) MapIndex(k pulumi.StringInput) FirewallDNSRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FirewallDNSRule {
		return vs[0].(map[string]*FirewallDNSRule)[vs[1].(string)]
	}).(FirewallDNSRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallDNSRuleInput)(nil)).Elem(), &FirewallDNSRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallDNSRuleArrayInput)(nil)).Elem(), FirewallDNSRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallDNSRuleMapInput)(nil)).Elem(), FirewallDNSRuleMap{})
	pulumi.RegisterOutputType(FirewallDNSRuleOutput{})
	pulumi.RegisterOutputType(FirewallDNSRuleArrayOutput{})
	pulumi.RegisterOutputType(FirewallDNSRuleMapOutput{})
}

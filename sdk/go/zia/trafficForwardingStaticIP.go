// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// * [Official documentation](https://help.zscaler.com/zia/about-static-ip)
// * [API documentation](https://help.zscaler.com/zia/traffic-forwarding-0#/staticIP-get)
//
// The **zia_traffic_forwarding_static_ip** resource allows the creation and management of static IP addresses in the Zscaler Internet Access cloud. The resource can then be associated with other resources such as:
//
// * VPN Credentials of type `IP`
// * Location Management
// * GRE Tunnel
//
// ## üéØ Automatic Coordinate Determination (v4.6.2+)
//
// Starting with **version 4.6.2**, the provider automatically determines latitude and longitude coordinates from the IP address, even when `geoOverride = true`. This means:
//
// * ‚úÖ **No manual coordinate lookups** - Provider handles it automatically
// * ‚úÖ **No drift issues** - State always contains exact API values
// * ‚úÖ **Simpler configuration** - Omit `latitude` and `longitude` for automatic determination
// * ‚úÖ **Fully backward compatible** - Explicit coordinates still work if provided
//
// **In short:** You can now use `geoOverride = true` without specifying coordinates! See examples below.
//
// ## Example Usage
//
// ### Example 1: Auto-Determined Coordinates (Recommended)
//
// ### Example 2: User-Specified Coordinates (Optional)
//
// ### Example 3: Automatic Geolocation (geo_override = false)
//
// ## How Latitude and Longitude Are Determined
//
// The provider handles coordinates intelligently based on your configuration:
//
// ### When `geoOverride = false` (or omitted)
// * ‚úÖ **Provider behavior**: Latitude and longitude are automatically determined by the ZIA API based on the IP address
// * ‚úÖ **State file**: Will contain the API-determined coordinates
// * ‚úÖ **User action**: None required - fully automatic
//
// ### When `geoOverride = true` WITHOUT coordinates
// * ‚úÖ **Provider behavior**:
//  1. Creates the static IP with `geoOverride = false` first
//  2. Retrieves the auto-determined coordinates from the API
//  3. Updates the static IP with `geoOverride = true` using those coordinates
//
// * ‚úÖ **State file**: Will contain the auto-determined coordinates
// * ‚úÖ **User action**: None required - provider handles it automatically
// * ‚úÖ **Result**: You get `geoOverride = true` without manually looking up coordinates
//
// ### When `geoOverride = true` WITH coordinates
// * ‚úÖ **Provider behavior**: Uses your specified coordinates
// * ‚úÖ **State file**: Will contain the exact values returned by the API (may have minor precision adjustments)
// * ‚úÖ **User action**: Provide `latitude` and `longitude` values
// * ‚úÖ **Result**: Your custom coordinates are used
//
// ### Key Benefits
// * üéØ **No drift issues** - State always contains exact API values
// * üéØ **No manual lookups** - API determines accurate coordinates from IP
// * üéØ **Flexible** - Can override coordinates when needed
// * üéØ **Always accurate** - Coordinates match the IP address geolocation
//
// ## Common Use Cases
//
// ### Use Case 1: GRE Tunnel with Auto-Determined Coordinates
//
// ### Use Case 2: Multiple Static IPs with forEach
//
// ### Use Case 3: VPN Credentials Integration
//
// ## Frequently Asked Questions (FAQ)
//
// ### Q: Do I need to specify latitude and longitude when using geoOverride = true?
//
// **A:** No! The provider will automatically determine coordinates from the IP address if you don't provide them. This is the **recommended approach** to avoid drift issues.
//
// ### Q: What if I want to use specific coordinates?
//
// **A:** You can still provide `latitude` and `longitude` explicitly. The provider will use your values if provided.
//
// ### Q: Will there be drift if I don't specify coordinates?
//
// **A:** No! The state file will contain the exact coordinates returned by the ZIA API. Subsequent `pulumi preview` commands will show no changes.
//
// ### Q: What happens if I provide coordinates that don't match the IP location?
//
// **A:** The API will accept your coordinates, but they may be adjusted for precision. The state file will always reflect the actual API response values.
//
// ### Q: Can I change from auto-determined to custom coordinates later?
//
// **A:** Yes! Simply add `latitude` and `longitude` to your configuration and run `pulumi up`. The provider will update the static IP with your custom coordinates.
//
// ### Q: What precision does the API use for coordinates?
//
// **A:** The API typically returns 4-7 decimal places depending on the IP location. The provider stores these exact values without rounding.
//
// ### Q: Why does my state show geoOverride = true but I didn't set it?
//
// **A:** The `geoOverride` attribute has `Computed: true`, meaning it's populated from the API response. The API may set it based on other factors.
//
// ## Troubleshooting
//
// ### Error: "Missing geo Coordinates"
//
// This error should no longer occur with the updated provider. If you still see it:
//
// 1. Ensure you're using provider version 4.6.2 or later
// 2. Check if coordinates are being populated: `terraform state show zia_traffic_forwarding_static_ip.<name>`
// 3. Enable debug logging: `export TF_LOG=DEBUG` and check for auto-population messages
//
// ### Unexpected Drift Detected
//
// If `pulumi preview` shows coordinate changes:
//
// 1. **Solution**: Remove explicit `latitude` and `longitude` from your configuration
// 2. **Reason**: API values may differ slightly from user-provided values due to precision
// 3. **After removal**: Run `pulumi up` once - state will sync with API values
// 4. **Future plans**: Will show no changes
//
// ### Coordinates Not in Expected Location
//
// The coordinates reflect the IP address's actual geolocation as determined by Zscaler's geolocation database. If you need different coordinates:
//
// 1. Set `geoOverride = true`
// 2. Provide your desired `latitude` and `longitude` explicitly
// 3. The API will use your values
//
// ## Best Practices
//
// ### ‚úÖ Recommended: Let the Provider Auto-Determine Coordinates
//
// **Why this is recommended:**
//
// * ‚úÖ No manual coordinate lookups required
// * ‚úÖ Zero drift - state always matches API
// * ‚úÖ Accurate - API knows the correct geolocation for each IP
// * ‚úÖ Maintainable - no hardcoded coordinates to update
//
// ### ‚ö†Ô∏è Use Custom Coordinates Only When Necessary
//
// Only provide explicit coordinates if you have a specific requirement:
//
// **When to use custom coordinates:**
//
// * Testing with specific geographic locations
// * Compliance requirements for specific geo-coordinates
// * Override API's geolocation database for special cases
//
// ## Migration Guide for Existing Users
//
// If you're upgrading from an older provider version (< 4.6.2), you may have configurations like this:
//
// ### Old Configuration (Still Works, But Not Recommended)
//
// ### Migrating to New Approach (Recommended)
//
// **Step 1:** Remove `latitude` and `longitude` from your configuration
//
// **Step 2:** Run `pulumi preview`
//
// You'll see Terraform wants to update the resource (to remove explicitly set coordinates from state).
//
// **Step 3:** Apply the changes
//
// The provider will:
//
// * Keep the same static IP (no destruction)
// * Auto-determine coordinates from the IP
// * Update state with API values
// * No infrastructure change - just cleaner config!
//
// **Step 4:** Verify no drift
//
// ### Migration Example: Full Before/After
//
// **Before Migration:**
//
// **After Migration:**
//
// **Migration Impact:**
//
// * Configuration: 8 lines removed (cleaner)
// * API calls: No additional overhead after migration
// * Drift: Eliminated
// * Maintenance: Easier
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
// Visit
//
// Static IP resources can be imported by using `<STATIC IP ID>` or `<IP ADDRESS>` as the import ID.
//
// ### Import by Static IP ID
//
// ```sh
// $ pulumi import zia:index/trafficForwardingStaticIP:TrafficForwardingStaticIP example <static_ip_id>
// ```
//
// Example:
//
// ```sh
// $ pulumi import zia:index/trafficForwardingStaticIP:TrafficForwardingStaticIP chennai 3030759
// ```
//
// ### Import by IP Address
//
// ```sh
// $ pulumi import zia:index/trafficForwardingStaticIP:TrafficForwardingStaticIP example <ip_address>
// ```
//
// Example:
//
// ```sh
// $ pulumi import zia:index/trafficForwardingStaticIP:TrafficForwardingStaticIP chennai 122.164.82.249
// ```
//
// **After Import:**
//
// * The state will include all attributes including latitude and longitude
// * You can omit coordinates from your configuration - state will remain accurate
// * Run `pulumi preview` to see what configuration should look like
type TrafficForwardingStaticIP struct {
	pulumi.CustomResourceState

	// Additional information about this static IP address
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
	GeoOverride pulumi.BoolOutput `pulumi:"geoOverride"`
	// The static IP address
	IpAddress pulumi.StringOutput `pulumi:"ipAddress"`
	// Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees. If not provided, the API will automatically determine it from the IP address.
	Latitude pulumi.Float64Output `pulumi:"latitude"`
	// Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees. If not provided, the API will automatically determine it from the IP address.
	Longitude pulumi.Float64Output `pulumi:"longitude"`
	// Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
	RoutableIp pulumi.BoolOutput `pulumi:"routableIp"`
	// The ID of the Static IP.
	StaticIpId pulumi.IntOutput `pulumi:"staticIpId"`
}

// NewTrafficForwardingStaticIP registers a new resource with the given unique name, arguments, and options.
func NewTrafficForwardingStaticIP(ctx *pulumi.Context,
	name string, args *TrafficForwardingStaticIPArgs, opts ...pulumi.ResourceOption) (*TrafficForwardingStaticIP, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IpAddress == nil {
		return nil, errors.New("invalid value for required argument 'IpAddress'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TrafficForwardingStaticIP
	err := ctx.RegisterResource("zia:index/trafficForwardingStaticIP:TrafficForwardingStaticIP", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTrafficForwardingStaticIP gets an existing TrafficForwardingStaticIP resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTrafficForwardingStaticIP(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TrafficForwardingStaticIPState, opts ...pulumi.ResourceOption) (*TrafficForwardingStaticIP, error) {
	var resource TrafficForwardingStaticIP
	err := ctx.ReadResource("zia:index/trafficForwardingStaticIP:TrafficForwardingStaticIP", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TrafficForwardingStaticIP resources.
type trafficForwardingStaticIPState struct {
	// Additional information about this static IP address
	Comment *string `pulumi:"comment"`
	// If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
	GeoOverride *bool `pulumi:"geoOverride"`
	// The static IP address
	IpAddress *string `pulumi:"ipAddress"`
	// Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees. If not provided, the API will automatically determine it from the IP address.
	Latitude *float64 `pulumi:"latitude"`
	// Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees. If not provided, the API will automatically determine it from the IP address.
	Longitude *float64 `pulumi:"longitude"`
	// Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
	RoutableIp *bool `pulumi:"routableIp"`
	// The ID of the Static IP.
	StaticIpId *int `pulumi:"staticIpId"`
}

type TrafficForwardingStaticIPState struct {
	// Additional information about this static IP address
	Comment pulumi.StringPtrInput
	// If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
	GeoOverride pulumi.BoolPtrInput
	// The static IP address
	IpAddress pulumi.StringPtrInput
	// Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees. If not provided, the API will automatically determine it from the IP address.
	Latitude pulumi.Float64PtrInput
	// Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees. If not provided, the API will automatically determine it from the IP address.
	Longitude pulumi.Float64PtrInput
	// Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
	RoutableIp pulumi.BoolPtrInput
	// The ID of the Static IP.
	StaticIpId pulumi.IntPtrInput
}

func (TrafficForwardingStaticIPState) ElementType() reflect.Type {
	return reflect.TypeOf((*trafficForwardingStaticIPState)(nil)).Elem()
}

type trafficForwardingStaticIPArgs struct {
	// Additional information about this static IP address
	Comment *string `pulumi:"comment"`
	// If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
	GeoOverride *bool `pulumi:"geoOverride"`
	// The static IP address
	IpAddress string `pulumi:"ipAddress"`
	// Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees. If not provided, the API will automatically determine it from the IP address.
	Latitude *float64 `pulumi:"latitude"`
	// Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees. If not provided, the API will automatically determine it from the IP address.
	Longitude *float64 `pulumi:"longitude"`
	// Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
	RoutableIp *bool `pulumi:"routableIp"`
}

// The set of arguments for constructing a TrafficForwardingStaticIP resource.
type TrafficForwardingStaticIPArgs struct {
	// Additional information about this static IP address
	Comment pulumi.StringPtrInput
	// If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
	GeoOverride pulumi.BoolPtrInput
	// The static IP address
	IpAddress pulumi.StringInput
	// Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees. If not provided, the API will automatically determine it from the IP address.
	Latitude pulumi.Float64PtrInput
	// Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees. If not provided, the API will automatically determine it from the IP address.
	Longitude pulumi.Float64PtrInput
	// Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
	RoutableIp pulumi.BoolPtrInput
}

func (TrafficForwardingStaticIPArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*trafficForwardingStaticIPArgs)(nil)).Elem()
}

type TrafficForwardingStaticIPInput interface {
	pulumi.Input

	ToTrafficForwardingStaticIPOutput() TrafficForwardingStaticIPOutput
	ToTrafficForwardingStaticIPOutputWithContext(ctx context.Context) TrafficForwardingStaticIPOutput
}

func (*TrafficForwardingStaticIP) ElementType() reflect.Type {
	return reflect.TypeOf((**TrafficForwardingStaticIP)(nil)).Elem()
}

func (i *TrafficForwardingStaticIP) ToTrafficForwardingStaticIPOutput() TrafficForwardingStaticIPOutput {
	return i.ToTrafficForwardingStaticIPOutputWithContext(context.Background())
}

func (i *TrafficForwardingStaticIP) ToTrafficForwardingStaticIPOutputWithContext(ctx context.Context) TrafficForwardingStaticIPOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficForwardingStaticIPOutput)
}

// TrafficForwardingStaticIPArrayInput is an input type that accepts TrafficForwardingStaticIPArray and TrafficForwardingStaticIPArrayOutput values.
// You can construct a concrete instance of `TrafficForwardingStaticIPArrayInput` via:
//
//	TrafficForwardingStaticIPArray{ TrafficForwardingStaticIPArgs{...} }
type TrafficForwardingStaticIPArrayInput interface {
	pulumi.Input

	ToTrafficForwardingStaticIPArrayOutput() TrafficForwardingStaticIPArrayOutput
	ToTrafficForwardingStaticIPArrayOutputWithContext(context.Context) TrafficForwardingStaticIPArrayOutput
}

type TrafficForwardingStaticIPArray []TrafficForwardingStaticIPInput

func (TrafficForwardingStaticIPArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TrafficForwardingStaticIP)(nil)).Elem()
}

func (i TrafficForwardingStaticIPArray) ToTrafficForwardingStaticIPArrayOutput() TrafficForwardingStaticIPArrayOutput {
	return i.ToTrafficForwardingStaticIPArrayOutputWithContext(context.Background())
}

func (i TrafficForwardingStaticIPArray) ToTrafficForwardingStaticIPArrayOutputWithContext(ctx context.Context) TrafficForwardingStaticIPArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficForwardingStaticIPArrayOutput)
}

// TrafficForwardingStaticIPMapInput is an input type that accepts TrafficForwardingStaticIPMap and TrafficForwardingStaticIPMapOutput values.
// You can construct a concrete instance of `TrafficForwardingStaticIPMapInput` via:
//
//	TrafficForwardingStaticIPMap{ "key": TrafficForwardingStaticIPArgs{...} }
type TrafficForwardingStaticIPMapInput interface {
	pulumi.Input

	ToTrafficForwardingStaticIPMapOutput() TrafficForwardingStaticIPMapOutput
	ToTrafficForwardingStaticIPMapOutputWithContext(context.Context) TrafficForwardingStaticIPMapOutput
}

type TrafficForwardingStaticIPMap map[string]TrafficForwardingStaticIPInput

func (TrafficForwardingStaticIPMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TrafficForwardingStaticIP)(nil)).Elem()
}

func (i TrafficForwardingStaticIPMap) ToTrafficForwardingStaticIPMapOutput() TrafficForwardingStaticIPMapOutput {
	return i.ToTrafficForwardingStaticIPMapOutputWithContext(context.Background())
}

func (i TrafficForwardingStaticIPMap) ToTrafficForwardingStaticIPMapOutputWithContext(ctx context.Context) TrafficForwardingStaticIPMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficForwardingStaticIPMapOutput)
}

type TrafficForwardingStaticIPOutput struct{ *pulumi.OutputState }

func (TrafficForwardingStaticIPOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TrafficForwardingStaticIP)(nil)).Elem()
}

func (o TrafficForwardingStaticIPOutput) ToTrafficForwardingStaticIPOutput() TrafficForwardingStaticIPOutput {
	return o
}

func (o TrafficForwardingStaticIPOutput) ToTrafficForwardingStaticIPOutputWithContext(ctx context.Context) TrafficForwardingStaticIPOutput {
	return o
}

// Additional information about this static IP address
func (o TrafficForwardingStaticIPOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
func (o TrafficForwardingStaticIPOutput) GeoOverride() pulumi.BoolOutput {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.BoolOutput { return v.GeoOverride }).(pulumi.BoolOutput)
}

// The static IP address
func (o TrafficForwardingStaticIPOutput) IpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.StringOutput { return v.IpAddress }).(pulumi.StringOutput)
}

// Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees. If not provided, the API will automatically determine it from the IP address.
func (o TrafficForwardingStaticIPOutput) Latitude() pulumi.Float64Output {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.Float64Output { return v.Latitude }).(pulumi.Float64Output)
}

// Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees. If not provided, the API will automatically determine it from the IP address.
func (o TrafficForwardingStaticIPOutput) Longitude() pulumi.Float64Output {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.Float64Output { return v.Longitude }).(pulumi.Float64Output)
}

// Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
func (o TrafficForwardingStaticIPOutput) RoutableIp() pulumi.BoolOutput {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.BoolOutput { return v.RoutableIp }).(pulumi.BoolOutput)
}

// The ID of the Static IP.
func (o TrafficForwardingStaticIPOutput) StaticIpId() pulumi.IntOutput {
	return o.ApplyT(func(v *TrafficForwardingStaticIP) pulumi.IntOutput { return v.StaticIpId }).(pulumi.IntOutput)
}

type TrafficForwardingStaticIPArrayOutput struct{ *pulumi.OutputState }

func (TrafficForwardingStaticIPArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TrafficForwardingStaticIP)(nil)).Elem()
}

func (o TrafficForwardingStaticIPArrayOutput) ToTrafficForwardingStaticIPArrayOutput() TrafficForwardingStaticIPArrayOutput {
	return o
}

func (o TrafficForwardingStaticIPArrayOutput) ToTrafficForwardingStaticIPArrayOutputWithContext(ctx context.Context) TrafficForwardingStaticIPArrayOutput {
	return o
}

func (o TrafficForwardingStaticIPArrayOutput) Index(i pulumi.IntInput) TrafficForwardingStaticIPOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TrafficForwardingStaticIP {
		return vs[0].([]*TrafficForwardingStaticIP)[vs[1].(int)]
	}).(TrafficForwardingStaticIPOutput)
}

type TrafficForwardingStaticIPMapOutput struct{ *pulumi.OutputState }

func (TrafficForwardingStaticIPMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TrafficForwardingStaticIP)(nil)).Elem()
}

func (o TrafficForwardingStaticIPMapOutput) ToTrafficForwardingStaticIPMapOutput() TrafficForwardingStaticIPMapOutput {
	return o
}

func (o TrafficForwardingStaticIPMapOutput) ToTrafficForwardingStaticIPMapOutputWithContext(ctx context.Context) TrafficForwardingStaticIPMapOutput {
	return o
}

func (o TrafficForwardingStaticIPMapOutput) MapIndex(k pulumi.StringInput) TrafficForwardingStaticIPOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TrafficForwardingStaticIP {
		return vs[0].(map[string]*TrafficForwardingStaticIP)[vs[1].(string)]
	}).(TrafficForwardingStaticIPOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TrafficForwardingStaticIPInput)(nil)).Elem(), &TrafficForwardingStaticIP{})
	pulumi.RegisterInputType(reflect.TypeOf((*TrafficForwardingStaticIPArrayInput)(nil)).Elem(), TrafficForwardingStaticIPArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TrafficForwardingStaticIPMapInput)(nil)).Elem(), TrafficForwardingStaticIPMap{})
	pulumi.RegisterOutputType(TrafficForwardingStaticIPOutput{})
	pulumi.RegisterOutputType(TrafficForwardingStaticIPArrayOutput{})
	pulumi.RegisterOutputType(TrafficForwardingStaticIPMapOutput{})
}

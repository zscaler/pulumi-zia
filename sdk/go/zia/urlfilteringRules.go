// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zia

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zia/sdk/go/zia/internal"
)

// The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.
//
// ## Example Usage
//
// ### ALLOW ACTION
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/zscaler/pulumi-zia/sdk/go/zia"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := zia.NewURLFilteringRules(ctx, "this", &zia.URLFilteringRulesArgs{
//				Action:      pulumi.String("ALLOW"),
//				Description: pulumi.String("Example"),
//				DeviceTrustLevels: pulumi.StringArray{
//					pulumi.String("UNKNOWN_DEVICETRUSTLEVEL"),
//					pulumi.String("LOW_TRUST"),
//					pulumi.String("MEDIUM_TRUST"),
//					pulumi.String("HIGH_TRUST"),
//				},
//				EnforceTimeValidity: pulumi.Bool(true),
//				Order:               pulumi.Int(1),
//				Protocols: pulumi.StringArray{
//					pulumi.String("ANY_RULE"),
//				},
//				RequestMethods: pulumi.StringArray{
//					pulumi.String("CONNECT"),
//					pulumi.String("DELETE"),
//					pulumi.String("GET"),
//					pulumi.String("HEAD"),
//					pulumi.String("OPTIONS"),
//					pulumi.String("OTHER"),
//					pulumi.String("POST"),
//					pulumi.String("PUT"),
//					pulumi.String("TRACE"),
//				},
//				SizeQuota: pulumi.Int(10),
//				State:     pulumi.String("ENABLED"),
//				TimeQuota: pulumi.Int(15),
//				UrlCategories: pulumi.StringArray{
//					pulumi.String("ANY"),
//				},
//				UserAgentTypes: pulumi.StringArray{
//					pulumi.String("OPERA"),
//					pulumi.String("FIREFOX"),
//					pulumi.String("MSIE"),
//					pulumi.String("MSEDGE"),
//					pulumi.String("CHROME"),
//					pulumi.String("SAFARI"),
//					pulumi.String("MSCHREDGE"),
//				},
//				ValidityEndTime:    pulumi.String("Tue, 17 Jun 2025 23:00:00 UTC"),
//				ValidityStartTime:  pulumi.String("Mon, 17 Jun 2024 23:30:00 UTC"),
//				ValidityTimeZoneId: pulumi.String("US/Pacific"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### BLOCK ACTION
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/zscaler/pulumi-zia/sdk/go/zia"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := zia.NewURLFilteringRules(ctx, "this", &zia.URLFilteringRulesArgs{
//				Action:        pulumi.String("BLOCK"),
//				BlockOverride: pulumi.Bool(true),
//				Description:   pulumi.String("Example"),
//				DeviceTrustLevels: pulumi.StringArray{
//					pulumi.String("UNKNOWN_DEVICETRUSTLEVEL"),
//					pulumi.String("LOW_TRUST"),
//					pulumi.String("MEDIUM_TRUST"),
//					pulumi.String("HIGH_TRUST"),
//				},
//				EnforceTimeValidity: pulumi.Bool(true),
//				Order:               pulumi.Int(1),
//				OverrideGroups: &zia.URLFilteringRulesOverrideGroupsArgs{
//					Ids: pulumi.IntArray{
//						pulumi.Int(76662385),
//					},
//				},
//				OverrideUsers: &zia.URLFilteringRulesOverrideUsersArgs{
//					Ids: pulumi.IntArray{
//						pulumi.Int(45513075),
//					},
//				},
//				Protocols: pulumi.StringArray{
//					pulumi.String("ANY_RULE"),
//				},
//				RequestMethods: pulumi.StringArray{
//					pulumi.String("CONNECT"),
//					pulumi.String("DELETE"),
//					pulumi.String("GET"),
//					pulumi.String("HEAD"),
//					pulumi.String("OPTIONS"),
//					pulumi.String("OTHER"),
//					pulumi.String("POST"),
//					pulumi.String("PUT"),
//					pulumi.String("TRACE"),
//				},
//				SizeQuota: pulumi.Int(10),
//				State:     pulumi.String("ENABLED"),
//				TimeQuota: pulumi.Int(15),
//				UrlCategories: pulumi.StringArray{
//					pulumi.String("ANY"),
//				},
//				UserAgentTypes: pulumi.StringArray{
//					pulumi.String("OPERA"),
//					pulumi.String("FIREFOX"),
//					pulumi.String("MSIE"),
//					pulumi.String("MSEDGE"),
//					pulumi.String("CHROME"),
//					pulumi.String("SAFARI"),
//					pulumi.String("MSCHREDGE"),
//				},
//				ValidityEndTime:    pulumi.String("Tue, 17 Jun 2025 23:00:00 UTC"),
//				ValidityStartTime:  pulumi.String("Mon, 17 Jun 2024 23:30:00 UTC"),
//				ValidityTimeZoneId: pulumi.String("US/Pacific"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### CAUTION ACTION
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/zscaler/pulumi-zia/sdk/go/zia"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := zia.NewURLFilteringRules(ctx, "this", &zia.URLFilteringRulesArgs{
//				Action:      pulumi.String("CAUTION"),
//				Description: pulumi.String("Example"),
//				DeviceTrustLevels: pulumi.StringArray{
//					pulumi.String("UNKNOWN_DEVICETRUSTLEVEL"),
//					pulumi.String("LOW_TRUST"),
//					pulumi.String("MEDIUM_TRUST"),
//					pulumi.String("HIGH_TRUST"),
//				},
//				EndUserNotificationUrl: pulumi.String("https://caution.acme.com"),
//				EnforceTimeValidity:    pulumi.Bool(true),
//				Order:                  pulumi.Int(1),
//				Protocols: pulumi.StringArray{
//					pulumi.String("ANY_RULE"),
//				},
//				RequestMethods: pulumi.StringArray{
//					pulumi.String("CONNECT"),
//					pulumi.String("DELETE"),
//					pulumi.String("GET"),
//					pulumi.String("HEAD"),
//					pulumi.String("OPTIONS"),
//					pulumi.String("OTHER"),
//					pulumi.String("POST"),
//					pulumi.String("PUT"),
//					pulumi.String("TRACE"),
//				},
//				SizeQuota: pulumi.Int(10),
//				State:     pulumi.String("ENABLED"),
//				TimeQuota: pulumi.Int(15),
//				UrlCategories: pulumi.StringArray{
//					pulumi.String("ANY"),
//				},
//				UserAgentTypes: pulumi.StringArray{
//					pulumi.String("OPERA"),
//					pulumi.String("FIREFOX"),
//					pulumi.String("MSIE"),
//					pulumi.String("MSEDGE"),
//					pulumi.String("CHROME"),
//					pulumi.String("SAFARI"),
//					pulumi.String("MSCHREDGE"),
//				},
//				ValidityEndTime:    pulumi.String("Tue, 17 Jun 2025 23:00:00 UTC"),
//				ValidityStartTime:  pulumi.String("Mon, 17 Jun 2024 23:30:00 UTC"),
//				ValidityTimeZoneId: pulumi.String("US/Pacific"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### ISOLATE ACTION
//
// ⚠️ **WARNING 1:**: Creating a URL Filtering rule with the action of `ISOLATE` requires the Cloud Browser Isolation subscription. To learn more, contact Zscaler Support or your local account team.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/zscaler/pulumi-zia/sdk/go/zia"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			thisCbiProfile, err := zia.GetCbiProfile(ctx, &zia.GetCbiProfileArgs{
//				Name: pulumi.StringRef("BD_SA_Profile1_ZIA"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = zia.NewURLFilteringRules(ctx, "thisURLFilteringRules", &zia.URLFilteringRulesArgs{
//				Description:         pulumi.String("Example"),
//				State:               pulumi.String("ENABLED"),
//				Action:              pulumi.String("ISOLATE"),
//				Order:               pulumi.Int(1),
//				EnforceTimeValidity: pulumi.Bool(true),
//				ValidityStartTime:   pulumi.String("Mon, 17 Jun 2024 23:30:00 UTC"),
//				ValidityEndTime:     pulumi.String("Tue, 17 Jun 2025 23:00:00 UTC"),
//				ValidityTimeZoneId:  pulumi.String("US/Pacific"),
//				TimeQuota:           pulumi.Int(15),
//				SizeQuota:           pulumi.Int(10),
//				UrlCategories: pulumi.StringArray{
//					pulumi.String("ANY"),
//				},
//				DeviceTrustLevels: pulumi.StringArray{
//					pulumi.String("UNKNOWN_DEVICETRUSTLEVEL"),
//					pulumi.String("LOW_TRUST"),
//					pulumi.String("MEDIUM_TRUST"),
//					pulumi.String("HIGH_TRUST"),
//				},
//				Protocols: pulumi.StringArray{
//					pulumi.String("HTTPS_RULE"),
//					pulumi.String("HTTP_RULE"),
//				},
//				RequestMethods: pulumi.StringArray{
//					pulumi.String("CONNECT"),
//					pulumi.String("DELETE"),
//					pulumi.String("GET"),
//					pulumi.String("HEAD"),
//					pulumi.String("OPTIONS"),
//					pulumi.String("OTHER"),
//					pulumi.String("POST"),
//					pulumi.String("PUT"),
//					pulumi.String("TRACE"),
//				},
//				CbiProfiles: zia.URLFilteringRulesCbiProfileArray{
//					&zia.URLFilteringRulesCbiProfileArgs{
//						Id:   pulumi.String(thisCbiProfile.Id),
//						Name: pulumi.String(thisCbiProfile.Name),
//						Url:  pulumi.String(thisCbiProfile.Url),
//					},
//				},
//				UserAgentTypes: pulumi.StringArray{
//					pulumi.String("OPERA"),
//					pulumi.String("FIREFOX"),
//					pulumi.String("MSIE"),
//					pulumi.String("MSEDGE"),
//					pulumi.String("CHROME"),
//					pulumi.String("SAFARI"),
//					pulumi.String("MSCHREDGE"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
//
// # Visit
//
// **zia_url_filtering_rules** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.
//
// For example:
//
// ```sh
// $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_id>
// ```
//
// or
//
// ```sh
// $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_name>
// ```
type URLFilteringRules struct {
	pulumi.CustomResourceState

	// Action taken when traffic matches rule criteria
	Action        pulumi.StringPtrOutput                 `pulumi:"action"`
	BlockOverride pulumi.BoolPtrOutput                   `pulumi:"blockOverride"`
	CbiProfiles   URLFilteringRulesCbiProfileArrayOutput `pulumi:"cbiProfiles"`
	// If set to true, the CIPA Compliance rule is enabled
	Ciparule pulumi.BoolPtrOutput `pulumi:"ciparule"`
	// Name-ID pairs of departments for which rule must be applied
	Departments URLFilteringRulesDepartmentsOutput `pulumi:"departments"`
	// Additional information about the URL Filtering rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups URLFilteringRulesDeviceGroupsOutput `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayOutput `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices URLFilteringRulesDevicesOutput `pulumi:"devices"`
	// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
	// 'overrideGroups' is specified.
	EndUserNotificationUrl pulumi.StringPtrOutput `pulumi:"endUserNotificationUrl"`
	// Enforce a set a validity time period for the URL Filtering rule.
	EnforceTimeValidity pulumi.BoolPtrOutput `pulumi:"enforceTimeValidity"`
	// Name-ID pairs of groups for which rule must be applied
	Groups URLFilteringRulesGroupsOutput `pulumi:"groups"`
	// The URL Filtering rule's label.
	Labels URLFilteringRulesLabelsOutput `pulumi:"labels"`
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups URLFilteringRulesLocationGroupsOutput `pulumi:"locationGroups"`
	// Name-ID pairs of locations for which rule must be applied
	Locations URLFilteringRulesLocationsOutput `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringOutput `pulumi:"name"`
	// Order of execution of rule with respect to other URL Filtering rules
	Order pulumi.IntOutput `pulumi:"order"`
	// Name-ID pairs of groups for which this rule can be overridden.
	OverrideGroups URLFilteringRulesOverrideGroupsOutput `pulumi:"overrideGroups"`
	// Name-ID pairs of users for which this rule can be overridden.
	OverrideUsers URLFilteringRulesOverrideUsersOutput `pulumi:"overrideUsers"`
	// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
	Protocols pulumi.StringArrayOutput `pulumi:"protocols"`
	// Admin rank of the Firewall Filtering policy rule
	Rank pulumi.IntPtrOutput `pulumi:"rank"`
	// Request method for which the rule must be applied. If not set, rule will be applied to all methods
	RequestMethods pulumi.StringArrayOutput `pulumi:"requestMethods"`
	// URL Filtering Rule ID
	RuleId pulumi.IntOutput `pulumi:"ruleId"`
	// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	SizeQuota pulumi.IntPtrOutput `pulumi:"sizeQuota"`
	// list of source ip groups
	SourceIpGroups URLFilteringRulesSourceIpGroupsOutput `pulumi:"sourceIpGroups"`
	State          pulumi.StringPtrOutput                `pulumi:"state"`
	// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	TimeQuota pulumi.IntPtrOutput `pulumi:"timeQuota"`
	// Name-ID pairs of time interval during which rule must be enforced.
	TimeWindows URLFilteringRulesTimeWindowsOutput `pulumi:"timeWindows"`
	// List of URL categories for which rule must be applied
	UrlCategories pulumi.StringArrayOutput `pulumi:"urlCategories"`
	// Supported User Agent Types
	UserAgentTypes      pulumi.StringArrayOutput `pulumi:"userAgentTypes"`
	UserRiskScoreLevels pulumi.StringArrayOutput `pulumi:"userRiskScoreLevels"`
	// Name-ID pairs of users for which rule must be applied
	Users URLFilteringRulesUsersOutput `pulumi:"users"`
	// If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
	ValidityEndTime pulumi.StringPtrOutput `pulumi:"validityEndTime"`
	// If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
	ValidityStartTime pulumi.StringPtrOutput `pulumi:"validityStartTime"`
	// If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
	// IANA Format TimeZone.
	ValidityTimeZoneId pulumi.StringPtrOutput `pulumi:"validityTimeZoneId"`
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups URLFilteringRulesWorkloadGroupArrayOutput `pulumi:"workloadGroups"`
}

// NewURLFilteringRules registers a new resource with the given unique name, arguments, and options.
func NewURLFilteringRules(ctx *pulumi.Context,
	name string, args *URLFilteringRulesArgs, opts ...pulumi.ResourceOption) (*URLFilteringRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Protocols == nil {
		return nil, errors.New("invalid value for required argument 'Protocols'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource URLFilteringRules
	err := ctx.RegisterResource("zia:index/uRLFilteringRules:URLFilteringRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetURLFilteringRules gets an existing URLFilteringRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetURLFilteringRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *URLFilteringRulesState, opts ...pulumi.ResourceOption) (*URLFilteringRules, error) {
	var resource URLFilteringRules
	err := ctx.ReadResource("zia:index/uRLFilteringRules:URLFilteringRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering URLFilteringRules resources.
type urlfilteringRulesState struct {
	// Action taken when traffic matches rule criteria
	Action        *string                       `pulumi:"action"`
	BlockOverride *bool                         `pulumi:"blockOverride"`
	CbiProfiles   []URLFilteringRulesCbiProfile `pulumi:"cbiProfiles"`
	// If set to true, the CIPA Compliance rule is enabled
	Ciparule *bool `pulumi:"ciparule"`
	// Name-ID pairs of departments for which rule must be applied
	Departments *URLFilteringRulesDepartments `pulumi:"departments"`
	// Additional information about the URL Filtering rule
	Description *string `pulumi:"description"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *URLFilteringRulesDeviceGroups `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels []string `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *URLFilteringRulesDevices `pulumi:"devices"`
	// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
	// 'overrideGroups' is specified.
	EndUserNotificationUrl *string `pulumi:"endUserNotificationUrl"`
	// Enforce a set a validity time period for the URL Filtering rule.
	EnforceTimeValidity *bool `pulumi:"enforceTimeValidity"`
	// Name-ID pairs of groups for which rule must be applied
	Groups *URLFilteringRulesGroups `pulumi:"groups"`
	// The URL Filtering rule's label.
	Labels *URLFilteringRulesLabels `pulumi:"labels"`
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups *URLFilteringRulesLocationGroups `pulumi:"locationGroups"`
	// Name-ID pairs of locations for which rule must be applied
	Locations *URLFilteringRulesLocations `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
	// Order of execution of rule with respect to other URL Filtering rules
	Order *int `pulumi:"order"`
	// Name-ID pairs of groups for which this rule can be overridden.
	OverrideGroups *URLFilteringRulesOverrideGroups `pulumi:"overrideGroups"`
	// Name-ID pairs of users for which this rule can be overridden.
	OverrideUsers *URLFilteringRulesOverrideUsers `pulumi:"overrideUsers"`
	// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
	Protocols []string `pulumi:"protocols"`
	// Admin rank of the Firewall Filtering policy rule
	Rank *int `pulumi:"rank"`
	// Request method for which the rule must be applied. If not set, rule will be applied to all methods
	RequestMethods []string `pulumi:"requestMethods"`
	// URL Filtering Rule ID
	RuleId *int `pulumi:"ruleId"`
	// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	SizeQuota *int `pulumi:"sizeQuota"`
	// list of source ip groups
	SourceIpGroups *URLFilteringRulesSourceIpGroups `pulumi:"sourceIpGroups"`
	State          *string                          `pulumi:"state"`
	// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	TimeQuota *int `pulumi:"timeQuota"`
	// Name-ID pairs of time interval during which rule must be enforced.
	TimeWindows *URLFilteringRulesTimeWindows `pulumi:"timeWindows"`
	// List of URL categories for which rule must be applied
	UrlCategories []string `pulumi:"urlCategories"`
	// Supported User Agent Types
	UserAgentTypes      []string `pulumi:"userAgentTypes"`
	UserRiskScoreLevels []string `pulumi:"userRiskScoreLevels"`
	// Name-ID pairs of users for which rule must be applied
	Users *URLFilteringRulesUsers `pulumi:"users"`
	// If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
	ValidityEndTime *string `pulumi:"validityEndTime"`
	// If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
	ValidityStartTime *string `pulumi:"validityStartTime"`
	// If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
	// IANA Format TimeZone.
	ValidityTimeZoneId *string `pulumi:"validityTimeZoneId"`
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups []URLFilteringRulesWorkloadGroup `pulumi:"workloadGroups"`
}

type URLFilteringRulesState struct {
	// Action taken when traffic matches rule criteria
	Action        pulumi.StringPtrInput
	BlockOverride pulumi.BoolPtrInput
	CbiProfiles   URLFilteringRulesCbiProfileArrayInput
	// If set to true, the CIPA Compliance rule is enabled
	Ciparule pulumi.BoolPtrInput
	// Name-ID pairs of departments for which rule must be applied
	Departments URLFilteringRulesDepartmentsPtrInput
	// Additional information about the URL Filtering rule
	Description pulumi.StringPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups URLFilteringRulesDeviceGroupsPtrInput
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices URLFilteringRulesDevicesPtrInput
	// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
	// 'overrideGroups' is specified.
	EndUserNotificationUrl pulumi.StringPtrInput
	// Enforce a set a validity time period for the URL Filtering rule.
	EnforceTimeValidity pulumi.BoolPtrInput
	// Name-ID pairs of groups for which rule must be applied
	Groups URLFilteringRulesGroupsPtrInput
	// The URL Filtering rule's label.
	Labels URLFilteringRulesLabelsPtrInput
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups URLFilteringRulesLocationGroupsPtrInput
	// Name-ID pairs of locations for which rule must be applied
	Locations URLFilteringRulesLocationsPtrInput
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput
	// Order of execution of rule with respect to other URL Filtering rules
	Order pulumi.IntPtrInput
	// Name-ID pairs of groups for which this rule can be overridden.
	OverrideGroups URLFilteringRulesOverrideGroupsPtrInput
	// Name-ID pairs of users for which this rule can be overridden.
	OverrideUsers URLFilteringRulesOverrideUsersPtrInput
	// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
	Protocols pulumi.StringArrayInput
	// Admin rank of the Firewall Filtering policy rule
	Rank pulumi.IntPtrInput
	// Request method for which the rule must be applied. If not set, rule will be applied to all methods
	RequestMethods pulumi.StringArrayInput
	// URL Filtering Rule ID
	RuleId pulumi.IntPtrInput
	// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	SizeQuota pulumi.IntPtrInput
	// list of source ip groups
	SourceIpGroups URLFilteringRulesSourceIpGroupsPtrInput
	State          pulumi.StringPtrInput
	// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	TimeQuota pulumi.IntPtrInput
	// Name-ID pairs of time interval during which rule must be enforced.
	TimeWindows URLFilteringRulesTimeWindowsPtrInput
	// List of URL categories for which rule must be applied
	UrlCategories pulumi.StringArrayInput
	// Supported User Agent Types
	UserAgentTypes      pulumi.StringArrayInput
	UserRiskScoreLevels pulumi.StringArrayInput
	// Name-ID pairs of users for which rule must be applied
	Users URLFilteringRulesUsersPtrInput
	// If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
	ValidityEndTime pulumi.StringPtrInput
	// If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
	ValidityStartTime pulumi.StringPtrInput
	// If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
	// IANA Format TimeZone.
	ValidityTimeZoneId pulumi.StringPtrInput
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups URLFilteringRulesWorkloadGroupArrayInput
}

func (URLFilteringRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*urlfilteringRulesState)(nil)).Elem()
}

type urlfilteringRulesArgs struct {
	// Action taken when traffic matches rule criteria
	Action        *string                       `pulumi:"action"`
	BlockOverride *bool                         `pulumi:"blockOverride"`
	CbiProfiles   []URLFilteringRulesCbiProfile `pulumi:"cbiProfiles"`
	// If set to true, the CIPA Compliance rule is enabled
	Ciparule *bool `pulumi:"ciparule"`
	// Name-ID pairs of departments for which rule must be applied
	Departments *URLFilteringRulesDepartments `pulumi:"departments"`
	// Additional information about the URL Filtering rule
	Description *string `pulumi:"description"`
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups *URLFilteringRulesDeviceGroups `pulumi:"deviceGroups"`
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels []string `pulumi:"deviceTrustLevels"`
	// Name-ID pairs of devices for which rule must be applied.
	Devices *URLFilteringRulesDevices `pulumi:"devices"`
	// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
	// 'overrideGroups' is specified.
	EndUserNotificationUrl *string `pulumi:"endUserNotificationUrl"`
	// Enforce a set a validity time period for the URL Filtering rule.
	EnforceTimeValidity *bool `pulumi:"enforceTimeValidity"`
	// Name-ID pairs of groups for which rule must be applied
	Groups *URLFilteringRulesGroups `pulumi:"groups"`
	// The URL Filtering rule's label.
	Labels *URLFilteringRulesLabels `pulumi:"labels"`
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups *URLFilteringRulesLocationGroups `pulumi:"locationGroups"`
	// Name-ID pairs of locations for which rule must be applied
	Locations *URLFilteringRulesLocations `pulumi:"locations"`
	// Name of the Firewall Filtering policy rule
	Name *string `pulumi:"name"`
	// Order of execution of rule with respect to other URL Filtering rules
	Order *int `pulumi:"order"`
	// Name-ID pairs of groups for which this rule can be overridden.
	OverrideGroups *URLFilteringRulesOverrideGroups `pulumi:"overrideGroups"`
	// Name-ID pairs of users for which this rule can be overridden.
	OverrideUsers *URLFilteringRulesOverrideUsers `pulumi:"overrideUsers"`
	// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
	Protocols []string `pulumi:"protocols"`
	// Admin rank of the Firewall Filtering policy rule
	Rank *int `pulumi:"rank"`
	// Request method for which the rule must be applied. If not set, rule will be applied to all methods
	RequestMethods []string `pulumi:"requestMethods"`
	// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	SizeQuota *int `pulumi:"sizeQuota"`
	// list of source ip groups
	SourceIpGroups *URLFilteringRulesSourceIpGroups `pulumi:"sourceIpGroups"`
	State          *string                          `pulumi:"state"`
	// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	TimeQuota *int `pulumi:"timeQuota"`
	// Name-ID pairs of time interval during which rule must be enforced.
	TimeWindows *URLFilteringRulesTimeWindows `pulumi:"timeWindows"`
	// List of URL categories for which rule must be applied
	UrlCategories []string `pulumi:"urlCategories"`
	// Supported User Agent Types
	UserAgentTypes      []string `pulumi:"userAgentTypes"`
	UserRiskScoreLevels []string `pulumi:"userRiskScoreLevels"`
	// Name-ID pairs of users for which rule must be applied
	Users *URLFilteringRulesUsers `pulumi:"users"`
	// If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
	ValidityEndTime *string `pulumi:"validityEndTime"`
	// If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
	ValidityStartTime *string `pulumi:"validityStartTime"`
	// If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
	// IANA Format TimeZone.
	ValidityTimeZoneId *string `pulumi:"validityTimeZoneId"`
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups []URLFilteringRulesWorkloadGroup `pulumi:"workloadGroups"`
}

// The set of arguments for constructing a URLFilteringRules resource.
type URLFilteringRulesArgs struct {
	// Action taken when traffic matches rule criteria
	Action        pulumi.StringPtrInput
	BlockOverride pulumi.BoolPtrInput
	CbiProfiles   URLFilteringRulesCbiProfileArrayInput
	// If set to true, the CIPA Compliance rule is enabled
	Ciparule pulumi.BoolPtrInput
	// Name-ID pairs of departments for which rule must be applied
	Departments URLFilteringRulesDepartmentsPtrInput
	// Additional information about the URL Filtering rule
	Description pulumi.StringPtrInput
	// This field is applicable for devices that are managed using Zscaler Client Connector.
	DeviceGroups URLFilteringRulesDeviceGroupsPtrInput
	// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
	// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
	// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
	DeviceTrustLevels pulumi.StringArrayInput
	// Name-ID pairs of devices for which rule must be applied.
	Devices URLFilteringRulesDevicesPtrInput
	// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
	// 'overrideGroups' is specified.
	EndUserNotificationUrl pulumi.StringPtrInput
	// Enforce a set a validity time period for the URL Filtering rule.
	EnforceTimeValidity pulumi.BoolPtrInput
	// Name-ID pairs of groups for which rule must be applied
	Groups URLFilteringRulesGroupsPtrInput
	// The URL Filtering rule's label.
	Labels URLFilteringRulesLabelsPtrInput
	// Name-ID pairs of the location groups to which the rule must be applied.
	LocationGroups URLFilteringRulesLocationGroupsPtrInput
	// Name-ID pairs of locations for which rule must be applied
	Locations URLFilteringRulesLocationsPtrInput
	// Name of the Firewall Filtering policy rule
	Name pulumi.StringPtrInput
	// Order of execution of rule with respect to other URL Filtering rules
	Order pulumi.IntPtrInput
	// Name-ID pairs of groups for which this rule can be overridden.
	OverrideGroups URLFilteringRulesOverrideGroupsPtrInput
	// Name-ID pairs of users for which this rule can be overridden.
	OverrideUsers URLFilteringRulesOverrideUsersPtrInput
	// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
	Protocols pulumi.StringArrayInput
	// Admin rank of the Firewall Filtering policy rule
	Rank pulumi.IntPtrInput
	// Request method for which the rule must be applied. If not set, rule will be applied to all methods
	RequestMethods pulumi.StringArrayInput
	// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	SizeQuota pulumi.IntPtrInput
	// list of source ip groups
	SourceIpGroups URLFilteringRulesSourceIpGroupsPtrInput
	State          pulumi.StringPtrInput
	// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
	// action is set to 'BLOCK', this field is not applicable.
	TimeQuota pulumi.IntPtrInput
	// Name-ID pairs of time interval during which rule must be enforced.
	TimeWindows URLFilteringRulesTimeWindowsPtrInput
	// List of URL categories for which rule must be applied
	UrlCategories pulumi.StringArrayInput
	// Supported User Agent Types
	UserAgentTypes      pulumi.StringArrayInput
	UserRiskScoreLevels pulumi.StringArrayInput
	// Name-ID pairs of users for which rule must be applied
	Users URLFilteringRulesUsersPtrInput
	// If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
	ValidityEndTime pulumi.StringPtrInput
	// If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
	ValidityStartTime pulumi.StringPtrInput
	// If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
	// IANA Format TimeZone.
	ValidityTimeZoneId pulumi.StringPtrInput
	// The list of preconfigured workload groups to which the policy must be applied
	WorkloadGroups URLFilteringRulesWorkloadGroupArrayInput
}

func (URLFilteringRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*urlfilteringRulesArgs)(nil)).Elem()
}

type URLFilteringRulesInput interface {
	pulumi.Input

	ToURLFilteringRulesOutput() URLFilteringRulesOutput
	ToURLFilteringRulesOutputWithContext(ctx context.Context) URLFilteringRulesOutput
}

func (*URLFilteringRules) ElementType() reflect.Type {
	return reflect.TypeOf((**URLFilteringRules)(nil)).Elem()
}

func (i *URLFilteringRules) ToURLFilteringRulesOutput() URLFilteringRulesOutput {
	return i.ToURLFilteringRulesOutputWithContext(context.Background())
}

func (i *URLFilteringRules) ToURLFilteringRulesOutputWithContext(ctx context.Context) URLFilteringRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(URLFilteringRulesOutput)
}

// URLFilteringRulesArrayInput is an input type that accepts URLFilteringRulesArray and URLFilteringRulesArrayOutput values.
// You can construct a concrete instance of `URLFilteringRulesArrayInput` via:
//
//	URLFilteringRulesArray{ URLFilteringRulesArgs{...} }
type URLFilteringRulesArrayInput interface {
	pulumi.Input

	ToURLFilteringRulesArrayOutput() URLFilteringRulesArrayOutput
	ToURLFilteringRulesArrayOutputWithContext(context.Context) URLFilteringRulesArrayOutput
}

type URLFilteringRulesArray []URLFilteringRulesInput

func (URLFilteringRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*URLFilteringRules)(nil)).Elem()
}

func (i URLFilteringRulesArray) ToURLFilteringRulesArrayOutput() URLFilteringRulesArrayOutput {
	return i.ToURLFilteringRulesArrayOutputWithContext(context.Background())
}

func (i URLFilteringRulesArray) ToURLFilteringRulesArrayOutputWithContext(ctx context.Context) URLFilteringRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(URLFilteringRulesArrayOutput)
}

// URLFilteringRulesMapInput is an input type that accepts URLFilteringRulesMap and URLFilteringRulesMapOutput values.
// You can construct a concrete instance of `URLFilteringRulesMapInput` via:
//
//	URLFilteringRulesMap{ "key": URLFilteringRulesArgs{...} }
type URLFilteringRulesMapInput interface {
	pulumi.Input

	ToURLFilteringRulesMapOutput() URLFilteringRulesMapOutput
	ToURLFilteringRulesMapOutputWithContext(context.Context) URLFilteringRulesMapOutput
}

type URLFilteringRulesMap map[string]URLFilteringRulesInput

func (URLFilteringRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*URLFilteringRules)(nil)).Elem()
}

func (i URLFilteringRulesMap) ToURLFilteringRulesMapOutput() URLFilteringRulesMapOutput {
	return i.ToURLFilteringRulesMapOutputWithContext(context.Background())
}

func (i URLFilteringRulesMap) ToURLFilteringRulesMapOutputWithContext(ctx context.Context) URLFilteringRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(URLFilteringRulesMapOutput)
}

type URLFilteringRulesOutput struct{ *pulumi.OutputState }

func (URLFilteringRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**URLFilteringRules)(nil)).Elem()
}

func (o URLFilteringRulesOutput) ToURLFilteringRulesOutput() URLFilteringRulesOutput {
	return o
}

func (o URLFilteringRulesOutput) ToURLFilteringRulesOutputWithContext(ctx context.Context) URLFilteringRulesOutput {
	return o
}

// Action taken when traffic matches rule criteria
func (o URLFilteringRulesOutput) Action() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.Action }).(pulumi.StringPtrOutput)
}

func (o URLFilteringRulesOutput) BlockOverride() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.BoolPtrOutput { return v.BlockOverride }).(pulumi.BoolPtrOutput)
}

func (o URLFilteringRulesOutput) CbiProfiles() URLFilteringRulesCbiProfileArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesCbiProfileArrayOutput { return v.CbiProfiles }).(URLFilteringRulesCbiProfileArrayOutput)
}

// If set to true, the CIPA Compliance rule is enabled
func (o URLFilteringRulesOutput) Ciparule() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.BoolPtrOutput { return v.Ciparule }).(pulumi.BoolPtrOutput)
}

// Name-ID pairs of departments for which rule must be applied
func (o URLFilteringRulesOutput) Departments() URLFilteringRulesDepartmentsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesDepartmentsOutput { return v.Departments }).(URLFilteringRulesDepartmentsOutput)
}

// Additional information about the URL Filtering rule
func (o URLFilteringRulesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// This field is applicable for devices that are managed using Zscaler Client Connector.
func (o URLFilteringRulesOutput) DeviceGroups() URLFilteringRulesDeviceGroupsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesDeviceGroupsOutput { return v.DeviceGroups }).(URLFilteringRulesDeviceGroupsOutput)
}

// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
func (o URLFilteringRulesOutput) DeviceTrustLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringArrayOutput { return v.DeviceTrustLevels }).(pulumi.StringArrayOutput)
}

// Name-ID pairs of devices for which rule must be applied.
func (o URLFilteringRulesOutput) Devices() URLFilteringRulesDevicesOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesDevicesOutput { return v.Devices }).(URLFilteringRulesDevicesOutput)
}

// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
// 'overrideGroups' is specified.
func (o URLFilteringRulesOutput) EndUserNotificationUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.EndUserNotificationUrl }).(pulumi.StringPtrOutput)
}

// Enforce a set a validity time period for the URL Filtering rule.
func (o URLFilteringRulesOutput) EnforceTimeValidity() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.BoolPtrOutput { return v.EnforceTimeValidity }).(pulumi.BoolPtrOutput)
}

// Name-ID pairs of groups for which rule must be applied
func (o URLFilteringRulesOutput) Groups() URLFilteringRulesGroupsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesGroupsOutput { return v.Groups }).(URLFilteringRulesGroupsOutput)
}

// The URL Filtering rule's label.
func (o URLFilteringRulesOutput) Labels() URLFilteringRulesLabelsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesLabelsOutput { return v.Labels }).(URLFilteringRulesLabelsOutput)
}

// Name-ID pairs of the location groups to which the rule must be applied.
func (o URLFilteringRulesOutput) LocationGroups() URLFilteringRulesLocationGroupsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesLocationGroupsOutput { return v.LocationGroups }).(URLFilteringRulesLocationGroupsOutput)
}

// Name-ID pairs of locations for which rule must be applied
func (o URLFilteringRulesOutput) Locations() URLFilteringRulesLocationsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesLocationsOutput { return v.Locations }).(URLFilteringRulesLocationsOutput)
}

// Name of the Firewall Filtering policy rule
func (o URLFilteringRulesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Order of execution of rule with respect to other URL Filtering rules
func (o URLFilteringRulesOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// Name-ID pairs of groups for which this rule can be overridden.
func (o URLFilteringRulesOutput) OverrideGroups() URLFilteringRulesOverrideGroupsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesOverrideGroupsOutput { return v.OverrideGroups }).(URLFilteringRulesOverrideGroupsOutput)
}

// Name-ID pairs of users for which this rule can be overridden.
func (o URLFilteringRulesOutput) OverrideUsers() URLFilteringRulesOverrideUsersOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesOverrideUsersOutput { return v.OverrideUsers }).(URLFilteringRulesOverrideUsersOutput)
}

// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
func (o URLFilteringRulesOutput) Protocols() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringArrayOutput { return v.Protocols }).(pulumi.StringArrayOutput)
}

// Admin rank of the Firewall Filtering policy rule
func (o URLFilteringRulesOutput) Rank() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.IntPtrOutput { return v.Rank }).(pulumi.IntPtrOutput)
}

// Request method for which the rule must be applied. If not set, rule will be applied to all methods
func (o URLFilteringRulesOutput) RequestMethods() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringArrayOutput { return v.RequestMethods }).(pulumi.StringArrayOutput)
}

// URL Filtering Rule ID
func (o URLFilteringRulesOutput) RuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.IntOutput { return v.RuleId }).(pulumi.IntOutput)
}

// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
// action is set to 'BLOCK', this field is not applicable.
func (o URLFilteringRulesOutput) SizeQuota() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.IntPtrOutput { return v.SizeQuota }).(pulumi.IntPtrOutput)
}

// list of source ip groups
func (o URLFilteringRulesOutput) SourceIpGroups() URLFilteringRulesSourceIpGroupsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesSourceIpGroupsOutput { return v.SourceIpGroups }).(URLFilteringRulesSourceIpGroupsOutput)
}

func (o URLFilteringRulesOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.State }).(pulumi.StringPtrOutput)
}

// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
// action is set to 'BLOCK', this field is not applicable.
func (o URLFilteringRulesOutput) TimeQuota() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.IntPtrOutput { return v.TimeQuota }).(pulumi.IntPtrOutput)
}

// Name-ID pairs of time interval during which rule must be enforced.
func (o URLFilteringRulesOutput) TimeWindows() URLFilteringRulesTimeWindowsOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesTimeWindowsOutput { return v.TimeWindows }).(URLFilteringRulesTimeWindowsOutput)
}

// List of URL categories for which rule must be applied
func (o URLFilteringRulesOutput) UrlCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringArrayOutput { return v.UrlCategories }).(pulumi.StringArrayOutput)
}

// Supported User Agent Types
func (o URLFilteringRulesOutput) UserAgentTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringArrayOutput { return v.UserAgentTypes }).(pulumi.StringArrayOutput)
}

func (o URLFilteringRulesOutput) UserRiskScoreLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringArrayOutput { return v.UserRiskScoreLevels }).(pulumi.StringArrayOutput)
}

// Name-ID pairs of users for which rule must be applied
func (o URLFilteringRulesOutput) Users() URLFilteringRulesUsersOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesUsersOutput { return v.Users }).(URLFilteringRulesUsersOutput)
}

// If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
func (o URLFilteringRulesOutput) ValidityEndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.ValidityEndTime }).(pulumi.StringPtrOutput)
}

// If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
func (o URLFilteringRulesOutput) ValidityStartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.ValidityStartTime }).(pulumi.StringPtrOutput)
}

// If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
// IANA Format TimeZone.
func (o URLFilteringRulesOutput) ValidityTimeZoneId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *URLFilteringRules) pulumi.StringPtrOutput { return v.ValidityTimeZoneId }).(pulumi.StringPtrOutput)
}

// The list of preconfigured workload groups to which the policy must be applied
func (o URLFilteringRulesOutput) WorkloadGroups() URLFilteringRulesWorkloadGroupArrayOutput {
	return o.ApplyT(func(v *URLFilteringRules) URLFilteringRulesWorkloadGroupArrayOutput { return v.WorkloadGroups }).(URLFilteringRulesWorkloadGroupArrayOutput)
}

type URLFilteringRulesArrayOutput struct{ *pulumi.OutputState }

func (URLFilteringRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*URLFilteringRules)(nil)).Elem()
}

func (o URLFilteringRulesArrayOutput) ToURLFilteringRulesArrayOutput() URLFilteringRulesArrayOutput {
	return o
}

func (o URLFilteringRulesArrayOutput) ToURLFilteringRulesArrayOutputWithContext(ctx context.Context) URLFilteringRulesArrayOutput {
	return o
}

func (o URLFilteringRulesArrayOutput) Index(i pulumi.IntInput) URLFilteringRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *URLFilteringRules {
		return vs[0].([]*URLFilteringRules)[vs[1].(int)]
	}).(URLFilteringRulesOutput)
}

type URLFilteringRulesMapOutput struct{ *pulumi.OutputState }

func (URLFilteringRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*URLFilteringRules)(nil)).Elem()
}

func (o URLFilteringRulesMapOutput) ToURLFilteringRulesMapOutput() URLFilteringRulesMapOutput {
	return o
}

func (o URLFilteringRulesMapOutput) ToURLFilteringRulesMapOutputWithContext(ctx context.Context) URLFilteringRulesMapOutput {
	return o
}

func (o URLFilteringRulesMapOutput) MapIndex(k pulumi.StringInput) URLFilteringRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *URLFilteringRules {
		return vs[0].(map[string]*URLFilteringRules)[vs[1].(string)]
	}).(URLFilteringRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*URLFilteringRulesInput)(nil)).Elem(), &URLFilteringRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*URLFilteringRulesArrayInput)(nil)).Elem(), URLFilteringRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*URLFilteringRulesMapInput)(nil)).Elem(), URLFilteringRulesMap{})
	pulumi.RegisterOutputType(URLFilteringRulesOutput{})
	pulumi.RegisterOutputType(URLFilteringRulesArrayOutput{})
	pulumi.RegisterOutputType(URLFilteringRulesMapOutput{})
}

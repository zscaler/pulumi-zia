// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace zscaler.PulumiPackage.Zia
{
    /// <summary>
    /// The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.
    /// 
    /// ## Example Usage
    /// 
    /// ### BLOCK ACTION
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Zia = zscaler.PulumiPackage.Zia;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Zia.URLFilteringRules("this", new()
    ///     {
    ///         Action = "BLOCK",
    ///         Description = "Example",
    ///         DeviceTrustLevels = new[]
    ///         {
    ///             "UNKNOWN_DEVICETRUSTLEVEL",
    ///             "LOW_TRUST",
    ///             "MEDIUM_TRUST",
    ///             "HIGH_TRUST",
    ///         },
    ///         Order = 1,
    ///         Protocols = new[]
    ///         {
    ///             "ANY_RULE",
    ///         },
    ///         RequestMethods = new[]
    ///         {
    ///             "CONNECT",
    ///             "DELETE",
    ///             "GET",
    ///             "HEAD",
    ///             "OPTIONS",
    ///             "OTHER",
    ///             "POST",
    ///             "PUT",
    ///             "TRACE",
    ///         },
    ///         State = "ENABLED",
    ///         UrlCategories = new[]
    ///         {
    ///             "ANY",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ### ISOLATE ACTION
    /// 
    /// ⚠️ **WARNING 1:**: Creating a URL Filtering rule with the action of `ISOLATE` requires the Cloud Browser Isolation subscription. To learn more, contact Zscaler Support or your local account team.
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Zia = Pulumi.Zia;
    /// using Zia = zscaler.PulumiPackage.Zia;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var thisCbiProfile = Zia.GetCbiProfile.Invoke(new()
    ///     {
    ///         Name = "BD_SA_Profile1_ZIA",
    ///     });
    /// 
    ///     var thisURLFilteringRules = new Zia.URLFilteringRules("thisURLFilteringRules", new()
    ///     {
    ///         Description = "Example",
    ///         State = "ENABLED",
    ///         Action = "ISOLATE",
    ///         Order = 1,
    ///         UrlCategories = new[]
    ///         {
    ///             "ANY",
    ///         },
    ///         DeviceTrustLevels = new[]
    ///         {
    ///             "UNKNOWN_DEVICETRUSTLEVEL",
    ///             "LOW_TRUST",
    ///             "MEDIUM_TRUST",
    ///             "HIGH_TRUST",
    ///         },
    ///         Protocols = new[]
    ///         {
    ///             "HTTPS_RULE",
    ///             "HTTP_RULE",
    ///         },
    ///         RequestMethods = new[]
    ///         {
    ///             "CONNECT",
    ///             "DELETE",
    ///             "GET",
    ///             "HEAD",
    ///             "OPTIONS",
    ///             "OTHER",
    ///             "POST",
    ///             "PUT",
    ///             "TRACE",
    ///         },
    ///         CbiProfiles = new[]
    ///         {
    ///             new Zia.Inputs.URLFilteringRulesCbiProfileArgs
    ///             {
    ///                 Id = thisCbiProfile.Apply(getCbiProfileResult =&gt; getCbiProfileResult.Id),
    ///                 Name = thisCbiProfile.Apply(getCbiProfileResult =&gt; getCbiProfileResult.Name),
    ///                 Url = thisCbiProfile.Apply(getCbiProfileResult =&gt; getCbiProfileResult.Url),
    ///             },
    ///         },
    ///         UserAgentTypes = new[]
    ///         {
    ///             "OPERA",
    ///             "FIREFOX",
    ///             "MSIE",
    ///             "MSEDGE",
    ///             "CHROME",
    ///             "SAFARI",
    ///             "MSCHREDGE",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// 
    /// Visit
    /// 
    /// **zia_url_filtering_rules** can be imported by using `&lt;RULE_ID&gt;` or `&lt;RULE_NAME&gt;` as the import ID.
    /// 
    /// For example:
    /// 
    /// ```sh
    /// $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example &lt;rule_id&gt;
    /// ```
    /// 
    /// or
    /// 
    /// ```sh
    /// $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example &lt;rule_name&gt;
    /// ```
    /// </summary>
    [ZiaResourceType("zia:index/uRLFilteringRules:URLFilteringRules")]
    public partial class URLFilteringRules : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        /// </summary>
        [Output("action")]
        public Output<string?> Action { get; private set; } = null!;

        /// <summary>
        /// When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block_override is not set, `BLOCK` action cannot be overridden.
        /// </summary>
        [Output("blockOverride")]
        public Output<bool?> BlockOverride { get; private set; } = null!;

        /// <summary>
        /// The cloud browser isolation profile to which the ISOLATE action is applied in the URL Filtering Policy rules. This block is required when the attribute `action` is set to `ISOLATE`
        /// </summary>
        [Output("cbiProfiles")]
        public Output<ImmutableArray<Outputs.URLFilteringRulesCbiProfile>> CbiProfiles { get; private set; } = null!;

        /// <summary>
        /// If set to true, the CIPA Compliance rule is enabled
        /// </summary>
        [Output("ciparule")]
        public Output<bool?> Ciparule { get; private set; } = null!;

        /// <summary>
        /// The departments to which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("departments")]
        public Output<Outputs.URLFilteringRulesDepartments> Departments { get; private set; } = null!;

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Output("deviceGroups")]
        public Output<Outputs.URLFilteringRulesDeviceGroups> DeviceGroups { get; private set; } = null!;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        /// </summary>
        [Output("deviceTrustLevels")]
        public Output<ImmutableArray<string>> DeviceTrustLevels { get; private set; } = null!;

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Output("devices")]
        public Output<Outputs.URLFilteringRulesDevices> Devices { get; private set; } = null!;

        /// <summary>
        /// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        /// </summary>
        [Output("endUserNotificationUrl")]
        public Output<string?> EndUserNotificationUrl { get; private set; } = null!;

        /// <summary>
        /// Enforce a set a validity time period for the URL Filtering rule.
        /// </summary>
        [Output("enforceTimeValidity")]
        public Output<bool?> EnforceTimeValidity { get; private set; } = null!;

        /// <summary>
        /// The groups to which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("groups")]
        public Output<Outputs.URLFilteringRulesGroups> Groups { get; private set; } = null!;

        /// <summary>
        /// The URL Filtering rule's label.
        /// </summary>
        [Output("labels")]
        public Output<Outputs.URLFilteringRulesLabels> Labels { get; private set; } = null!;

        /// <summary>
        /// The location groups to which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("locationGroups")]
        public Output<Outputs.URLFilteringRulesLocationGroups> LocationGroups { get; private set; } = null!;

        /// <summary>
        /// The locations to which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("locations")]
        public Output<Outputs.URLFilteringRulesLocations> Locations { get; private set; } = null!;

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Order of execution of rule with respect to other URL Filtering rules
        /// </summary>
        [Output("order")]
        public Output<int> Order { get; private set; } = null!;

        /// <summary>
        /// Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        /// </summary>
        [Output("overrideGroups")]
        public Output<Outputs.URLFilteringRulesOverrideGroups> OverrideGroups { get; private set; } = null!;

        /// <summary>
        /// Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        /// </summary>
        [Output("overrideUsers")]
        public Output<Outputs.URLFilteringRulesOverrideUsers> OverrideUsers { get; private set; } = null!;

        /// <summary>
        /// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        /// </summary>
        [Output("protocols")]
        public Output<ImmutableArray<string>> Protocols { get; private set; } = null!;

        /// <summary>
        /// Admin rank of the admin who creates this rule
        /// </summary>
        [Output("rank")]
        public Output<int?> Rank { get; private set; } = null!;

        /// <summary>
        /// Request method for which the rule must be applied. If not set, rule will be applied to all methods
        /// </summary>
        [Output("requestMethods")]
        public Output<ImmutableArray<string>> RequestMethods { get; private set; } = null!;

        /// <summary>
        /// URL Filtering Rule ID
        /// </summary>
        [Output("ruleId")]
        public Output<int> RuleId { get; private set; } = null!;

        /// <summary>
        /// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        /// </summary>
        [Output("sizeQuota")]
        public Output<int?> SizeQuota { get; private set; } = null!;

        /// <summary>
        /// Rule State
        /// </summary>
        [Output("state")]
        public Output<string?> State { get; private set; } = null!;

        /// <summary>
        /// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        /// </summary>
        [Output("timeQuota")]
        public Output<int?> TimeQuota { get; private set; } = null!;

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("timeWindows")]
        public Output<Outputs.URLFilteringRulesTimeWindows> TimeWindows { get; private set; } = null!;

        /// <summary>
        /// List of URL categories for which rule must be applied
        /// </summary>
        [Output("urlCategories")]
        public Output<ImmutableArray<string>> UrlCategories { get; private set; } = null!;

        /// <summary>
        /// Supported User Agent Types
        /// </summary>
        [Output("userAgentTypes")]
        public Output<ImmutableArray<string>> UserAgentTypes { get; private set; } = null!;

        /// <summary>
        /// Indicates the user risk score level selectedd for the DLP rule violation: Returned values are: `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`
        /// </summary>
        [Output("userRiskScoreLevels")]
        public Output<ImmutableArray<string>> UserRiskScoreLevels { get; private set; } = null!;

        /// <summary>
        /// The users to which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("users")]
        public Output<Outputs.URLFilteringRulesUsers> Users { get; private set; } = null!;

        /// <summary>
        /// If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        /// </summary>
        [Output("validityEndTime")]
        public Output<int?> ValidityEndTime { get; private set; } = null!;

        /// <summary>
        /// If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        /// </summary>
        [Output("validityStartTime")]
        public Output<int?> ValidityStartTime { get; private set; } = null!;

        /// <summary>
        /// If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        /// </summary>
        [Output("validityTimeZoneId")]
        public Output<string?> ValidityTimeZoneId { get; private set; } = null!;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        [Output("workloadGroups")]
        public Output<ImmutableArray<Outputs.URLFilteringRulesWorkloadGroup>> WorkloadGroups { get; private set; } = null!;


        /// <summary>
        /// Create a URLFilteringRules resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public URLFilteringRules(string name, URLFilteringRulesArgs args, CustomResourceOptions? options = null)
            : base("zia:index/uRLFilteringRules:URLFilteringRules", name, args ?? new URLFilteringRulesArgs(), MakeResourceOptions(options, ""))
        {
        }

        private URLFilteringRules(string name, Input<string> id, URLFilteringRulesState? state = null, CustomResourceOptions? options = null)
            : base("zia:index/uRLFilteringRules:URLFilteringRules", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing URLFilteringRules resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static URLFilteringRules Get(string name, Input<string> id, URLFilteringRulesState? state = null, CustomResourceOptions? options = null)
        {
            return new URLFilteringRules(name, id, state, options);
        }
    }

    public sealed class URLFilteringRulesArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block_override is not set, `BLOCK` action cannot be overridden.
        /// </summary>
        [Input("blockOverride")]
        public Input<bool>? BlockOverride { get; set; }

        [Input("cbiProfiles")]
        private InputList<Inputs.URLFilteringRulesCbiProfileArgs>? _cbiProfiles;

        /// <summary>
        /// The cloud browser isolation profile to which the ISOLATE action is applied in the URL Filtering Policy rules. This block is required when the attribute `action` is set to `ISOLATE`
        /// </summary>
        public InputList<Inputs.URLFilteringRulesCbiProfileArgs> CbiProfiles
        {
            get => _cbiProfiles ?? (_cbiProfiles = new InputList<Inputs.URLFilteringRulesCbiProfileArgs>());
            set => _cbiProfiles = value;
        }

        /// <summary>
        /// If set to true, the CIPA Compliance rule is enabled
        /// </summary>
        [Input("ciparule")]
        public Input<bool>? Ciparule { get; set; }

        /// <summary>
        /// The departments to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("departments")]
        public Input<Inputs.URLFilteringRulesDepartmentsArgs>? Departments { get; set; }

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.URLFilteringRulesDeviceGroupsArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.URLFilteringRulesDevicesArgs>? Devices { get; set; }

        /// <summary>
        /// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        /// </summary>
        [Input("endUserNotificationUrl")]
        public Input<string>? EndUserNotificationUrl { get; set; }

        /// <summary>
        /// Enforce a set a validity time period for the URL Filtering rule.
        /// </summary>
        [Input("enforceTimeValidity")]
        public Input<bool>? EnforceTimeValidity { get; set; }

        /// <summary>
        /// The groups to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("groups")]
        public Input<Inputs.URLFilteringRulesGroupsArgs>? Groups { get; set; }

        /// <summary>
        /// The URL Filtering rule's label.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.URLFilteringRulesLabelsArgs>? Labels { get; set; }

        /// <summary>
        /// The location groups to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.URLFilteringRulesLocationGroupsArgs>? LocationGroups { get; set; }

        /// <summary>
        /// The locations to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("locations")]
        public Input<Inputs.URLFilteringRulesLocationsArgs>? Locations { get; set; }

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Order of execution of rule with respect to other URL Filtering rules
        /// </summary>
        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        /// </summary>
        [Input("overrideGroups")]
        public Input<Inputs.URLFilteringRulesOverrideGroupsArgs>? OverrideGroups { get; set; }

        /// <summary>
        /// Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        /// </summary>
        [Input("overrideUsers")]
        public Input<Inputs.URLFilteringRulesOverrideUsersArgs>? OverrideUsers { get; set; }

        [Input("protocols", required: true)]
        private InputList<string>? _protocols;

        /// <summary>
        /// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        /// </summary>
        public InputList<string> Protocols
        {
            get => _protocols ?? (_protocols = new InputList<string>());
            set => _protocols = value;
        }

        /// <summary>
        /// Admin rank of the admin who creates this rule
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("requestMethods")]
        private InputList<string>? _requestMethods;

        /// <summary>
        /// Request method for which the rule must be applied. If not set, rule will be applied to all methods
        /// </summary>
        public InputList<string> RequestMethods
        {
            get => _requestMethods ?? (_requestMethods = new InputList<string>());
            set => _requestMethods = value;
        }

        /// <summary>
        /// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        /// </summary>
        [Input("sizeQuota")]
        public Input<int>? SizeQuota { get; set; }

        /// <summary>
        /// Rule State
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        /// </summary>
        [Input("timeQuota")]
        public Input<int>? TimeQuota { get; set; }

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.URLFilteringRulesTimeWindowsArgs>? TimeWindows { get; set; }

        [Input("urlCategories")]
        private InputList<string>? _urlCategories;

        /// <summary>
        /// List of URL categories for which rule must be applied
        /// </summary>
        public InputList<string> UrlCategories
        {
            get => _urlCategories ?? (_urlCategories = new InputList<string>());
            set => _urlCategories = value;
        }

        [Input("userAgentTypes")]
        private InputList<string>? _userAgentTypes;

        /// <summary>
        /// Supported User Agent Types
        /// </summary>
        public InputList<string> UserAgentTypes
        {
            get => _userAgentTypes ?? (_userAgentTypes = new InputList<string>());
            set => _userAgentTypes = value;
        }

        [Input("userRiskScoreLevels")]
        private InputList<string>? _userRiskScoreLevels;

        /// <summary>
        /// Indicates the user risk score level selectedd for the DLP rule violation: Returned values are: `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`
        /// </summary>
        public InputList<string> UserRiskScoreLevels
        {
            get => _userRiskScoreLevels ?? (_userRiskScoreLevels = new InputList<string>());
            set => _userRiskScoreLevels = value;
        }

        /// <summary>
        /// The users to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("users")]
        public Input<Inputs.URLFilteringRulesUsersArgs>? Users { get; set; }

        /// <summary>
        /// If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        /// </summary>
        [Input("validityEndTime")]
        public Input<int>? ValidityEndTime { get; set; }

        /// <summary>
        /// If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        /// </summary>
        [Input("validityStartTime")]
        public Input<int>? ValidityStartTime { get; set; }

        /// <summary>
        /// If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        /// </summary>
        [Input("validityTimeZoneId")]
        public Input<string>? ValidityTimeZoneId { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.URLFilteringRulesWorkloadGroupArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.URLFilteringRulesWorkloadGroupArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.URLFilteringRulesWorkloadGroupArgs>());
            set => _workloadGroups = value;
        }

        public URLFilteringRulesArgs()
        {
        }
        public static new URLFilteringRulesArgs Empty => new URLFilteringRulesArgs();
    }

    public sealed class URLFilteringRulesState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block_override is not set, `BLOCK` action cannot be overridden.
        /// </summary>
        [Input("blockOverride")]
        public Input<bool>? BlockOverride { get; set; }

        [Input("cbiProfiles")]
        private InputList<Inputs.URLFilteringRulesCbiProfileGetArgs>? _cbiProfiles;

        /// <summary>
        /// The cloud browser isolation profile to which the ISOLATE action is applied in the URL Filtering Policy rules. This block is required when the attribute `action` is set to `ISOLATE`
        /// </summary>
        public InputList<Inputs.URLFilteringRulesCbiProfileGetArgs> CbiProfiles
        {
            get => _cbiProfiles ?? (_cbiProfiles = new InputList<Inputs.URLFilteringRulesCbiProfileGetArgs>());
            set => _cbiProfiles = value;
        }

        /// <summary>
        /// If set to true, the CIPA Compliance rule is enabled
        /// </summary>
        [Input("ciparule")]
        public Input<bool>? Ciparule { get; set; }

        /// <summary>
        /// The departments to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("departments")]
        public Input<Inputs.URLFilteringRulesDepartmentsGetArgs>? Departments { get; set; }

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.URLFilteringRulesDeviceGroupsGetArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.URLFilteringRulesDevicesGetArgs>? Devices { get; set; }

        /// <summary>
        /// URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        /// </summary>
        [Input("endUserNotificationUrl")]
        public Input<string>? EndUserNotificationUrl { get; set; }

        /// <summary>
        /// Enforce a set a validity time period for the URL Filtering rule.
        /// </summary>
        [Input("enforceTimeValidity")]
        public Input<bool>? EnforceTimeValidity { get; set; }

        /// <summary>
        /// The groups to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("groups")]
        public Input<Inputs.URLFilteringRulesGroupsGetArgs>? Groups { get; set; }

        /// <summary>
        /// The URL Filtering rule's label.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.URLFilteringRulesLabelsGetArgs>? Labels { get; set; }

        /// <summary>
        /// The location groups to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.URLFilteringRulesLocationGroupsGetArgs>? LocationGroups { get; set; }

        /// <summary>
        /// The locations to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("locations")]
        public Input<Inputs.URLFilteringRulesLocationsGetArgs>? Locations { get; set; }

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Order of execution of rule with respect to other URL Filtering rules
        /// </summary>
        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        /// </summary>
        [Input("overrideGroups")]
        public Input<Inputs.URLFilteringRulesOverrideGroupsGetArgs>? OverrideGroups { get; set; }

        /// <summary>
        /// Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        /// </summary>
        [Input("overrideUsers")]
        public Input<Inputs.URLFilteringRulesOverrideUsersGetArgs>? OverrideUsers { get; set; }

        [Input("protocols")]
        private InputList<string>? _protocols;

        /// <summary>
        /// Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        /// </summary>
        public InputList<string> Protocols
        {
            get => _protocols ?? (_protocols = new InputList<string>());
            set => _protocols = value;
        }

        /// <summary>
        /// Admin rank of the admin who creates this rule
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("requestMethods")]
        private InputList<string>? _requestMethods;

        /// <summary>
        /// Request method for which the rule must be applied. If not set, rule will be applied to all methods
        /// </summary>
        public InputList<string> RequestMethods
        {
            get => _requestMethods ?? (_requestMethods = new InputList<string>());
            set => _requestMethods = value;
        }

        /// <summary>
        /// URL Filtering Rule ID
        /// </summary>
        [Input("ruleId")]
        public Input<int>? RuleId { get; set; }

        /// <summary>
        /// Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        /// </summary>
        [Input("sizeQuota")]
        public Input<int>? SizeQuota { get; set; }

        /// <summary>
        /// Rule State
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        /// </summary>
        [Input("timeQuota")]
        public Input<int>? TimeQuota { get; set; }

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.URLFilteringRulesTimeWindowsGetArgs>? TimeWindows { get; set; }

        [Input("urlCategories")]
        private InputList<string>? _urlCategories;

        /// <summary>
        /// List of URL categories for which rule must be applied
        /// </summary>
        public InputList<string> UrlCategories
        {
            get => _urlCategories ?? (_urlCategories = new InputList<string>());
            set => _urlCategories = value;
        }

        [Input("userAgentTypes")]
        private InputList<string>? _userAgentTypes;

        /// <summary>
        /// Supported User Agent Types
        /// </summary>
        public InputList<string> UserAgentTypes
        {
            get => _userAgentTypes ?? (_userAgentTypes = new InputList<string>());
            set => _userAgentTypes = value;
        }

        [Input("userRiskScoreLevels")]
        private InputList<string>? _userRiskScoreLevels;

        /// <summary>
        /// Indicates the user risk score level selectedd for the DLP rule violation: Returned values are: `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`
        /// </summary>
        public InputList<string> UserRiskScoreLevels
        {
            get => _userRiskScoreLevels ?? (_userRiskScoreLevels = new InputList<string>());
            set => _userRiskScoreLevels = value;
        }

        /// <summary>
        /// The users to which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("users")]
        public Input<Inputs.URLFilteringRulesUsersGetArgs>? Users { get; set; }

        /// <summary>
        /// If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        /// </summary>
        [Input("validityEndTime")]
        public Input<int>? ValidityEndTime { get; set; }

        /// <summary>
        /// If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        /// </summary>
        [Input("validityStartTime")]
        public Input<int>? ValidityStartTime { get; set; }

        /// <summary>
        /// If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        /// </summary>
        [Input("validityTimeZoneId")]
        public Input<string>? ValidityTimeZoneId { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.URLFilteringRulesWorkloadGroupGetArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.URLFilteringRulesWorkloadGroupGetArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.URLFilteringRulesWorkloadGroupGetArgs>());
            set => _workloadGroups = value;
        }

        public URLFilteringRulesState()
        {
        }
        public static new URLFilteringRulesState Empty => new URLFilteringRulesState();
    }
}

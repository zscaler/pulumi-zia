// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace zscaler.PulumiPackage.Zia
{
    /// <summary>
    /// The **zia_firewall_filtering_rule** resource allows the creation and management of ZIA Cloud Firewall filtering rules in the Zscaler Internet Access.
    /// 
    /// ## Example Usage
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Zia = Pulumi.Zia;
    /// using Zia = zscaler.PulumiPackage.Zia;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var zscalerProxyNwServices = Zia.GetFirewallFilteringNetworkServices.Invoke(new()
    ///     {
    ///         Name = "ZSCALER_PROXY_NW_SERVICES",
    ///     });
    /// 
    ///     var engineering = Zia.GetDepartmentManagement.Invoke(new()
    ///     {
    ///         Name = "Engineering",
    ///     });
    /// 
    ///     var normalInternet = Zia.GetGroupManagement.Invoke(new()
    ///     {
    ///         Name = "Normal_Internet",
    ///     });
    /// 
    ///     var workHours = Zia.GetTimeWindow.Invoke(new()
    ///     {
    ///         Name = "Work hours",
    ///     });
    /// 
    ///     var example = new Zia.FirewallFilteringRule("example", new()
    ///     {
    ///         Description = "Example",
    ///         Action = "ALLOW",
    ///         State = "ENABLED",
    ///         Order = 1,
    ///         EnableFullLogging = true,
    ///         NwServices = new Zia.Inputs.FirewallFilteringRuleNwServicesArgs
    ///         {
    ///             Ids = new[]
    ///             {
    ///                 zscalerProxyNwServices.Apply(getFirewallFilteringNetworkServicesResult =&gt; getFirewallFilteringNetworkServicesResult.Id),
    ///             },
    ///         },
    ///         Departments = new Zia.Inputs.FirewallFilteringRuleDepartmentsArgs
    ///         {
    ///             Ids = new[]
    ///             {
    ///                 engineering.Apply(getDepartmentManagementResult =&gt; getDepartmentManagementResult.Id),
    ///             },
    ///         },
    ///         Groups = new Zia.Inputs.FirewallFilteringRuleGroupsArgs
    ///         {
    ///             Ids = new[]
    ///             {
    ///                 normalInternet.Apply(getGroupManagementResult =&gt; getGroupManagementResult.Id),
    ///             },
    ///         },
    ///         TimeWindows = new Zia.Inputs.FirewallFilteringRuleTimeWindowsArgs
    ///         {
    ///             Ids = new[]
    ///             {
    ///                 workHours.Apply(getTimeWindowResult =&gt; getTimeWindowResult.Id),
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// 
    /// Visit
    /// 
    /// **zia_firewall_filtering_rule** can be imported by using `&lt;RULE ID&gt;` or `&lt;RULE NAME&gt;` as the import ID.
    /// 
    /// For example:
    /// 
    /// ```sh
    /// $ pulumi import zia:index/firewallFilteringRule:FirewallFilteringRule example &lt;rule_id&gt;
    /// ```
    /// 
    /// or
    /// 
    /// ```sh
    /// $ pulumi import zia:index/firewallFilteringRule:FirewallFilteringRule example &lt;rule_name&gt;
    /// ```
    /// </summary>
    [ZiaResourceType("zia:index/firewallFilteringRule:FirewallFilteringRule")]
    public partial class FirewallFilteringRule : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Choose the action of the service when packets match the rule. The following actions are accepted: `ALLOW`, `BLOCK_DROP`, `BLOCK_RESET`, `BLOCK_ICMP`, `EVAL_NWAPP`
        /// </summary>
        [Output("action")]
        public Output<string?> Action { get; private set; } = null!;

        /// <summary>
        /// Application service groups on which this rule is applied
        /// </summary>
        [Output("appServiceGroups")]
        public Output<Outputs.FirewallFilteringRuleAppServiceGroups> AppServiceGroups { get; private set; } = null!;

        /// <summary>
        /// Application services on which this rule is applied
        /// </summary>
        [Output("appServices")]
        public Output<Outputs.FirewallFilteringRuleAppServices> AppServices { get; private set; } = null!;

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Output("defaultRule")]
        public Output<bool?> DefaultRule { get; private set; } = null!;

        /// <summary>
        /// Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        /// </summary>
        [Output("departments")]
        public Output<Outputs.FirewallFilteringRuleDepartments> Departments { get; private set; } = null!;

        /// <summary>
        /// Enter additional notes or information. The description cannot exceed 10,240 characters.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// ** - (Optional) -  IP addresses and fully qualified domain names (FQDNs), if the domain has multiple destination IP addresses or if its IP addresses may change. For IP addresses, you can enter individual IP addresses, subnets, or address ranges. If adding multiple items, hit Enter after each entry.
        /// </summary>
        [Output("destAddresses")]
        public Output<ImmutableArray<string>> DestAddresses { get; private set; } = null!;

        /// <summary>
        /// ** - (Optional) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        /// </summary>
        [Output("destCountries")]
        public Output<ImmutableArray<string>> DestCountries { get; private set; } = null!;

        /// <summary>
        /// ** - (Optional) identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        /// </summary>
        [Output("destIpCategories")]
        public Output<ImmutableArray<string>> DestIpCategories { get; private set; } = null!;

        /// <summary>
        /// ** - (Optional) Any number of destination IP address groups that you want to control with this rule.
        /// </summary>
        [Output("destIpGroups")]
        public Output<Outputs.FirewallFilteringRuleDestIpGroups> DestIpGroups { get; private set; } = null!;

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Output("deviceGroups")]
        public Output<Outputs.FirewallFilteringRuleDeviceGroups> DeviceGroups { get; private set; } = null!;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        /// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        /// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        [Output("deviceTrustLevels")]
        public Output<ImmutableArray<string>> DeviceTrustLevels { get; private set; } = null!;

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Output("devices")]
        public Output<Outputs.FirewallFilteringRuleDevices> Devices { get; private set; } = null!;

        [Output("enableFullLogging")]
        public Output<bool?> EnableFullLogging { get; private set; } = null!;

        /// <summary>
        /// You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        /// </summary>
        [Output("groups")]
        public Output<Outputs.FirewallFilteringRuleGroups> Groups { get; private set; } = null!;

        /// <summary>
        /// Labels that are applicable to the rule.
        /// </summary>
        [Output("labels")]
        public Output<Outputs.FirewallFilteringRuleLabels> Labels { get; private set; } = null!;

        /// <summary>
        /// You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        /// </summary>
        [Output("locationGroups")]
        public Output<Outputs.FirewallFilteringRuleLocationGroups> LocationGroups { get; private set; } = null!;

        /// <summary>
        /// You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        /// </summary>
        [Output("locations")]
        public Output<Outputs.FirewallFilteringRuleLocations> Locations { get; private set; } = null!;

        /// <summary>
        /// The name of the workload group
        /// 
        /// * `Other Exported Arguments`
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Any number of application groups that you want to control with this rule. The service provides predefined applications that you can group, but not modify
        /// </summary>
        [Output("nwApplicationGroups")]
        public Output<Outputs.FirewallFilteringRuleNwApplicationGroups> NwApplicationGroups { get; private set; } = null!;

        /// <summary>
        /// When not used it applies the rule to all applications. The service provides predefined applications, which you can group, but not modify.
        /// 
        /// `source ip addresses` supports the following attributes:
        /// </summary>
        [Output("nwApplications")]
        public Output<ImmutableArray<string>> NwApplications { get; private set; } = null!;

        /// <summary>
        /// Any number of predefined or custom network service groups to which the rule applies.
        /// </summary>
        [Output("nwServiceGroups")]
        public Output<Outputs.FirewallFilteringRuleNwServiceGroups> NwServiceGroups { get; private set; } = null!;

        /// <summary>
        /// When not used it applies the rule to all network services or you can select specific network services. The Zscaler firewall has predefined services and you can configure up to `1,024` additional custom services.
        /// 
        /// `network applications` supports the following attributes:
        /// </summary>
        [Output("nwServices")]
        public Output<Outputs.FirewallFilteringRuleNwServices> NwServices { get; private set; } = null!;

        /// <summary>
        /// Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        /// </summary>
        [Output("order")]
        public Output<int?> Order { get; private set; } = null!;

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Output("predefined")]
        public Output<bool?> Predefined { get; private set; } = null!;

        /// <summary>
        /// By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        /// 
        /// `Who, Where and When` supports the following attributes:
        /// </summary>
        [Output("rank")]
        public Output<int?> Rank { get; private set; } = null!;

        [Output("ruleId")]
        public Output<int> RuleId { get; private set; } = null!;

        /// <summary>
        /// Any number of source IP address groups that you want to control with this rule.
        /// </summary>
        [Output("srcIpGroups")]
        public Output<Outputs.FirewallFilteringRuleSrcIpGroups> SrcIpGroups { get; private set; } = null!;

        /// <summary>
        /// You can enter individual IP addresses, subnets, or address ranges.
        /// </summary>
        [Output("srcIps")]
        public Output<ImmutableArray<string>> SrcIps { get; private set; } = null!;

        /// <summary>
        /// An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        /// </summary>
        [Output("state")]
        public Output<string?> State { get; private set; } = null!;

        /// <summary>
        /// You can manually select up to `2` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        /// </summary>
        [Output("timeWindows")]
        public Output<Outputs.FirewallFilteringRuleTimeWindows> TimeWindows { get; private set; } = null!;

        /// <summary>
        /// You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        /// </summary>
        [Output("users")]
        public Output<Outputs.FirewallFilteringRuleUsers> Users { get; private set; } = null!;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        [Output("workloadGroups")]
        public Output<ImmutableArray<Outputs.FirewallFilteringRuleWorkloadGroup>> WorkloadGroups { get; private set; } = null!;

        /// <summary>
        /// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
        /// Gateway forwarding method.
        /// </summary>
        [Output("zpaAppSegments")]
        public Output<ImmutableArray<Outputs.FirewallFilteringRuleZpaAppSegment>> ZpaAppSegments { get; private set; } = null!;


        /// <summary>
        /// Create a FirewallFilteringRule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public FirewallFilteringRule(string name, FirewallFilteringRuleArgs? args = null, CustomResourceOptions? options = null)
            : base("zia:index/firewallFilteringRule:FirewallFilteringRule", name, args ?? new FirewallFilteringRuleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private FirewallFilteringRule(string name, Input<string> id, FirewallFilteringRuleState? state = null, CustomResourceOptions? options = null)
            : base("zia:index/firewallFilteringRule:FirewallFilteringRule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing FirewallFilteringRule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static FirewallFilteringRule Get(string name, Input<string> id, FirewallFilteringRuleState? state = null, CustomResourceOptions? options = null)
        {
            return new FirewallFilteringRule(name, id, state, options);
        }
    }

    public sealed class FirewallFilteringRuleArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Choose the action of the service when packets match the rule. The following actions are accepted: `ALLOW`, `BLOCK_DROP`, `BLOCK_RESET`, `BLOCK_ICMP`, `EVAL_NWAPP`
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Application service groups on which this rule is applied
        /// </summary>
        [Input("appServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleAppServiceGroupsArgs>? AppServiceGroups { get; set; }

        /// <summary>
        /// Application services on which this rule is applied
        /// </summary>
        [Input("appServices")]
        public Input<Inputs.FirewallFilteringRuleAppServicesArgs>? AppServices { get; set; }

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Input("defaultRule")]
        public Input<bool>? DefaultRule { get; set; }

        /// <summary>
        /// Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        /// </summary>
        [Input("departments")]
        public Input<Inputs.FirewallFilteringRuleDepartmentsArgs>? Departments { get; set; }

        /// <summary>
        /// Enter additional notes or information. The description cannot exceed 10,240 characters.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("destAddresses")]
        private InputList<string>? _destAddresses;

        /// <summary>
        /// ** - (Optional) -  IP addresses and fully qualified domain names (FQDNs), if the domain has multiple destination IP addresses or if its IP addresses may change. For IP addresses, you can enter individual IP addresses, subnets, or address ranges. If adding multiple items, hit Enter after each entry.
        /// </summary>
        public InputList<string> DestAddresses
        {
            get => _destAddresses ?? (_destAddresses = new InputList<string>());
            set => _destAddresses = value;
        }

        [Input("destCountries")]
        private InputList<string>? _destCountries;

        /// <summary>
        /// ** - (Optional) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        /// </summary>
        public InputList<string> DestCountries
        {
            get => _destCountries ?? (_destCountries = new InputList<string>());
            set => _destCountries = value;
        }

        [Input("destIpCategories")]
        private InputList<string>? _destIpCategories;

        /// <summary>
        /// ** - (Optional) identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        /// </summary>
        public InputList<string> DestIpCategories
        {
            get => _destIpCategories ?? (_destIpCategories = new InputList<string>());
            set => _destIpCategories = value;
        }

        /// <summary>
        /// ** - (Optional) Any number of destination IP address groups that you want to control with this rule.
        /// </summary>
        [Input("destIpGroups")]
        public Input<Inputs.FirewallFilteringRuleDestIpGroupsArgs>? DestIpGroups { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.FirewallFilteringRuleDeviceGroupsArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        /// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        /// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.FirewallFilteringRuleDevicesArgs>? Devices { get; set; }

        [Input("enableFullLogging")]
        public Input<bool>? EnableFullLogging { get; set; }

        /// <summary>
        /// You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        /// </summary>
        [Input("groups")]
        public Input<Inputs.FirewallFilteringRuleGroupsArgs>? Groups { get; set; }

        /// <summary>
        /// Labels that are applicable to the rule.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.FirewallFilteringRuleLabelsArgs>? Labels { get; set; }

        /// <summary>
        /// You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.FirewallFilteringRuleLocationGroupsArgs>? LocationGroups { get; set; }

        /// <summary>
        /// You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        /// </summary>
        [Input("locations")]
        public Input<Inputs.FirewallFilteringRuleLocationsArgs>? Locations { get; set; }

        /// <summary>
        /// The name of the workload group
        /// 
        /// * `Other Exported Arguments`
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Any number of application groups that you want to control with this rule. The service provides predefined applications that you can group, but not modify
        /// </summary>
        [Input("nwApplicationGroups")]
        public Input<Inputs.FirewallFilteringRuleNwApplicationGroupsArgs>? NwApplicationGroups { get; set; }

        [Input("nwApplications")]
        private InputList<string>? _nwApplications;

        /// <summary>
        /// When not used it applies the rule to all applications. The service provides predefined applications, which you can group, but not modify.
        /// 
        /// `source ip addresses` supports the following attributes:
        /// </summary>
        public InputList<string> NwApplications
        {
            get => _nwApplications ?? (_nwApplications = new InputList<string>());
            set => _nwApplications = value;
        }

        /// <summary>
        /// Any number of predefined or custom network service groups to which the rule applies.
        /// </summary>
        [Input("nwServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleNwServiceGroupsArgs>? NwServiceGroups { get; set; }

        /// <summary>
        /// When not used it applies the rule to all network services or you can select specific network services. The Zscaler firewall has predefined services and you can configure up to `1,024` additional custom services.
        /// 
        /// `network applications` supports the following attributes:
        /// </summary>
        [Input("nwServices")]
        public Input<Inputs.FirewallFilteringRuleNwServicesArgs>? NwServices { get; set; }

        /// <summary>
        /// Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        /// </summary>
        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Input("predefined")]
        public Input<bool>? Predefined { get; set; }

        /// <summary>
        /// By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        /// 
        /// `Who, Where and When` supports the following attributes:
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        /// <summary>
        /// Any number of source IP address groups that you want to control with this rule.
        /// </summary>
        [Input("srcIpGroups")]
        public Input<Inputs.FirewallFilteringRuleSrcIpGroupsArgs>? SrcIpGroups { get; set; }

        [Input("srcIps")]
        private InputList<string>? _srcIps;

        /// <summary>
        /// You can enter individual IP addresses, subnets, or address ranges.
        /// </summary>
        public InputList<string> SrcIps
        {
            get => _srcIps ?? (_srcIps = new InputList<string>());
            set => _srcIps = value;
        }

        /// <summary>
        /// An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// You can manually select up to `2` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.FirewallFilteringRuleTimeWindowsArgs>? TimeWindows { get; set; }

        /// <summary>
        /// You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        /// </summary>
        [Input("users")]
        public Input<Inputs.FirewallFilteringRuleUsersArgs>? Users { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.FirewallFilteringRuleWorkloadGroupArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleWorkloadGroupArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.FirewallFilteringRuleWorkloadGroupArgs>());
            set => _workloadGroups = value;
        }

        [Input("zpaAppSegments")]
        private InputList<Inputs.FirewallFilteringRuleZpaAppSegmentArgs>? _zpaAppSegments;

        /// <summary>
        /// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
        /// Gateway forwarding method.
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleZpaAppSegmentArgs> ZpaAppSegments
        {
            get => _zpaAppSegments ?? (_zpaAppSegments = new InputList<Inputs.FirewallFilteringRuleZpaAppSegmentArgs>());
            set => _zpaAppSegments = value;
        }

        public FirewallFilteringRuleArgs()
        {
        }
        public static new FirewallFilteringRuleArgs Empty => new FirewallFilteringRuleArgs();
    }

    public sealed class FirewallFilteringRuleState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Choose the action of the service when packets match the rule. The following actions are accepted: `ALLOW`, `BLOCK_DROP`, `BLOCK_RESET`, `BLOCK_ICMP`, `EVAL_NWAPP`
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Application service groups on which this rule is applied
        /// </summary>
        [Input("appServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleAppServiceGroupsGetArgs>? AppServiceGroups { get; set; }

        /// <summary>
        /// Application services on which this rule is applied
        /// </summary>
        [Input("appServices")]
        public Input<Inputs.FirewallFilteringRuleAppServicesGetArgs>? AppServices { get; set; }

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Input("defaultRule")]
        public Input<bool>? DefaultRule { get; set; }

        /// <summary>
        /// Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        /// </summary>
        [Input("departments")]
        public Input<Inputs.FirewallFilteringRuleDepartmentsGetArgs>? Departments { get; set; }

        /// <summary>
        /// Enter additional notes or information. The description cannot exceed 10,240 characters.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("destAddresses")]
        private InputList<string>? _destAddresses;

        /// <summary>
        /// ** - (Optional) -  IP addresses and fully qualified domain names (FQDNs), if the domain has multiple destination IP addresses or if its IP addresses may change. For IP addresses, you can enter individual IP addresses, subnets, or address ranges. If adding multiple items, hit Enter after each entry.
        /// </summary>
        public InputList<string> DestAddresses
        {
            get => _destAddresses ?? (_destAddresses = new InputList<string>());
            set => _destAddresses = value;
        }

        [Input("destCountries")]
        private InputList<string>? _destCountries;

        /// <summary>
        /// ** - (Optional) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        /// </summary>
        public InputList<string> DestCountries
        {
            get => _destCountries ?? (_destCountries = new InputList<string>());
            set => _destCountries = value;
        }

        [Input("destIpCategories")]
        private InputList<string>? _destIpCategories;

        /// <summary>
        /// ** - (Optional) identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        /// </summary>
        public InputList<string> DestIpCategories
        {
            get => _destIpCategories ?? (_destIpCategories = new InputList<string>());
            set => _destIpCategories = value;
        }

        /// <summary>
        /// ** - (Optional) Any number of destination IP address groups that you want to control with this rule.
        /// </summary>
        [Input("destIpGroups")]
        public Input<Inputs.FirewallFilteringRuleDestIpGroupsGetArgs>? DestIpGroups { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.FirewallFilteringRuleDeviceGroupsGetArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        /// using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        /// Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.FirewallFilteringRuleDevicesGetArgs>? Devices { get; set; }

        [Input("enableFullLogging")]
        public Input<bool>? EnableFullLogging { get; set; }

        /// <summary>
        /// You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        /// </summary>
        [Input("groups")]
        public Input<Inputs.FirewallFilteringRuleGroupsGetArgs>? Groups { get; set; }

        /// <summary>
        /// Labels that are applicable to the rule.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.FirewallFilteringRuleLabelsGetArgs>? Labels { get; set; }

        /// <summary>
        /// You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.FirewallFilteringRuleLocationGroupsGetArgs>? LocationGroups { get; set; }

        /// <summary>
        /// You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        /// </summary>
        [Input("locations")]
        public Input<Inputs.FirewallFilteringRuleLocationsGetArgs>? Locations { get; set; }

        /// <summary>
        /// The name of the workload group
        /// 
        /// * `Other Exported Arguments`
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Any number of application groups that you want to control with this rule. The service provides predefined applications that you can group, but not modify
        /// </summary>
        [Input("nwApplicationGroups")]
        public Input<Inputs.FirewallFilteringRuleNwApplicationGroupsGetArgs>? NwApplicationGroups { get; set; }

        [Input("nwApplications")]
        private InputList<string>? _nwApplications;

        /// <summary>
        /// When not used it applies the rule to all applications. The service provides predefined applications, which you can group, but not modify.
        /// 
        /// `source ip addresses` supports the following attributes:
        /// </summary>
        public InputList<string> NwApplications
        {
            get => _nwApplications ?? (_nwApplications = new InputList<string>());
            set => _nwApplications = value;
        }

        /// <summary>
        /// Any number of predefined or custom network service groups to which the rule applies.
        /// </summary>
        [Input("nwServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleNwServiceGroupsGetArgs>? NwServiceGroups { get; set; }

        /// <summary>
        /// When not used it applies the rule to all network services or you can select specific network services. The Zscaler firewall has predefined services and you can configure up to `1,024` additional custom services.
        /// 
        /// `network applications` supports the following attributes:
        /// </summary>
        [Input("nwServices")]
        public Input<Inputs.FirewallFilteringRuleNwServicesGetArgs>? NwServices { get; set; }

        /// <summary>
        /// Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        /// </summary>
        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Input("predefined")]
        public Input<bool>? Predefined { get; set; }

        /// <summary>
        /// By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        /// 
        /// `Who, Where and When` supports the following attributes:
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("ruleId")]
        public Input<int>? RuleId { get; set; }

        /// <summary>
        /// Any number of source IP address groups that you want to control with this rule.
        /// </summary>
        [Input("srcIpGroups")]
        public Input<Inputs.FirewallFilteringRuleSrcIpGroupsGetArgs>? SrcIpGroups { get; set; }

        [Input("srcIps")]
        private InputList<string>? _srcIps;

        /// <summary>
        /// You can enter individual IP addresses, subnets, or address ranges.
        /// </summary>
        public InputList<string> SrcIps
        {
            get => _srcIps ?? (_srcIps = new InputList<string>());
            set => _srcIps = value;
        }

        /// <summary>
        /// An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// You can manually select up to `2` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.FirewallFilteringRuleTimeWindowsGetArgs>? TimeWindows { get; set; }

        /// <summary>
        /// You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        /// </summary>
        [Input("users")]
        public Input<Inputs.FirewallFilteringRuleUsersGetArgs>? Users { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.FirewallFilteringRuleWorkloadGroupGetArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleWorkloadGroupGetArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.FirewallFilteringRuleWorkloadGroupGetArgs>());
            set => _workloadGroups = value;
        }

        [Input("zpaAppSegments")]
        private InputList<Inputs.FirewallFilteringRuleZpaAppSegmentGetArgs>? _zpaAppSegments;

        /// <summary>
        /// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA
        /// Gateway forwarding method.
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleZpaAppSegmentGetArgs> ZpaAppSegments
        {
            get => _zpaAppSegments ?? (_zpaAppSegments = new InputList<Inputs.FirewallFilteringRuleZpaAppSegmentGetArgs>());
            set => _zpaAppSegments = value;
        }

        public FirewallFilteringRuleState()
        {
        }
        public static new FirewallFilteringRuleState Empty => new FirewallFilteringRuleState();
    }
}

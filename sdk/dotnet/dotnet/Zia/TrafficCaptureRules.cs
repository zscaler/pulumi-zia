// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace zscaler.PulumiPackage.Zia
{
    /// <summary>
    /// * [Official documentation](https://help.zscaler.com/zia/about-traffic-capture-policy)
    /// * [API documentation](https://help.zscaler.com/zia/traffic-capture-policy#/trafficCaptureRules-get)
    /// 
    /// The **zia_traffic_capture_rules** resource allows the creation and management of ZIA traffic capture rules in the Zscaler Internet Access.
    /// 
    /// ## Example Usage
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// Visit
    /// 
    /// **zia_traffic_capture_rules** can be imported by using `&lt;RULE ID&gt;` or `&lt;RULE NAME&gt;` as the import ID.
    /// 
    /// For example:
    /// 
    /// ```sh
    /// $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example &lt;rule_id&gt;
    /// ```
    /// 
    /// or
    /// 
    /// ```sh
    /// $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example &lt;rule_name&gt;
    /// ```
    /// </summary>
    [ZiaResourceType("zia:index/trafficCaptureRules:TrafficCaptureRules")]
    public partial class TrafficCaptureRules : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The action to be enforced when the traffic matches the rule criteria
        /// </summary>
        [Output("action")]
        public Output<string?> Action { get; private set; } = null!;

        /// <summary>
        /// list of application service groups
        /// </summary>
        [Output("appServiceGroups")]
        public Output<Outputs.TrafficCaptureRulesAppServiceGroups?> AppServiceGroups { get; private set; } = null!;

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Output("defaultRule")]
        public Output<bool?> DefaultRule { get; private set; } = null!;

        /// <summary>
        /// list of departments for which rule must be applied
        /// </summary>
        [Output("departments")]
        public Output<Outputs.TrafficCaptureRulesDepartments?> Departments { get; private set; } = null!;

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        /// </summary>
        [Output("destAddresses")]
        public Output<ImmutableArray<string>> DestAddresses { get; private set; } = null!;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        [Output("destCountries")]
        public Output<ImmutableArray<string>> DestCountries { get; private set; } = null!;

        [Output("destIpCategories")]
        public Output<ImmutableArray<string>> DestIpCategories { get; private set; } = null!;

        /// <summary>
        /// list of destination ip groups
        /// </summary>
        [Output("destIpGroups")]
        public Output<Outputs.TrafficCaptureRulesDestIpGroups?> DestIpGroups { get; private set; } = null!;

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Output("deviceGroups")]
        public Output<Outputs.TrafficCaptureRulesDeviceGroups?> DeviceGroups { get; private set; } = null!;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        [Output("deviceTrustLevels")]
        public Output<ImmutableArray<string>> DeviceTrustLevels { get; private set; } = null!;

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Output("devices")]
        public Output<Outputs.TrafficCaptureRulesDevices?> Devices { get; private set; } = null!;

        /// <summary>
        /// list of groups for which rule must be applied
        /// </summary>
        [Output("groups")]
        public Output<Outputs.TrafficCaptureRulesGroups?> Groups { get; private set; } = null!;

        /// <summary>
        /// list of Labels that are applicable to the rule.
        /// </summary>
        [Output("labels")]
        public Output<Outputs.TrafficCaptureRulesLabels?> Labels { get; private set; } = null!;

        /// <summary>
        /// list of locations groups
        /// </summary>
        [Output("locationGroups")]
        public Output<Outputs.TrafficCaptureRulesLocationGroups?> LocationGroups { get; private set; } = null!;

        /// <summary>
        /// list of locations for which rule must be applied
        /// </summary>
        [Output("locations")]
        public Output<Outputs.TrafficCaptureRulesLocations?> Locations { get; private set; } = null!;

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// list of nw application groups
        /// </summary>
        [Output("nwApplicationGroups")]
        public Output<Outputs.TrafficCaptureRulesNwApplicationGroups?> NwApplicationGroups { get; private set; } = null!;

        [Output("nwApplications")]
        public Output<ImmutableArray<string>> NwApplications { get; private set; } = null!;

        /// <summary>
        /// list of nw service groups
        /// </summary>
        [Output("nwServiceGroups")]
        public Output<Outputs.TrafficCaptureRulesNwServiceGroups?> NwServiceGroups { get; private set; } = null!;

        /// <summary>
        /// list of nw services
        /// </summary>
        [Output("nwServices")]
        public Output<Outputs.TrafficCaptureRulesNwServices?> NwServices { get; private set; } = null!;

        /// <summary>
        /// Rule order number. If omitted, the rule will be added to the end of the rule set.
        /// </summary>
        [Output("order")]
        public Output<int> Order { get; private set; } = null!;

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Output("predefined")]
        public Output<bool?> Predefined { get; private set; } = null!;

        /// <summary>
        /// Admin rank of the Firewall Filtering policy rule
        /// </summary>
        [Output("rank")]
        public Output<int?> Rank { get; private set; } = null!;

        [Output("ruleId")]
        public Output<int> RuleId { get; private set; } = null!;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        [Output("sourceCountries")]
        public Output<ImmutableArray<string>> SourceCountries { get; private set; } = null!;

        /// <summary>
        /// list of source ip groups
        /// </summary>
        [Output("srcIpGroups")]
        public Output<Outputs.TrafficCaptureRulesSrcIpGroups?> SrcIpGroups { get; private set; } = null!;

        /// <summary>
        /// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        /// </summary>
        [Output("srcIps")]
        public Output<ImmutableArray<string>> SrcIps { get; private set; } = null!;

        /// <summary>
        /// Determines whether the Firewall Filtering policy rule is enabled or disabled
        /// </summary>
        [Output("state")]
        public Output<string?> State { get; private set; } = null!;

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("timeWindows")]
        public Output<Outputs.TrafficCaptureRulesTimeWindows?> TimeWindows { get; private set; } = null!;

        /// <summary>
        /// The percentage of connections sampled for capturing each time the rule is triggered
        /// </summary>
        [Output("txnSampling")]
        public Output<string?> TxnSampling { get; private set; } = null!;

        /// <summary>
        /// The maximum size of traffic to capture per connection
        /// </summary>
        [Output("txnSizeLimit")]
        public Output<string?> TxnSizeLimit { get; private set; } = null!;

        /// <summary>
        /// list of users for which rule must be applied
        /// </summary>
        [Output("users")]
        public Output<Outputs.TrafficCaptureRulesUsers?> Users { get; private set; } = null!;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        [Output("workloadGroups")]
        public Output<ImmutableArray<Outputs.TrafficCaptureRulesWorkloadGroup>> WorkloadGroups { get; private set; } = null!;


        /// <summary>
        /// Create a TrafficCaptureRules resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public TrafficCaptureRules(string name, TrafficCaptureRulesArgs args, CustomResourceOptions? options = null)
            : base("zia:index/trafficCaptureRules:TrafficCaptureRules", name, args ?? new TrafficCaptureRulesArgs(), MakeResourceOptions(options, ""))
        {
        }

        private TrafficCaptureRules(string name, Input<string> id, TrafficCaptureRulesState? state = null, CustomResourceOptions? options = null)
            : base("zia:index/trafficCaptureRules:TrafficCaptureRules", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing TrafficCaptureRules resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static TrafficCaptureRules Get(string name, Input<string> id, TrafficCaptureRulesState? state = null, CustomResourceOptions? options = null)
        {
            return new TrafficCaptureRules(name, id, state, options);
        }
    }

    public sealed class TrafficCaptureRulesArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The action to be enforced when the traffic matches the rule criteria
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// list of application service groups
        /// </summary>
        [Input("appServiceGroups")]
        public Input<Inputs.TrafficCaptureRulesAppServiceGroupsArgs>? AppServiceGroups { get; set; }

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Input("defaultRule")]
        public Input<bool>? DefaultRule { get; set; }

        /// <summary>
        /// list of departments for which rule must be applied
        /// </summary>
        [Input("departments")]
        public Input<Inputs.TrafficCaptureRulesDepartmentsArgs>? Departments { get; set; }

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("destAddresses")]
        private InputList<string>? _destAddresses;

        /// <summary>
        /// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        /// </summary>
        public InputList<string> DestAddresses
        {
            get => _destAddresses ?? (_destAddresses = new InputList<string>());
            set => _destAddresses = value;
        }

        [Input("destCountries")]
        private InputList<string>? _destCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> DestCountries
        {
            get => _destCountries ?? (_destCountries = new InputList<string>());
            set => _destCountries = value;
        }

        [Input("destIpCategories")]
        private InputList<string>? _destIpCategories;
        public InputList<string> DestIpCategories
        {
            get => _destIpCategories ?? (_destIpCategories = new InputList<string>());
            set => _destIpCategories = value;
        }

        /// <summary>
        /// list of destination ip groups
        /// </summary>
        [Input("destIpGroups")]
        public Input<Inputs.TrafficCaptureRulesDestIpGroupsArgs>? DestIpGroups { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.TrafficCaptureRulesDeviceGroupsArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.TrafficCaptureRulesDevicesArgs>? Devices { get; set; }

        /// <summary>
        /// list of groups for which rule must be applied
        /// </summary>
        [Input("groups")]
        public Input<Inputs.TrafficCaptureRulesGroupsArgs>? Groups { get; set; }

        /// <summary>
        /// list of Labels that are applicable to the rule.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.TrafficCaptureRulesLabelsArgs>? Labels { get; set; }

        /// <summary>
        /// list of locations groups
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.TrafficCaptureRulesLocationGroupsArgs>? LocationGroups { get; set; }

        /// <summary>
        /// list of locations for which rule must be applied
        /// </summary>
        [Input("locations")]
        public Input<Inputs.TrafficCaptureRulesLocationsArgs>? Locations { get; set; }

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// list of nw application groups
        /// </summary>
        [Input("nwApplicationGroups")]
        public Input<Inputs.TrafficCaptureRulesNwApplicationGroupsArgs>? NwApplicationGroups { get; set; }

        [Input("nwApplications")]
        private InputList<string>? _nwApplications;
        public InputList<string> NwApplications
        {
            get => _nwApplications ?? (_nwApplications = new InputList<string>());
            set => _nwApplications = value;
        }

        /// <summary>
        /// list of nw service groups
        /// </summary>
        [Input("nwServiceGroups")]
        public Input<Inputs.TrafficCaptureRulesNwServiceGroupsArgs>? NwServiceGroups { get; set; }

        /// <summary>
        /// list of nw services
        /// </summary>
        [Input("nwServices")]
        public Input<Inputs.TrafficCaptureRulesNwServicesArgs>? NwServices { get; set; }

        /// <summary>
        /// Rule order number. If omitted, the rule will be added to the end of the rule set.
        /// </summary>
        [Input("order", required: true)]
        public Input<int> Order { get; set; } = null!;

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Input("predefined")]
        public Input<bool>? Predefined { get; set; }

        /// <summary>
        /// Admin rank of the Firewall Filtering policy rule
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("sourceCountries")]
        private InputList<string>? _sourceCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> SourceCountries
        {
            get => _sourceCountries ?? (_sourceCountries = new InputList<string>());
            set => _sourceCountries = value;
        }

        /// <summary>
        /// list of source ip groups
        /// </summary>
        [Input("srcIpGroups")]
        public Input<Inputs.TrafficCaptureRulesSrcIpGroupsArgs>? SrcIpGroups { get; set; }

        [Input("srcIps")]
        private InputList<string>? _srcIps;

        /// <summary>
        /// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        /// </summary>
        public InputList<string> SrcIps
        {
            get => _srcIps ?? (_srcIps = new InputList<string>());
            set => _srcIps = value;
        }

        /// <summary>
        /// Determines whether the Firewall Filtering policy rule is enabled or disabled
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.TrafficCaptureRulesTimeWindowsArgs>? TimeWindows { get; set; }

        /// <summary>
        /// The percentage of connections sampled for capturing each time the rule is triggered
        /// </summary>
        [Input("txnSampling")]
        public Input<string>? TxnSampling { get; set; }

        /// <summary>
        /// The maximum size of traffic to capture per connection
        /// </summary>
        [Input("txnSizeLimit")]
        public Input<string>? TxnSizeLimit { get; set; }

        /// <summary>
        /// list of users for which rule must be applied
        /// </summary>
        [Input("users")]
        public Input<Inputs.TrafficCaptureRulesUsersArgs>? Users { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.TrafficCaptureRulesWorkloadGroupArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.TrafficCaptureRulesWorkloadGroupArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.TrafficCaptureRulesWorkloadGroupArgs>());
            set => _workloadGroups = value;
        }

        public TrafficCaptureRulesArgs()
        {
        }
        public static new TrafficCaptureRulesArgs Empty => new TrafficCaptureRulesArgs();
    }

    public sealed class TrafficCaptureRulesState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The action to be enforced when the traffic matches the rule criteria
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// list of application service groups
        /// </summary>
        [Input("appServiceGroups")]
        public Input<Inputs.TrafficCaptureRulesAppServiceGroupsGetArgs>? AppServiceGroups { get; set; }

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Input("defaultRule")]
        public Input<bool>? DefaultRule { get; set; }

        /// <summary>
        /// list of departments for which rule must be applied
        /// </summary>
        [Input("departments")]
        public Input<Inputs.TrafficCaptureRulesDepartmentsGetArgs>? Departments { get; set; }

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("destAddresses")]
        private InputList<string>? _destAddresses;

        /// <summary>
        /// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        /// </summary>
        public InputList<string> DestAddresses
        {
            get => _destAddresses ?? (_destAddresses = new InputList<string>());
            set => _destAddresses = value;
        }

        [Input("destCountries")]
        private InputList<string>? _destCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> DestCountries
        {
            get => _destCountries ?? (_destCountries = new InputList<string>());
            set => _destCountries = value;
        }

        [Input("destIpCategories")]
        private InputList<string>? _destIpCategories;
        public InputList<string> DestIpCategories
        {
            get => _destIpCategories ?? (_destIpCategories = new InputList<string>());
            set => _destIpCategories = value;
        }

        /// <summary>
        /// list of destination ip groups
        /// </summary>
        [Input("destIpGroups")]
        public Input<Inputs.TrafficCaptureRulesDestIpGroupsGetArgs>? DestIpGroups { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.TrafficCaptureRulesDeviceGroupsGetArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.TrafficCaptureRulesDevicesGetArgs>? Devices { get; set; }

        /// <summary>
        /// list of groups for which rule must be applied
        /// </summary>
        [Input("groups")]
        public Input<Inputs.TrafficCaptureRulesGroupsGetArgs>? Groups { get; set; }

        /// <summary>
        /// list of Labels that are applicable to the rule.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.TrafficCaptureRulesLabelsGetArgs>? Labels { get; set; }

        /// <summary>
        /// list of locations groups
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.TrafficCaptureRulesLocationGroupsGetArgs>? LocationGroups { get; set; }

        /// <summary>
        /// list of locations for which rule must be applied
        /// </summary>
        [Input("locations")]
        public Input<Inputs.TrafficCaptureRulesLocationsGetArgs>? Locations { get; set; }

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// list of nw application groups
        /// </summary>
        [Input("nwApplicationGroups")]
        public Input<Inputs.TrafficCaptureRulesNwApplicationGroupsGetArgs>? NwApplicationGroups { get; set; }

        [Input("nwApplications")]
        private InputList<string>? _nwApplications;
        public InputList<string> NwApplications
        {
            get => _nwApplications ?? (_nwApplications = new InputList<string>());
            set => _nwApplications = value;
        }

        /// <summary>
        /// list of nw service groups
        /// </summary>
        [Input("nwServiceGroups")]
        public Input<Inputs.TrafficCaptureRulesNwServiceGroupsGetArgs>? NwServiceGroups { get; set; }

        /// <summary>
        /// list of nw services
        /// </summary>
        [Input("nwServices")]
        public Input<Inputs.TrafficCaptureRulesNwServicesGetArgs>? NwServices { get; set; }

        /// <summary>
        /// Rule order number. If omitted, the rule will be added to the end of the rule set.
        /// </summary>
        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Input("predefined")]
        public Input<bool>? Predefined { get; set; }

        /// <summary>
        /// Admin rank of the Firewall Filtering policy rule
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("ruleId")]
        public Input<int>? RuleId { get; set; }

        [Input("sourceCountries")]
        private InputList<string>? _sourceCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> SourceCountries
        {
            get => _sourceCountries ?? (_sourceCountries = new InputList<string>());
            set => _sourceCountries = value;
        }

        /// <summary>
        /// list of source ip groups
        /// </summary>
        [Input("srcIpGroups")]
        public Input<Inputs.TrafficCaptureRulesSrcIpGroupsGetArgs>? SrcIpGroups { get; set; }

        [Input("srcIps")]
        private InputList<string>? _srcIps;

        /// <summary>
        /// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        /// </summary>
        public InputList<string> SrcIps
        {
            get => _srcIps ?? (_srcIps = new InputList<string>());
            set => _srcIps = value;
        }

        /// <summary>
        /// Determines whether the Firewall Filtering policy rule is enabled or disabled
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.TrafficCaptureRulesTimeWindowsGetArgs>? TimeWindows { get; set; }

        /// <summary>
        /// The percentage of connections sampled for capturing each time the rule is triggered
        /// </summary>
        [Input("txnSampling")]
        public Input<string>? TxnSampling { get; set; }

        /// <summary>
        /// The maximum size of traffic to capture per connection
        /// </summary>
        [Input("txnSizeLimit")]
        public Input<string>? TxnSizeLimit { get; set; }

        /// <summary>
        /// list of users for which rule must be applied
        /// </summary>
        [Input("users")]
        public Input<Inputs.TrafficCaptureRulesUsersGetArgs>? Users { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.TrafficCaptureRulesWorkloadGroupGetArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.TrafficCaptureRulesWorkloadGroupGetArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.TrafficCaptureRulesWorkloadGroupGetArgs>());
            set => _workloadGroups = value;
        }

        public TrafficCaptureRulesState()
        {
        }
        public static new TrafficCaptureRulesState Empty => new TrafficCaptureRulesState();
    }
}

// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace zscaler.PulumiPackage.Zia
{
    /// <summary>
    /// * [Official documentation](https://help.zscaler.com/zia/firewall-policies#/firewallFilteringRules-post)
    /// * [API documentation](https://help.zscaler.com/zia/firewall-policies#/firewallFilteringRules-post)
    /// 
    /// The **zia_firewall_filtering_rule** resource allows the creation and management of ZIA Cloud Firewall filtering rules in the Zscaler Internet Access.
    /// 
    /// **NOTE 1** Zscaler Cloud Firewall contain default and predefined rules which cannot be deleted (not all attributes are supported on predefined rules). The provider **automatically handles predefined rules** during rule ordering. You can simply use sequential order values (1, 2, 3...) and the provider will:
    /// 
    /// * Automatically place new rules at the correct position
    /// * Handle reordering around predefined rules
    /// * Avoid configuration drift
    /// 
    /// Example: If there are predefined rules in your tenant, you can still configure your rules starting at `order = 1`. The provider will automatically handle the reordering to place your rules in the correct position relative to predefined rules.
    /// 
    /// **NOTE 2** Certain attributes on &lt;span pulumi-lang-nodejs="`predefined`" pulumi-lang-dotnet="`Predefined`" pulumi-lang-go="`predefined`" pulumi-lang-python="`predefined`" pulumi-lang-yaml="`predefined`" pulumi-lang-java="`predefined`"&gt;`predefined`&lt;/span&gt; rules can still be managed or updated via Terraform such as:
    /// 
    /// * &lt;span pulumi-lang-nodejs="`description`" pulumi-lang-dotnet="`Description`" pulumi-lang-go="`description`" pulumi-lang-python="`description`" pulumi-lang-yaml="`description`" pulumi-lang-java="`description`"&gt;`description`&lt;/span&gt; - (Optional) Enter additional notes or information. The description cannot exceed 10,240 characters.
    /// * &lt;span pulumi-lang-nodejs="`state`" pulumi-lang-dotnet="`State`" pulumi-lang-go="`state`" pulumi-lang-python="`state`" pulumi-lang-yaml="`state`" pulumi-lang-java="`state`"&gt;`state`&lt;/span&gt; - (Optional) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
    /// * &lt;span pulumi-lang-nodejs="`order`" pulumi-lang-dotnet="`Order`" pulumi-lang-go="`order`" pulumi-lang-python="`order`" pulumi-lang-yaml="`order`" pulumi-lang-java="`order`"&gt;`order`&lt;/span&gt; - (Optional) Rule order number of the Firewall Filtering policy rule
    /// 
    /// * &lt;span pulumi-lang-nodejs="`labels`" pulumi-lang-dotnet="`Labels`" pulumi-lang-go="`labels`" pulumi-lang-python="`labels`" pulumi-lang-yaml="`labels`" pulumi-lang-java="`labels`"&gt;`labels`&lt;/span&gt; (list) - Labels that are applicable to the rule.
    ///     * &lt;span pulumi-lang-nodejs="`id`" pulumi-lang-dotnet="`Id`" pulumi-lang-go="`id`" pulumi-lang-python="`id`" pulumi-lang-yaml="`id`" pulumi-lang-java="`id`"&gt;`id`&lt;/span&gt; - (Integer) Identifier that uniquely identifies an entity
    /// 
    /// **NOTE 3** The following attributes on &lt;span pulumi-lang-nodejs="`predefined`" pulumi-lang-dotnet="`Predefined`" pulumi-lang-go="`predefined`" pulumi-lang-python="`predefined`" pulumi-lang-yaml="`predefined`" pulumi-lang-java="`predefined`"&gt;`predefined`&lt;/span&gt; rules **cannot** be updated:
    /// 
    /// * &lt;span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`"&gt;`name`&lt;/span&gt; - Name of the Firewall Filtering policy rule
    /// * &lt;span pulumi-lang-nodejs="`action`" pulumi-lang-dotnet="`Action`" pulumi-lang-go="`action`" pulumi-lang-python="`action`" pulumi-lang-yaml="`action`" pulumi-lang-java="`action`"&gt;`action`&lt;/span&gt; - The action the Firewall Filtering policy rule takes when packets match the rule. Supported Values: `ALLOW`, `BLOCK_DROP`, `BLOCK_RESET`, `BLOCK_ICMP`, `EVAL_NWAPP`
    /// * &lt;span pulumi-lang-nodejs="`rank`" pulumi-lang-dotnet="`Rank`" pulumi-lang-go="`rank`" pulumi-lang-python="`rank`" pulumi-lang-yaml="`rank`" pulumi-lang-java="`rank`"&gt;`rank`&lt;/span&gt; - (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank in UI first. The default value is &lt;span pulumi-lang-nodejs="`7`" pulumi-lang-dotnet="`7`" pulumi-lang-go="`7`" pulumi-lang-python="`7`" pulumi-lang-yaml="`7`" pulumi-lang-java="`7`"&gt;`7`&lt;/span&gt;. Visit to learn more [About Admin Rank](https://help.zscaler.com/zia/about-admin-rank)
    /// * Most other attributes that define the rule's behavior
    /// 
    /// **NOTE 4** The import of &lt;span pulumi-lang-nodejs="`predefined`" pulumi-lang-dotnet="`Predefined`" pulumi-lang-go="`predefined`" pulumi-lang-python="`predefined`" pulumi-lang-yaml="`predefined`" pulumi-lang-java="`predefined`"&gt;`predefined`&lt;/span&gt; rules is still possible in case you want o have them under the Terraform management; however, remember that these rules cannot be deleted. That means, the provider will fail when executing `terraform destroy`; hence, you must remove the rules you want to delete, and re-run `pulumi up` instead.
    /// 
    /// ## Example Usage
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// Visit
    /// 
    /// **zia_firewall_filtering_rule** can be imported by using `&lt;RULE ID&gt;` or `&lt;RULE NAME&gt;` as the import ID.
    /// 
    /// For example:
    /// 
    /// ```sh
    /// $ pulumi import zia:index/firewallFilteringRule:FirewallFilteringRule example &lt;rule_id&gt;
    /// ```
    /// 
    /// or
    /// 
    /// ```sh
    /// $ pulumi import zia:index/firewallFilteringRule:FirewallFilteringRule example &lt;rule_name&gt;
    /// ```
    /// </summary>
    [ZiaResourceType("zia:index/firewallFilteringRule:FirewallFilteringRule")]
    public partial class FirewallFilteringRule : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The action the Firewall Filtering policy rule takes when packets match the rule
        /// </summary>
        [Output("action")]
        public Output<string?> Action { get; private set; } = null!;

        /// <summary>
        /// list of application service groups
        /// </summary>
        [Output("appServiceGroups")]
        public Output<Outputs.FirewallFilteringRuleAppServiceGroups?> AppServiceGroups { get; private set; } = null!;

        /// <summary>
        /// list of application services
        /// </summary>
        [Output("appServices")]
        public Output<Outputs.FirewallFilteringRuleAppServices?> AppServices { get; private set; } = null!;

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Output("defaultRule")]
        public Output<bool?> DefaultRule { get; private set; } = null!;

        /// <summary>
        /// list of departments for which rule must be applied
        /// </summary>
        [Output("departments")]
        public Output<Outputs.FirewallFilteringRuleDepartments?> Departments { get; private set; } = null!;

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        /// </summary>
        [Output("destAddresses")]
        public Output<ImmutableArray<string>> DestAddresses { get; private set; } = null!;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        [Output("destCountries")]
        public Output<ImmutableArray<string>> DestCountries { get; private set; } = null!;

        [Output("destIpCategories")]
        public Output<ImmutableArray<string>> DestIpCategories { get; private set; } = null!;

        /// <summary>
        /// list of destination ip groups
        /// </summary>
        [Output("destIpGroups")]
        public Output<Outputs.FirewallFilteringRuleDestIpGroups?> DestIpGroups { get; private set; } = null!;

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Output("deviceGroups")]
        public Output<Outputs.FirewallFilteringRuleDeviceGroups?> DeviceGroups { get; private set; } = null!;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        [Output("deviceTrustLevels")]
        public Output<ImmutableArray<string>> DeviceTrustLevels { get; private set; } = null!;

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Output("devices")]
        public Output<Outputs.FirewallFilteringRuleDevices?> Devices { get; private set; } = null!;

        [Output("enableFullLogging")]
        public Output<bool?> EnableFullLogging { get; private set; } = null!;

        [Output("excludeSrcCountries")]
        public Output<bool?> ExcludeSrcCountries { get; private set; } = null!;

        /// <summary>
        /// list of groups for which rule must be applied
        /// </summary>
        [Output("groups")]
        public Output<Outputs.FirewallFilteringRuleGroups?> Groups { get; private set; } = null!;

        /// <summary>
        /// list of Labels that are applicable to the rule.
        /// </summary>
        [Output("labels")]
        public Output<Outputs.FirewallFilteringRuleLabels?> Labels { get; private set; } = null!;

        /// <summary>
        /// list of locations groups
        /// </summary>
        [Output("locationGroups")]
        public Output<Outputs.FirewallFilteringRuleLocationGroups?> LocationGroups { get; private set; } = null!;

        /// <summary>
        /// list of locations for which rule must be applied
        /// </summary>
        [Output("locations")]
        public Output<Outputs.FirewallFilteringRuleLocations?> Locations { get; private set; } = null!;

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// list of nw application groups
        /// </summary>
        [Output("nwApplicationGroups")]
        public Output<Outputs.FirewallFilteringRuleNwApplicationGroups?> NwApplicationGroups { get; private set; } = null!;

        [Output("nwApplications")]
        public Output<ImmutableArray<string>> NwApplications { get; private set; } = null!;

        /// <summary>
        /// list of nw service groups
        /// </summary>
        [Output("nwServiceGroups")]
        public Output<Outputs.FirewallFilteringRuleNwServiceGroups?> NwServiceGroups { get; private set; } = null!;

        /// <summary>
        /// list of nw services
        /// </summary>
        [Output("nwServices")]
        public Output<Outputs.FirewallFilteringRuleNwServices?> NwServices { get; private set; } = null!;

        /// <summary>
        /// Rule order number. If omitted, the rule will be added to the end of the rule set.
        /// </summary>
        [Output("order")]
        public Output<int> Order { get; private set; } = null!;

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Output("predefined")]
        public Output<bool?> Predefined { get; private set; } = null!;

        /// <summary>
        /// Admin rank of the Firewall Filtering policy rule
        /// </summary>
        [Output("rank")]
        public Output<int?> Rank { get; private set; } = null!;

        [Output("ruleId")]
        public Output<int> RuleId { get; private set; } = null!;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        [Output("sourceCountries")]
        public Output<ImmutableArray<string>> SourceCountries { get; private set; } = null!;

        /// <summary>
        /// list of source ip groups
        /// </summary>
        [Output("srcIpGroups")]
        public Output<Outputs.FirewallFilteringRuleSrcIpGroups?> SrcIpGroups { get; private set; } = null!;

        /// <summary>
        /// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        /// </summary>
        [Output("srcIps")]
        public Output<ImmutableArray<string>> SrcIps { get; private set; } = null!;

        /// <summary>
        /// Determines whether the Firewall Filtering policy rule is enabled or disabled
        /// </summary>
        [Output("state")]
        public Output<string?> State { get; private set; } = null!;

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Output("timeWindows")]
        public Output<Outputs.FirewallFilteringRuleTimeWindows?> TimeWindows { get; private set; } = null!;

        /// <summary>
        /// list of users for which rule must be applied
        /// </summary>
        [Output("users")]
        public Output<Outputs.FirewallFilteringRuleUsers?> Users { get; private set; } = null!;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        [Output("workloadGroups")]
        public Output<ImmutableArray<Outputs.FirewallFilteringRuleWorkloadGroup>> WorkloadGroups { get; private set; } = null!;

        /// <summary>
        /// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA Gateway forwarding method.
        /// </summary>
        [Output("zpaAppSegments")]
        public Output<ImmutableArray<Outputs.FirewallFilteringRuleZpaAppSegment>> ZpaAppSegments { get; private set; } = null!;


        /// <summary>
        /// Create a FirewallFilteringRule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public FirewallFilteringRule(string name, FirewallFilteringRuleArgs args, CustomResourceOptions? options = null)
            : base("zia:index/firewallFilteringRule:FirewallFilteringRule", name, args ?? new FirewallFilteringRuleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private FirewallFilteringRule(string name, Input<string> id, FirewallFilteringRuleState? state = null, CustomResourceOptions? options = null)
            : base("zia:index/firewallFilteringRule:FirewallFilteringRule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing FirewallFilteringRule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static FirewallFilteringRule Get(string name, Input<string> id, FirewallFilteringRuleState? state = null, CustomResourceOptions? options = null)
        {
            return new FirewallFilteringRule(name, id, state, options);
        }
    }

    public sealed class FirewallFilteringRuleArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The action the Firewall Filtering policy rule takes when packets match the rule
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// list of application service groups
        /// </summary>
        [Input("appServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleAppServiceGroupsArgs>? AppServiceGroups { get; set; }

        /// <summary>
        /// list of application services
        /// </summary>
        [Input("appServices")]
        public Input<Inputs.FirewallFilteringRuleAppServicesArgs>? AppServices { get; set; }

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Input("defaultRule")]
        public Input<bool>? DefaultRule { get; set; }

        /// <summary>
        /// list of departments for which rule must be applied
        /// </summary>
        [Input("departments")]
        public Input<Inputs.FirewallFilteringRuleDepartmentsArgs>? Departments { get; set; }

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("destAddresses")]
        private InputList<string>? _destAddresses;

        /// <summary>
        /// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        /// </summary>
        public InputList<string> DestAddresses
        {
            get => _destAddresses ?? (_destAddresses = new InputList<string>());
            set => _destAddresses = value;
        }

        [Input("destCountries")]
        private InputList<string>? _destCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> DestCountries
        {
            get => _destCountries ?? (_destCountries = new InputList<string>());
            set => _destCountries = value;
        }

        [Input("destIpCategories")]
        private InputList<string>? _destIpCategories;
        public InputList<string> DestIpCategories
        {
            get => _destIpCategories ?? (_destIpCategories = new InputList<string>());
            set => _destIpCategories = value;
        }

        /// <summary>
        /// list of destination ip groups
        /// </summary>
        [Input("destIpGroups")]
        public Input<Inputs.FirewallFilteringRuleDestIpGroupsArgs>? DestIpGroups { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.FirewallFilteringRuleDeviceGroupsArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.FirewallFilteringRuleDevicesArgs>? Devices { get; set; }

        [Input("enableFullLogging")]
        public Input<bool>? EnableFullLogging { get; set; }

        [Input("excludeSrcCountries")]
        public Input<bool>? ExcludeSrcCountries { get; set; }

        /// <summary>
        /// list of groups for which rule must be applied
        /// </summary>
        [Input("groups")]
        public Input<Inputs.FirewallFilteringRuleGroupsArgs>? Groups { get; set; }

        /// <summary>
        /// list of Labels that are applicable to the rule.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.FirewallFilteringRuleLabelsArgs>? Labels { get; set; }

        /// <summary>
        /// list of locations groups
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.FirewallFilteringRuleLocationGroupsArgs>? LocationGroups { get; set; }

        /// <summary>
        /// list of locations for which rule must be applied
        /// </summary>
        [Input("locations")]
        public Input<Inputs.FirewallFilteringRuleLocationsArgs>? Locations { get; set; }

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// list of nw application groups
        /// </summary>
        [Input("nwApplicationGroups")]
        public Input<Inputs.FirewallFilteringRuleNwApplicationGroupsArgs>? NwApplicationGroups { get; set; }

        [Input("nwApplications")]
        private InputList<string>? _nwApplications;
        public InputList<string> NwApplications
        {
            get => _nwApplications ?? (_nwApplications = new InputList<string>());
            set => _nwApplications = value;
        }

        /// <summary>
        /// list of nw service groups
        /// </summary>
        [Input("nwServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleNwServiceGroupsArgs>? NwServiceGroups { get; set; }

        /// <summary>
        /// list of nw services
        /// </summary>
        [Input("nwServices")]
        public Input<Inputs.FirewallFilteringRuleNwServicesArgs>? NwServices { get; set; }

        /// <summary>
        /// Rule order number. If omitted, the rule will be added to the end of the rule set.
        /// </summary>
        [Input("order", required: true)]
        public Input<int> Order { get; set; } = null!;

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Input("predefined")]
        public Input<bool>? Predefined { get; set; }

        /// <summary>
        /// Admin rank of the Firewall Filtering policy rule
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("sourceCountries")]
        private InputList<string>? _sourceCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> SourceCountries
        {
            get => _sourceCountries ?? (_sourceCountries = new InputList<string>());
            set => _sourceCountries = value;
        }

        /// <summary>
        /// list of source ip groups
        /// </summary>
        [Input("srcIpGroups")]
        public Input<Inputs.FirewallFilteringRuleSrcIpGroupsArgs>? SrcIpGroups { get; set; }

        [Input("srcIps")]
        private InputList<string>? _srcIps;

        /// <summary>
        /// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        /// </summary>
        public InputList<string> SrcIps
        {
            get => _srcIps ?? (_srcIps = new InputList<string>());
            set => _srcIps = value;
        }

        /// <summary>
        /// Determines whether the Firewall Filtering policy rule is enabled or disabled
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.FirewallFilteringRuleTimeWindowsArgs>? TimeWindows { get; set; }

        /// <summary>
        /// list of users for which rule must be applied
        /// </summary>
        [Input("users")]
        public Input<Inputs.FirewallFilteringRuleUsersArgs>? Users { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.FirewallFilteringRuleWorkloadGroupArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleWorkloadGroupArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.FirewallFilteringRuleWorkloadGroupArgs>());
            set => _workloadGroups = value;
        }

        [Input("zpaAppSegments")]
        private InputList<Inputs.FirewallFilteringRuleZpaAppSegmentArgs>? _zpaAppSegments;

        /// <summary>
        /// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA Gateway forwarding method.
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleZpaAppSegmentArgs> ZpaAppSegments
        {
            get => _zpaAppSegments ?? (_zpaAppSegments = new InputList<Inputs.FirewallFilteringRuleZpaAppSegmentArgs>());
            set => _zpaAppSegments = value;
        }

        public FirewallFilteringRuleArgs()
        {
        }
        public static new FirewallFilteringRuleArgs Empty => new FirewallFilteringRuleArgs();
    }

    public sealed class FirewallFilteringRuleState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The action the Firewall Filtering policy rule takes when packets match the rule
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// list of application service groups
        /// </summary>
        [Input("appServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleAppServiceGroupsGetArgs>? AppServiceGroups { get; set; }

        /// <summary>
        /// list of application services
        /// </summary>
        [Input("appServices")]
        public Input<Inputs.FirewallFilteringRuleAppServicesGetArgs>? AppServices { get; set; }

        /// <summary>
        /// If set to true, the default rule is applied
        /// </summary>
        [Input("defaultRule")]
        public Input<bool>? DefaultRule { get; set; }

        /// <summary>
        /// list of departments for which rule must be applied
        /// </summary>
        [Input("departments")]
        public Input<Inputs.FirewallFilteringRuleDepartmentsGetArgs>? Departments { get; set; }

        /// <summary>
        /// Additional information about the rule
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("destAddresses")]
        private InputList<string>? _destAddresses;

        /// <summary>
        /// Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        /// </summary>
        public InputList<string> DestAddresses
        {
            get => _destAddresses ?? (_destAddresses = new InputList<string>());
            set => _destAddresses = value;
        }

        [Input("destCountries")]
        private InputList<string>? _destCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> DestCountries
        {
            get => _destCountries ?? (_destCountries = new InputList<string>());
            set => _destCountries = value;
        }

        [Input("destIpCategories")]
        private InputList<string>? _destIpCategories;
        public InputList<string> DestIpCategories
        {
            get => _destIpCategories ?? (_destIpCategories = new InputList<string>());
            set => _destIpCategories = value;
        }

        /// <summary>
        /// list of destination ip groups
        /// </summary>
        [Input("destIpGroups")]
        public Input<Inputs.FirewallFilteringRuleDestIpGroupsGetArgs>? DestIpGroups { get; set; }

        /// <summary>
        /// This field is applicable for devices that are managed using Zscaler Client Connector.
        /// </summary>
        [Input("deviceGroups")]
        public Input<Inputs.FirewallFilteringRuleDeviceGroupsGetArgs>? DeviceGroups { get; set; }

        [Input("deviceTrustLevels")]
        private InputList<string>? _deviceTrustLevels;

        /// <summary>
        /// List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        /// </summary>
        public InputList<string> DeviceTrustLevels
        {
            get => _deviceTrustLevels ?? (_deviceTrustLevels = new InputList<string>());
            set => _deviceTrustLevels = value;
        }

        /// <summary>
        /// Name-ID pairs of devices for which rule must be applied.
        /// </summary>
        [Input("devices")]
        public Input<Inputs.FirewallFilteringRuleDevicesGetArgs>? Devices { get; set; }

        [Input("enableFullLogging")]
        public Input<bool>? EnableFullLogging { get; set; }

        [Input("excludeSrcCountries")]
        public Input<bool>? ExcludeSrcCountries { get; set; }

        /// <summary>
        /// list of groups for which rule must be applied
        /// </summary>
        [Input("groups")]
        public Input<Inputs.FirewallFilteringRuleGroupsGetArgs>? Groups { get; set; }

        /// <summary>
        /// list of Labels that are applicable to the rule.
        /// </summary>
        [Input("labels")]
        public Input<Inputs.FirewallFilteringRuleLabelsGetArgs>? Labels { get; set; }

        /// <summary>
        /// list of locations groups
        /// </summary>
        [Input("locationGroups")]
        public Input<Inputs.FirewallFilteringRuleLocationGroupsGetArgs>? LocationGroups { get; set; }

        /// <summary>
        /// list of locations for which rule must be applied
        /// </summary>
        [Input("locations")]
        public Input<Inputs.FirewallFilteringRuleLocationsGetArgs>? Locations { get; set; }

        /// <summary>
        /// Name of the Firewall Filtering policy rule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// list of nw application groups
        /// </summary>
        [Input("nwApplicationGroups")]
        public Input<Inputs.FirewallFilteringRuleNwApplicationGroupsGetArgs>? NwApplicationGroups { get; set; }

        [Input("nwApplications")]
        private InputList<string>? _nwApplications;
        public InputList<string> NwApplications
        {
            get => _nwApplications ?? (_nwApplications = new InputList<string>());
            set => _nwApplications = value;
        }

        /// <summary>
        /// list of nw service groups
        /// </summary>
        [Input("nwServiceGroups")]
        public Input<Inputs.FirewallFilteringRuleNwServiceGroupsGetArgs>? NwServiceGroups { get; set; }

        /// <summary>
        /// list of nw services
        /// </summary>
        [Input("nwServices")]
        public Input<Inputs.FirewallFilteringRuleNwServicesGetArgs>? NwServices { get; set; }

        /// <summary>
        /// Rule order number. If omitted, the rule will be added to the end of the rule set.
        /// </summary>
        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// If set to true, a predefined rule is applied
        /// </summary>
        [Input("predefined")]
        public Input<bool>? Predefined { get; set; }

        /// <summary>
        /// Admin rank of the Firewall Filtering policy rule
        /// </summary>
        [Input("rank")]
        public Input<int>? Rank { get; set; }

        [Input("ruleId")]
        public Input<int>? RuleId { get; set; }

        [Input("sourceCountries")]
        private InputList<string>? _sourceCountries;

        /// <summary>
        /// Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        /// </summary>
        public InputList<string> SourceCountries
        {
            get => _sourceCountries ?? (_sourceCountries = new InputList<string>());
            set => _sourceCountries = value;
        }

        /// <summary>
        /// list of source ip groups
        /// </summary>
        [Input("srcIpGroups")]
        public Input<Inputs.FirewallFilteringRuleSrcIpGroupsGetArgs>? SrcIpGroups { get; set; }

        [Input("srcIps")]
        private InputList<string>? _srcIps;

        /// <summary>
        /// User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        /// </summary>
        public InputList<string> SrcIps
        {
            get => _srcIps ?? (_srcIps = new InputList<string>());
            set => _srcIps = value;
        }

        /// <summary>
        /// Determines whether the Firewall Filtering policy rule is enabled or disabled
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// The time interval in which the Firewall Filtering policy rule applies
        /// </summary>
        [Input("timeWindows")]
        public Input<Inputs.FirewallFilteringRuleTimeWindowsGetArgs>? TimeWindows { get; set; }

        /// <summary>
        /// list of users for which rule must be applied
        /// </summary>
        [Input("users")]
        public Input<Inputs.FirewallFilteringRuleUsersGetArgs>? Users { get; set; }

        [Input("workloadGroups")]
        private InputList<Inputs.FirewallFilteringRuleWorkloadGroupGetArgs>? _workloadGroups;

        /// <summary>
        /// The list of preconfigured workload groups to which the policy must be applied
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleWorkloadGroupGetArgs> WorkloadGroups
        {
            get => _workloadGroups ?? (_workloadGroups = new InputList<Inputs.FirewallFilteringRuleWorkloadGroupGetArgs>());
            set => _workloadGroups = value;
        }

        [Input("zpaAppSegments")]
        private InputList<Inputs.FirewallFilteringRuleZpaAppSegmentGetArgs>? _zpaAppSegments;

        /// <summary>
        /// The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA Gateway forwarding method.
        /// </summary>
        public InputList<Inputs.FirewallFilteringRuleZpaAppSegmentGetArgs> ZpaAppSegments
        {
            get => _zpaAppSegments ?? (_zpaAppSegments = new InputList<Inputs.FirewallFilteringRuleZpaAppSegmentGetArgs>());
            set => _zpaAppSegments = value;
        }

        public FirewallFilteringRuleState()
        {
        }
        public static new FirewallFilteringRuleState Empty => new FirewallFilteringRuleState();
    }
}

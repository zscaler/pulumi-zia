// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace zscaler.PulumiPackage.Zia
{
    /// <summary>
    /// * [Official documentation](https://help.zscaler.com/zia/configuring-advanced-settings)
    /// * [API documentation](https://help.zscaler.com/zia/advanced-settings#/advancedSettings-get)
    /// 
    /// The **zia_advanced_settings** resource alows you to updates the advanced settings configuration in the ZIA Admin Portal. To learn more see [Configuring Advanced Settings](https://help.zscaler.com/zia/configuring-advanced-settings)
    /// 
    /// ## Example Usage
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// 
    /// Visit
    /// 
    /// **zia_advanced_settings** can be imported by using `advanced_settings` as the import ID.
    /// 
    /// For example:
    /// 
    /// ```sh
    /// $ pulumi import zia:index/advancedSettings:AdvancedSettings this "advanced_settings"
    /// ```
    /// </summary>
    [ZiaResourceType("zia:index/advancedSettings:AdvancedSettings")]
    public partial class AdvancedSettings : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Cloud applications that are exempted from cookie authentication
        /// </summary>
        [Output("authBypassApps")]
        public Output<ImmutableArray<string>> AuthBypassApps { get; private set; } = null!;

        /// <summary>
        /// URL categories that are exempted from cookie authentication
        /// </summary>
        [Output("authBypassUrlCategories")]
        public Output<ImmutableArray<string>> AuthBypassUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Custom URLs that are exempted from cookie authentication for users
        /// </summary>
        [Output("authBypassUrls")]
        public Output<ImmutableArray<string>> AuthBypassUrls { get; private set; } = null!;

        /// <summary>
        /// Cloud applications that are exempted from Basic authentication
        /// </summary>
        [Output("basicBypassApps")]
        public Output<ImmutableArray<string>> BasicBypassApps { get; private set; } = null!;

        /// <summary>
        /// URL categories that are exempted from Basic authentication
        /// </summary>
        [Output("basicBypassUrlCategories")]
        public Output<ImmutableArray<string>> BasicBypassUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether CONNECT host and SNI mismatch (i.e., CONNECT host doesn't match the SSL/TLS client hello SNI)
        /// is blocked or not
        /// </summary>
        [Output("blockConnectHostSniMismatch")]
        public Output<bool> BlockConnectHostSniMismatch { get; private set; } = null!;

        /// <summary>
        /// Applications which are subjected to Domain Fronting
        /// </summary>
        [Output("blockDomainFrontingApps")]
        public Output<ImmutableArray<string>> BlockDomainFrontingApps { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to block or allow HTTP/S transactions in which the FQDN of the request URL is different than
        /// the FQDN of the request's host header
        /// </summary>
        [Output("blockDomainFrontingOnHostHeader")]
        public Output<bool> BlockDomainFrontingOnHostHeader { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether HTTP CONNECT method requests to non-standard ports are allowed or not (i.e., requests directed
        /// to ports other than the standard HTTP/S ports 80 and 443)
        /// </summary>
        [Output("blockHttpTunnelOnNonHttpPorts")]
        public Output<bool> BlockHttpTunnelOnNonHttpPorts { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to allow or block traffic that is not compliant with RFC HTTP protocol standards
        /// </summary>
        [Output("blockNonCompliantHttpRequestOnHttpPorts")]
        public Output<bool> BlockNonCompliantHttpRequestOnHttpPorts { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether non-HTTP Traffic on HTTP/S ports are allowed or blocked
        /// </summary>
        [Output("blockNonHttpOnHttpPortEnabled")]
        public Output<bool> BlockNonHttpOnHttpPortEnabled { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to apply the URL Filtering policy even when the Cloud App Control policy already allows a
        /// transaction explicitly
        /// </summary>
        [Output("cascadeUrlFiltering")]
        public Output<bool> CascadeUrlFiltering { get; private set; } = null!;

        /// <summary>
        /// Cloud applications that are exempted from Digest authentication
        /// </summary>
        [Output("digestAuthBypassApps")]
        public Output<ImmutableArray<string>> DigestAuthBypassApps { get; private set; } = null!;

        /// <summary>
        /// URL categories that are exempted from Digest authentication
        /// </summary>
        [Output("digestAuthBypassUrlCategories")]
        public Output<ImmutableArray<string>> DigestAuthBypassUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Custom URLs that are exempted from Digest authentication. Cloud applications that are exempted from Digest
        /// authentication
        /// </summary>
        [Output("digestAuthBypassUrls")]
        public Output<ImmutableArray<string>> DigestAuthBypassUrls { get; private set; } = null!;

        /// <summary>
        /// Cloud applications to which DNS optimization on transparent proxy mode applies
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyApps")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyApps { get; private set; } = null!;

        /// <summary>
        /// Cloud applications that are excluded from DNS optimization on transparent proxy mode
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyExemptApps")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyExemptApps { get; private set; } = null!;

        [Output("dnsResolutionOnTransparentProxyExemptUrlCategories")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyExemptUrlCategories { get; private set; } = null!;

        /// <summary>
        /// URLs that are excluded from DNS optimization on transparent proxy mode
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyExemptUrls")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyExemptUrls { get; private set; } = null!;

        /// <summary>
        /// Cloud applications to which DNS optimization for IPv6 addresses on transparent proxy mode applies
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyIpv6Apps")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyIpv6Apps { get; private set; } = null!;

        /// <summary>
        /// Cloud applications that are excluded from DNS optimization for IPv6 addresses on transparent proxy mode
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyIpv6ExemptApps")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyIpv6ExemptApps { get; private set; } = null!;

        [Output("dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyIpv6ExemptUrlCategories { get; private set; } = null!;

        /// <summary>
        /// IPv6 URL categories to which DNS optimization on transparent proxy mode applies
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyIpv6UrlCategories")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyIpv6UrlCategories { get; private set; } = null!;

        /// <summary>
        /// URL categories to which DNS optimization on transparent proxy mode applies
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyUrlCategories")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyUrlCategories { get; private set; } = null!;

        /// <summary>
        /// URLs to which DNS optimization on transparent proxy mode applies
        /// </summary>
        [Output("dnsResolutionOnTransparentProxyUrls")]
        public Output<ImmutableArray<string>> DnsResolutionOnTransparentProxyUrls { get; private set; } = null!;

        /// <summary>
        /// URL categories that are exempted from domain fronting
        /// </summary>
        [Output("domainFrontingBypassUrlCategories")]
        public Output<ImmutableArray<string>> DomainFrontingBypassUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to dynamically update user risk score by tracking risky user activities in real time
        /// </summary>
        [Output("dynamicUserRiskEnabled")]
        public Output<bool> DynamicUserRiskEnabled { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether or not to include the ECS option in all DNS queries, originating from all locations and remote
        /// users.
        /// </summary>
        [Output("ecsForAllEnabled")]
        public Output<bool> EcsForAllEnabled { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether ranks are enabled for admins to allow admin ranks in policy configuration and management
        /// </summary>
        [Output("enableAdminRankAccess")]
        public Output<bool> EnableAdminRankAccess { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether DNS optimization is enabled or disabled for Z-Tunnel 2.0 and transparent proxy mode traffic
        /// (e.g., traffic via GRE or IPSec tunnels without a PAC file).
        /// </summary>
        [Output("enableDnsResolutionOnTransparentProxy")]
        public Output<bool> EnableDnsResolutionOnTransparentProxy { get; private set; } = null!;

        /// <summary>
        /// Enable/Disable DNS optimization for all IPv6 transparent proxy traffic
        /// </summary>
        [Output("enableEvaluatePolicyOnGlobalSslBypass")]
        public Output<bool> EnableEvaluatePolicyOnGlobalSslBypass { get; private set; } = null!;

        /// <summary>
        /// Enable/Disable DNS optimization for all IPv6 transparent proxy traffic
        /// </summary>
        [Output("enableIpv6DnsOptimizationOnAllTransparentProxy")]
        public Output<bool> EnableIpv6DnsOptimizationOnAllTransparentProxy { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether DNS optimization is enabled or disabled for IPv6 connections to dual-stack or IPv6-only
        /// destinations sent via Z-Tunnel 2.0 and transparent proxy proxy mode (e.g., traffic via GRE or IPSec tunnels without a
        /// PAC file).
        /// </summary>
        [Output("enableIpv6DnsResolutionOnTransparentProxy")]
        public Output<bool> EnableIpv6DnsResolutionOnTransparentProxy { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether Microsoft Office 365 One Click Configuration is enabled or not
        /// </summary>
        [Output("enableOffice365")]
        public Output<bool> EnableOffice365 { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether policies that include user and department criteria can be configured and applied for
        /// unauthenticated traffic
        /// </summary>
        [Output("enablePolicyForUnauthenticatedTraffic")]
        public Output<bool> EnablePolicyForUnauthenticatedTraffic { get; private set; } = null!;

        /// <summary>
        /// Enforce Surrogate IP authentication for Windows app traffic
        /// </summary>
        [Output("enforceSurrogateIpForWindowsApp")]
        public Output<bool> EnforceSurrogateIpForWindowsApp { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether or not HTTP/2 should be the default web protocol for accessing various applications at your
        /// organizational level
        /// </summary>
        [Output("http2NonbrowserTrafficEnabled")]
        public Output<bool> Http2NonbrowserTrafficEnabled { get; private set; } = null!;

        /// <summary>
        /// URL categories for which HTTP range headers must be removed
        /// </summary>
        [Output("httpRangeHeaderRemoveUrlCategories")]
        public Output<ImmutableArray<string>> HttpRangeHeaderRemoveUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Cloud applications that are exempted from Kerberos authentication
        /// </summary>
        [Output("kerberosBypassApps")]
        public Output<ImmutableArray<string>> KerberosBypassApps { get; private set; } = null!;

        /// <summary>
        /// URL categories that are exempted from Kerberos authentication
        /// </summary>
        [Output("kerberosBypassUrlCategories")]
        public Output<ImmutableArray<string>> KerberosBypassUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Custom URLs that are exempted from Kerberos authentication
        /// </summary>
        [Output("kerberosBypassUrls")]
        public Output<ImmutableArray<string>> KerberosBypassUrls { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to log internal IP address present in X-Forwarded-For (XFF) proxy header or not
        /// </summary>
        [Output("logInternalIp")]
        public Output<bool> LogInternalIp { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether or not to use the SSL/TLS client hello SNI for DNS resolution instead of the CONNECT host for
        /// forward proxy connections
        /// </summary>
        [Output("preferSniOverConnHost")]
        public Output<bool> PreferSniOverConnHost { get; private set; } = null!;

        /// <summary>
        /// Applications that are exempted from the preferSniOverConnHost setting (i.e., prefer SSL/TLS client hello SNI for DNS
        /// resolution instead of the CONNECT host for forward proxy connections)
        /// </summary>
        [Output("preferSniOverConnHostApps")]
        public Output<ImmutableArray<string>> PreferSniOverConnHostApps { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether or not to insert XFF header to all traffic forwarded from ZIA to ZPA, including source
        /// IP-anchored and ZIA-inspected ZPA application traffic.
        /// </summary>
        [Output("sipaXffHeaderEnabled")]
        public Output<bool> SipaXffHeaderEnabled { get; private set; } = null!;

        /// <summary>
        /// URL categories that are excluded from the preferSniOverConnHost setting (i.e., prefer SSL/TLS client hello SNI for DNS
        /// resolution instead of the CONNECT host for forward proxy connections)
        /// </summary>
        [Output("sniDnsOptimizationBypassUrlCategories")]
        public Output<ImmutableArray<string>> SniDnsOptimizationBypassUrlCategories { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to apply configured policies on tunneled HTTP traffic sent via a CONNECT method request on port
        /// 80
        /// </summary>
        [Output("trackHttpTunnelOnHttpPorts")]
        public Output<bool> TrackHttpTunnelOnHttpPorts { get; private set; } = null!;

        /// <summary>
        /// Specifies the login session timeout for admins accessing the ZIA Admin Portal
        /// </summary>
        [Output("uiSessionTimeout")]
        public Output<int> UiSessionTimeout { get; private set; } = null!;

        /// <summary>
        /// Value indicating whether to apply the Firewall rules configured without a specified location criteria (or with the Road
        /// Warrior location) to remote user traffic forwarded via Z-Tunnel 1.0 or PAC files
        /// </summary>
        [Output("zscalerClientConnector1AndPacRoadWarriorInFirewall")]
        public Output<bool> ZscalerClientConnector1AndPacRoadWarriorInFirewall { get; private set; } = null!;


        /// <summary>
        /// Create a AdvancedSettings resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AdvancedSettings(string name, AdvancedSettingsArgs? args = null, CustomResourceOptions? options = null)
            : base("zia:index/advancedSettings:AdvancedSettings", name, args ?? new AdvancedSettingsArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AdvancedSettings(string name, Input<string> id, AdvancedSettingsState? state = null, CustomResourceOptions? options = null)
            : base("zia:index/advancedSettings:AdvancedSettings", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AdvancedSettings resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AdvancedSettings Get(string name, Input<string> id, AdvancedSettingsState? state = null, CustomResourceOptions? options = null)
        {
            return new AdvancedSettings(name, id, state, options);
        }
    }

    public sealed class AdvancedSettingsArgs : global::Pulumi.ResourceArgs
    {
        [Input("authBypassApps")]
        private InputList<string>? _authBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from cookie authentication
        /// </summary>
        public InputList<string> AuthBypassApps
        {
            get => _authBypassApps ?? (_authBypassApps = new InputList<string>());
            set => _authBypassApps = value;
        }

        [Input("authBypassUrlCategories")]
        private InputList<string>? _authBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from cookie authentication
        /// </summary>
        public InputList<string> AuthBypassUrlCategories
        {
            get => _authBypassUrlCategories ?? (_authBypassUrlCategories = new InputList<string>());
            set => _authBypassUrlCategories = value;
        }

        [Input("authBypassUrls")]
        private InputList<string>? _authBypassUrls;

        /// <summary>
        /// Custom URLs that are exempted from cookie authentication for users
        /// </summary>
        public InputList<string> AuthBypassUrls
        {
            get => _authBypassUrls ?? (_authBypassUrls = new InputList<string>());
            set => _authBypassUrls = value;
        }

        [Input("basicBypassApps")]
        private InputList<string>? _basicBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from Basic authentication
        /// </summary>
        public InputList<string> BasicBypassApps
        {
            get => _basicBypassApps ?? (_basicBypassApps = new InputList<string>());
            set => _basicBypassApps = value;
        }

        [Input("basicBypassUrlCategories")]
        private InputList<string>? _basicBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from Basic authentication
        /// </summary>
        public InputList<string> BasicBypassUrlCategories
        {
            get => _basicBypassUrlCategories ?? (_basicBypassUrlCategories = new InputList<string>());
            set => _basicBypassUrlCategories = value;
        }

        /// <summary>
        /// Value indicating whether CONNECT host and SNI mismatch (i.e., CONNECT host doesn't match the SSL/TLS client hello SNI)
        /// is blocked or not
        /// </summary>
        [Input("blockConnectHostSniMismatch")]
        public Input<bool>? BlockConnectHostSniMismatch { get; set; }

        [Input("blockDomainFrontingApps")]
        private InputList<string>? _blockDomainFrontingApps;

        /// <summary>
        /// Applications which are subjected to Domain Fronting
        /// </summary>
        public InputList<string> BlockDomainFrontingApps
        {
            get => _blockDomainFrontingApps ?? (_blockDomainFrontingApps = new InputList<string>());
            set => _blockDomainFrontingApps = value;
        }

        /// <summary>
        /// Value indicating whether to block or allow HTTP/S transactions in which the FQDN of the request URL is different than
        /// the FQDN of the request's host header
        /// </summary>
        [Input("blockDomainFrontingOnHostHeader")]
        public Input<bool>? BlockDomainFrontingOnHostHeader { get; set; }

        /// <summary>
        /// Value indicating whether HTTP CONNECT method requests to non-standard ports are allowed or not (i.e., requests directed
        /// to ports other than the standard HTTP/S ports 80 and 443)
        /// </summary>
        [Input("blockHttpTunnelOnNonHttpPorts")]
        public Input<bool>? BlockHttpTunnelOnNonHttpPorts { get; set; }

        /// <summary>
        /// Value indicating whether to allow or block traffic that is not compliant with RFC HTTP protocol standards
        /// </summary>
        [Input("blockNonCompliantHttpRequestOnHttpPorts")]
        public Input<bool>? BlockNonCompliantHttpRequestOnHttpPorts { get; set; }

        /// <summary>
        /// Value indicating whether non-HTTP Traffic on HTTP/S ports are allowed or blocked
        /// </summary>
        [Input("blockNonHttpOnHttpPortEnabled")]
        public Input<bool>? BlockNonHttpOnHttpPortEnabled { get; set; }

        /// <summary>
        /// Value indicating whether to apply the URL Filtering policy even when the Cloud App Control policy already allows a
        /// transaction explicitly
        /// </summary>
        [Input("cascadeUrlFiltering")]
        public Input<bool>? CascadeUrlFiltering { get; set; }

        [Input("digestAuthBypassApps")]
        private InputList<string>? _digestAuthBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from Digest authentication
        /// </summary>
        public InputList<string> DigestAuthBypassApps
        {
            get => _digestAuthBypassApps ?? (_digestAuthBypassApps = new InputList<string>());
            set => _digestAuthBypassApps = value;
        }

        [Input("digestAuthBypassUrlCategories")]
        private InputList<string>? _digestAuthBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from Digest authentication
        /// </summary>
        public InputList<string> DigestAuthBypassUrlCategories
        {
            get => _digestAuthBypassUrlCategories ?? (_digestAuthBypassUrlCategories = new InputList<string>());
            set => _digestAuthBypassUrlCategories = value;
        }

        [Input("digestAuthBypassUrls")]
        private InputList<string>? _digestAuthBypassUrls;

        /// <summary>
        /// Custom URLs that are exempted from Digest authentication. Cloud applications that are exempted from Digest
        /// authentication
        /// </summary>
        public InputList<string> DigestAuthBypassUrls
        {
            get => _digestAuthBypassUrls ?? (_digestAuthBypassUrls = new InputList<string>());
            set => _digestAuthBypassUrls = value;
        }

        [Input("dnsResolutionOnTransparentProxyApps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyApps;

        /// <summary>
        /// Cloud applications to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyApps
        {
            get => _dnsResolutionOnTransparentProxyApps ?? (_dnsResolutionOnTransparentProxyApps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyApps = value;
        }

        [Input("dnsResolutionOnTransparentProxyExemptApps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyExemptApps;

        /// <summary>
        /// Cloud applications that are excluded from DNS optimization on transparent proxy mode
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyExemptApps
        {
            get => _dnsResolutionOnTransparentProxyExemptApps ?? (_dnsResolutionOnTransparentProxyExemptApps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyExemptApps = value;
        }

        [Input("dnsResolutionOnTransparentProxyExemptUrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyExemptUrlCategories;
        public InputList<string> DnsResolutionOnTransparentProxyExemptUrlCategories
        {
            get => _dnsResolutionOnTransparentProxyExemptUrlCategories ?? (_dnsResolutionOnTransparentProxyExemptUrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyExemptUrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyExemptUrls")]
        private InputList<string>? _dnsResolutionOnTransparentProxyExemptUrls;

        /// <summary>
        /// URLs that are excluded from DNS optimization on transparent proxy mode
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyExemptUrls
        {
            get => _dnsResolutionOnTransparentProxyExemptUrls ?? (_dnsResolutionOnTransparentProxyExemptUrls = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyExemptUrls = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6Apps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6Apps;

        /// <summary>
        /// Cloud applications to which DNS optimization for IPv6 addresses on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyIpv6Apps
        {
            get => _dnsResolutionOnTransparentProxyIpv6Apps ?? (_dnsResolutionOnTransparentProxyIpv6Apps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6Apps = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6ExemptApps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6ExemptApps;

        /// <summary>
        /// Cloud applications that are excluded from DNS optimization for IPv6 addresses on transparent proxy mode
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyIpv6ExemptApps
        {
            get => _dnsResolutionOnTransparentProxyIpv6ExemptApps ?? (_dnsResolutionOnTransparentProxyIpv6ExemptApps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6ExemptApps = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories;
        public InputList<string> DnsResolutionOnTransparentProxyIpv6ExemptUrlCategories
        {
            get => _dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories ?? (_dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6UrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6UrlCategories;

        /// <summary>
        /// IPv6 URL categories to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyIpv6UrlCategories
        {
            get => _dnsResolutionOnTransparentProxyIpv6UrlCategories ?? (_dnsResolutionOnTransparentProxyIpv6UrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6UrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyUrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyUrlCategories;

        /// <summary>
        /// URL categories to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyUrlCategories
        {
            get => _dnsResolutionOnTransparentProxyUrlCategories ?? (_dnsResolutionOnTransparentProxyUrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyUrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyUrls")]
        private InputList<string>? _dnsResolutionOnTransparentProxyUrls;

        /// <summary>
        /// URLs to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyUrls
        {
            get => _dnsResolutionOnTransparentProxyUrls ?? (_dnsResolutionOnTransparentProxyUrls = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyUrls = value;
        }

        [Input("domainFrontingBypassUrlCategories")]
        private InputList<string>? _domainFrontingBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from domain fronting
        /// </summary>
        public InputList<string> DomainFrontingBypassUrlCategories
        {
            get => _domainFrontingBypassUrlCategories ?? (_domainFrontingBypassUrlCategories = new InputList<string>());
            set => _domainFrontingBypassUrlCategories = value;
        }

        /// <summary>
        /// Value indicating whether to dynamically update user risk score by tracking risky user activities in real time
        /// </summary>
        [Input("dynamicUserRiskEnabled")]
        public Input<bool>? DynamicUserRiskEnabled { get; set; }

        /// <summary>
        /// Value indicating whether or not to include the ECS option in all DNS queries, originating from all locations and remote
        /// users.
        /// </summary>
        [Input("ecsForAllEnabled")]
        public Input<bool>? EcsForAllEnabled { get; set; }

        /// <summary>
        /// Value indicating whether ranks are enabled for admins to allow admin ranks in policy configuration and management
        /// </summary>
        [Input("enableAdminRankAccess")]
        public Input<bool>? EnableAdminRankAccess { get; set; }

        /// <summary>
        /// Value indicating whether DNS optimization is enabled or disabled for Z-Tunnel 2.0 and transparent proxy mode traffic
        /// (e.g., traffic via GRE or IPSec tunnels without a PAC file).
        /// </summary>
        [Input("enableDnsResolutionOnTransparentProxy")]
        public Input<bool>? EnableDnsResolutionOnTransparentProxy { get; set; }

        /// <summary>
        /// Enable/Disable DNS optimization for all IPv6 transparent proxy traffic
        /// </summary>
        [Input("enableEvaluatePolicyOnGlobalSslBypass")]
        public Input<bool>? EnableEvaluatePolicyOnGlobalSslBypass { get; set; }

        /// <summary>
        /// Enable/Disable DNS optimization for all IPv6 transparent proxy traffic
        /// </summary>
        [Input("enableIpv6DnsOptimizationOnAllTransparentProxy")]
        public Input<bool>? EnableIpv6DnsOptimizationOnAllTransparentProxy { get; set; }

        /// <summary>
        /// Value indicating whether DNS optimization is enabled or disabled for IPv6 connections to dual-stack or IPv6-only
        /// destinations sent via Z-Tunnel 2.0 and transparent proxy proxy mode (e.g., traffic via GRE or IPSec tunnels without a
        /// PAC file).
        /// </summary>
        [Input("enableIpv6DnsResolutionOnTransparentProxy")]
        public Input<bool>? EnableIpv6DnsResolutionOnTransparentProxy { get; set; }

        /// <summary>
        /// Value indicating whether Microsoft Office 365 One Click Configuration is enabled or not
        /// </summary>
        [Input("enableOffice365")]
        public Input<bool>? EnableOffice365 { get; set; }

        /// <summary>
        /// Value indicating whether policies that include user and department criteria can be configured and applied for
        /// unauthenticated traffic
        /// </summary>
        [Input("enablePolicyForUnauthenticatedTraffic")]
        public Input<bool>? EnablePolicyForUnauthenticatedTraffic { get; set; }

        /// <summary>
        /// Enforce Surrogate IP authentication for Windows app traffic
        /// </summary>
        [Input("enforceSurrogateIpForWindowsApp")]
        public Input<bool>? EnforceSurrogateIpForWindowsApp { get; set; }

        /// <summary>
        /// Value indicating whether or not HTTP/2 should be the default web protocol for accessing various applications at your
        /// organizational level
        /// </summary>
        [Input("http2NonbrowserTrafficEnabled")]
        public Input<bool>? Http2NonbrowserTrafficEnabled { get; set; }

        [Input("httpRangeHeaderRemoveUrlCategories")]
        private InputList<string>? _httpRangeHeaderRemoveUrlCategories;

        /// <summary>
        /// URL categories for which HTTP range headers must be removed
        /// </summary>
        public InputList<string> HttpRangeHeaderRemoveUrlCategories
        {
            get => _httpRangeHeaderRemoveUrlCategories ?? (_httpRangeHeaderRemoveUrlCategories = new InputList<string>());
            set => _httpRangeHeaderRemoveUrlCategories = value;
        }

        [Input("kerberosBypassApps")]
        private InputList<string>? _kerberosBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from Kerberos authentication
        /// </summary>
        public InputList<string> KerberosBypassApps
        {
            get => _kerberosBypassApps ?? (_kerberosBypassApps = new InputList<string>());
            set => _kerberosBypassApps = value;
        }

        [Input("kerberosBypassUrlCategories")]
        private InputList<string>? _kerberosBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from Kerberos authentication
        /// </summary>
        public InputList<string> KerberosBypassUrlCategories
        {
            get => _kerberosBypassUrlCategories ?? (_kerberosBypassUrlCategories = new InputList<string>());
            set => _kerberosBypassUrlCategories = value;
        }

        [Input("kerberosBypassUrls")]
        private InputList<string>? _kerberosBypassUrls;

        /// <summary>
        /// Custom URLs that are exempted from Kerberos authentication
        /// </summary>
        public InputList<string> KerberosBypassUrls
        {
            get => _kerberosBypassUrls ?? (_kerberosBypassUrls = new InputList<string>());
            set => _kerberosBypassUrls = value;
        }

        /// <summary>
        /// Value indicating whether to log internal IP address present in X-Forwarded-For (XFF) proxy header or not
        /// </summary>
        [Input("logInternalIp")]
        public Input<bool>? LogInternalIp { get; set; }

        /// <summary>
        /// Value indicating whether or not to use the SSL/TLS client hello SNI for DNS resolution instead of the CONNECT host for
        /// forward proxy connections
        /// </summary>
        [Input("preferSniOverConnHost")]
        public Input<bool>? PreferSniOverConnHost { get; set; }

        [Input("preferSniOverConnHostApps")]
        private InputList<string>? _preferSniOverConnHostApps;

        /// <summary>
        /// Applications that are exempted from the preferSniOverConnHost setting (i.e., prefer SSL/TLS client hello SNI for DNS
        /// resolution instead of the CONNECT host for forward proxy connections)
        /// </summary>
        public InputList<string> PreferSniOverConnHostApps
        {
            get => _preferSniOverConnHostApps ?? (_preferSniOverConnHostApps = new InputList<string>());
            set => _preferSniOverConnHostApps = value;
        }

        /// <summary>
        /// Value indicating whether or not to insert XFF header to all traffic forwarded from ZIA to ZPA, including source
        /// IP-anchored and ZIA-inspected ZPA application traffic.
        /// </summary>
        [Input("sipaXffHeaderEnabled")]
        public Input<bool>? SipaXffHeaderEnabled { get; set; }

        [Input("sniDnsOptimizationBypassUrlCategories")]
        private InputList<string>? _sniDnsOptimizationBypassUrlCategories;

        /// <summary>
        /// URL categories that are excluded from the preferSniOverConnHost setting (i.e., prefer SSL/TLS client hello SNI for DNS
        /// resolution instead of the CONNECT host for forward proxy connections)
        /// </summary>
        public InputList<string> SniDnsOptimizationBypassUrlCategories
        {
            get => _sniDnsOptimizationBypassUrlCategories ?? (_sniDnsOptimizationBypassUrlCategories = new InputList<string>());
            set => _sniDnsOptimizationBypassUrlCategories = value;
        }

        /// <summary>
        /// Value indicating whether to apply configured policies on tunneled HTTP traffic sent via a CONNECT method request on port
        /// 80
        /// </summary>
        [Input("trackHttpTunnelOnHttpPorts")]
        public Input<bool>? TrackHttpTunnelOnHttpPorts { get; set; }

        /// <summary>
        /// Specifies the login session timeout for admins accessing the ZIA Admin Portal
        /// </summary>
        [Input("uiSessionTimeout")]
        public Input<int>? UiSessionTimeout { get; set; }

        /// <summary>
        /// Value indicating whether to apply the Firewall rules configured without a specified location criteria (or with the Road
        /// Warrior location) to remote user traffic forwarded via Z-Tunnel 1.0 or PAC files
        /// </summary>
        [Input("zscalerClientConnector1AndPacRoadWarriorInFirewall")]
        public Input<bool>? ZscalerClientConnector1AndPacRoadWarriorInFirewall { get; set; }

        public AdvancedSettingsArgs()
        {
        }
        public static new AdvancedSettingsArgs Empty => new AdvancedSettingsArgs();
    }

    public sealed class AdvancedSettingsState : global::Pulumi.ResourceArgs
    {
        [Input("authBypassApps")]
        private InputList<string>? _authBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from cookie authentication
        /// </summary>
        public InputList<string> AuthBypassApps
        {
            get => _authBypassApps ?? (_authBypassApps = new InputList<string>());
            set => _authBypassApps = value;
        }

        [Input("authBypassUrlCategories")]
        private InputList<string>? _authBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from cookie authentication
        /// </summary>
        public InputList<string> AuthBypassUrlCategories
        {
            get => _authBypassUrlCategories ?? (_authBypassUrlCategories = new InputList<string>());
            set => _authBypassUrlCategories = value;
        }

        [Input("authBypassUrls")]
        private InputList<string>? _authBypassUrls;

        /// <summary>
        /// Custom URLs that are exempted from cookie authentication for users
        /// </summary>
        public InputList<string> AuthBypassUrls
        {
            get => _authBypassUrls ?? (_authBypassUrls = new InputList<string>());
            set => _authBypassUrls = value;
        }

        [Input("basicBypassApps")]
        private InputList<string>? _basicBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from Basic authentication
        /// </summary>
        public InputList<string> BasicBypassApps
        {
            get => _basicBypassApps ?? (_basicBypassApps = new InputList<string>());
            set => _basicBypassApps = value;
        }

        [Input("basicBypassUrlCategories")]
        private InputList<string>? _basicBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from Basic authentication
        /// </summary>
        public InputList<string> BasicBypassUrlCategories
        {
            get => _basicBypassUrlCategories ?? (_basicBypassUrlCategories = new InputList<string>());
            set => _basicBypassUrlCategories = value;
        }

        /// <summary>
        /// Value indicating whether CONNECT host and SNI mismatch (i.e., CONNECT host doesn't match the SSL/TLS client hello SNI)
        /// is blocked or not
        /// </summary>
        [Input("blockConnectHostSniMismatch")]
        public Input<bool>? BlockConnectHostSniMismatch { get; set; }

        [Input("blockDomainFrontingApps")]
        private InputList<string>? _blockDomainFrontingApps;

        /// <summary>
        /// Applications which are subjected to Domain Fronting
        /// </summary>
        public InputList<string> BlockDomainFrontingApps
        {
            get => _blockDomainFrontingApps ?? (_blockDomainFrontingApps = new InputList<string>());
            set => _blockDomainFrontingApps = value;
        }

        /// <summary>
        /// Value indicating whether to block or allow HTTP/S transactions in which the FQDN of the request URL is different than
        /// the FQDN of the request's host header
        /// </summary>
        [Input("blockDomainFrontingOnHostHeader")]
        public Input<bool>? BlockDomainFrontingOnHostHeader { get; set; }

        /// <summary>
        /// Value indicating whether HTTP CONNECT method requests to non-standard ports are allowed or not (i.e., requests directed
        /// to ports other than the standard HTTP/S ports 80 and 443)
        /// </summary>
        [Input("blockHttpTunnelOnNonHttpPorts")]
        public Input<bool>? BlockHttpTunnelOnNonHttpPorts { get; set; }

        /// <summary>
        /// Value indicating whether to allow or block traffic that is not compliant with RFC HTTP protocol standards
        /// </summary>
        [Input("blockNonCompliantHttpRequestOnHttpPorts")]
        public Input<bool>? BlockNonCompliantHttpRequestOnHttpPorts { get; set; }

        /// <summary>
        /// Value indicating whether non-HTTP Traffic on HTTP/S ports are allowed or blocked
        /// </summary>
        [Input("blockNonHttpOnHttpPortEnabled")]
        public Input<bool>? BlockNonHttpOnHttpPortEnabled { get; set; }

        /// <summary>
        /// Value indicating whether to apply the URL Filtering policy even when the Cloud App Control policy already allows a
        /// transaction explicitly
        /// </summary>
        [Input("cascadeUrlFiltering")]
        public Input<bool>? CascadeUrlFiltering { get; set; }

        [Input("digestAuthBypassApps")]
        private InputList<string>? _digestAuthBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from Digest authentication
        /// </summary>
        public InputList<string> DigestAuthBypassApps
        {
            get => _digestAuthBypassApps ?? (_digestAuthBypassApps = new InputList<string>());
            set => _digestAuthBypassApps = value;
        }

        [Input("digestAuthBypassUrlCategories")]
        private InputList<string>? _digestAuthBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from Digest authentication
        /// </summary>
        public InputList<string> DigestAuthBypassUrlCategories
        {
            get => _digestAuthBypassUrlCategories ?? (_digestAuthBypassUrlCategories = new InputList<string>());
            set => _digestAuthBypassUrlCategories = value;
        }

        [Input("digestAuthBypassUrls")]
        private InputList<string>? _digestAuthBypassUrls;

        /// <summary>
        /// Custom URLs that are exempted from Digest authentication. Cloud applications that are exempted from Digest
        /// authentication
        /// </summary>
        public InputList<string> DigestAuthBypassUrls
        {
            get => _digestAuthBypassUrls ?? (_digestAuthBypassUrls = new InputList<string>());
            set => _digestAuthBypassUrls = value;
        }

        [Input("dnsResolutionOnTransparentProxyApps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyApps;

        /// <summary>
        /// Cloud applications to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyApps
        {
            get => _dnsResolutionOnTransparentProxyApps ?? (_dnsResolutionOnTransparentProxyApps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyApps = value;
        }

        [Input("dnsResolutionOnTransparentProxyExemptApps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyExemptApps;

        /// <summary>
        /// Cloud applications that are excluded from DNS optimization on transparent proxy mode
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyExemptApps
        {
            get => _dnsResolutionOnTransparentProxyExemptApps ?? (_dnsResolutionOnTransparentProxyExemptApps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyExemptApps = value;
        }

        [Input("dnsResolutionOnTransparentProxyExemptUrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyExemptUrlCategories;
        public InputList<string> DnsResolutionOnTransparentProxyExemptUrlCategories
        {
            get => _dnsResolutionOnTransparentProxyExemptUrlCategories ?? (_dnsResolutionOnTransparentProxyExemptUrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyExemptUrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyExemptUrls")]
        private InputList<string>? _dnsResolutionOnTransparentProxyExemptUrls;

        /// <summary>
        /// URLs that are excluded from DNS optimization on transparent proxy mode
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyExemptUrls
        {
            get => _dnsResolutionOnTransparentProxyExemptUrls ?? (_dnsResolutionOnTransparentProxyExemptUrls = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyExemptUrls = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6Apps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6Apps;

        /// <summary>
        /// Cloud applications to which DNS optimization for IPv6 addresses on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyIpv6Apps
        {
            get => _dnsResolutionOnTransparentProxyIpv6Apps ?? (_dnsResolutionOnTransparentProxyIpv6Apps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6Apps = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6ExemptApps")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6ExemptApps;

        /// <summary>
        /// Cloud applications that are excluded from DNS optimization for IPv6 addresses on transparent proxy mode
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyIpv6ExemptApps
        {
            get => _dnsResolutionOnTransparentProxyIpv6ExemptApps ?? (_dnsResolutionOnTransparentProxyIpv6ExemptApps = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6ExemptApps = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories;
        public InputList<string> DnsResolutionOnTransparentProxyIpv6ExemptUrlCategories
        {
            get => _dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories ?? (_dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6ExemptUrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyIpv6UrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyIpv6UrlCategories;

        /// <summary>
        /// IPv6 URL categories to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyIpv6UrlCategories
        {
            get => _dnsResolutionOnTransparentProxyIpv6UrlCategories ?? (_dnsResolutionOnTransparentProxyIpv6UrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyIpv6UrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyUrlCategories")]
        private InputList<string>? _dnsResolutionOnTransparentProxyUrlCategories;

        /// <summary>
        /// URL categories to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyUrlCategories
        {
            get => _dnsResolutionOnTransparentProxyUrlCategories ?? (_dnsResolutionOnTransparentProxyUrlCategories = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyUrlCategories = value;
        }

        [Input("dnsResolutionOnTransparentProxyUrls")]
        private InputList<string>? _dnsResolutionOnTransparentProxyUrls;

        /// <summary>
        /// URLs to which DNS optimization on transparent proxy mode applies
        /// </summary>
        public InputList<string> DnsResolutionOnTransparentProxyUrls
        {
            get => _dnsResolutionOnTransparentProxyUrls ?? (_dnsResolutionOnTransparentProxyUrls = new InputList<string>());
            set => _dnsResolutionOnTransparentProxyUrls = value;
        }

        [Input("domainFrontingBypassUrlCategories")]
        private InputList<string>? _domainFrontingBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from domain fronting
        /// </summary>
        public InputList<string> DomainFrontingBypassUrlCategories
        {
            get => _domainFrontingBypassUrlCategories ?? (_domainFrontingBypassUrlCategories = new InputList<string>());
            set => _domainFrontingBypassUrlCategories = value;
        }

        /// <summary>
        /// Value indicating whether to dynamically update user risk score by tracking risky user activities in real time
        /// </summary>
        [Input("dynamicUserRiskEnabled")]
        public Input<bool>? DynamicUserRiskEnabled { get; set; }

        /// <summary>
        /// Value indicating whether or not to include the ECS option in all DNS queries, originating from all locations and remote
        /// users.
        /// </summary>
        [Input("ecsForAllEnabled")]
        public Input<bool>? EcsForAllEnabled { get; set; }

        /// <summary>
        /// Value indicating whether ranks are enabled for admins to allow admin ranks in policy configuration and management
        /// </summary>
        [Input("enableAdminRankAccess")]
        public Input<bool>? EnableAdminRankAccess { get; set; }

        /// <summary>
        /// Value indicating whether DNS optimization is enabled or disabled for Z-Tunnel 2.0 and transparent proxy mode traffic
        /// (e.g., traffic via GRE or IPSec tunnels without a PAC file).
        /// </summary>
        [Input("enableDnsResolutionOnTransparentProxy")]
        public Input<bool>? EnableDnsResolutionOnTransparentProxy { get; set; }

        /// <summary>
        /// Enable/Disable DNS optimization for all IPv6 transparent proxy traffic
        /// </summary>
        [Input("enableEvaluatePolicyOnGlobalSslBypass")]
        public Input<bool>? EnableEvaluatePolicyOnGlobalSslBypass { get; set; }

        /// <summary>
        /// Enable/Disable DNS optimization for all IPv6 transparent proxy traffic
        /// </summary>
        [Input("enableIpv6DnsOptimizationOnAllTransparentProxy")]
        public Input<bool>? EnableIpv6DnsOptimizationOnAllTransparentProxy { get; set; }

        /// <summary>
        /// Value indicating whether DNS optimization is enabled or disabled for IPv6 connections to dual-stack or IPv6-only
        /// destinations sent via Z-Tunnel 2.0 and transparent proxy proxy mode (e.g., traffic via GRE or IPSec tunnels without a
        /// PAC file).
        /// </summary>
        [Input("enableIpv6DnsResolutionOnTransparentProxy")]
        public Input<bool>? EnableIpv6DnsResolutionOnTransparentProxy { get; set; }

        /// <summary>
        /// Value indicating whether Microsoft Office 365 One Click Configuration is enabled or not
        /// </summary>
        [Input("enableOffice365")]
        public Input<bool>? EnableOffice365 { get; set; }

        /// <summary>
        /// Value indicating whether policies that include user and department criteria can be configured and applied for
        /// unauthenticated traffic
        /// </summary>
        [Input("enablePolicyForUnauthenticatedTraffic")]
        public Input<bool>? EnablePolicyForUnauthenticatedTraffic { get; set; }

        /// <summary>
        /// Enforce Surrogate IP authentication for Windows app traffic
        /// </summary>
        [Input("enforceSurrogateIpForWindowsApp")]
        public Input<bool>? EnforceSurrogateIpForWindowsApp { get; set; }

        /// <summary>
        /// Value indicating whether or not HTTP/2 should be the default web protocol for accessing various applications at your
        /// organizational level
        /// </summary>
        [Input("http2NonbrowserTrafficEnabled")]
        public Input<bool>? Http2NonbrowserTrafficEnabled { get; set; }

        [Input("httpRangeHeaderRemoveUrlCategories")]
        private InputList<string>? _httpRangeHeaderRemoveUrlCategories;

        /// <summary>
        /// URL categories for which HTTP range headers must be removed
        /// </summary>
        public InputList<string> HttpRangeHeaderRemoveUrlCategories
        {
            get => _httpRangeHeaderRemoveUrlCategories ?? (_httpRangeHeaderRemoveUrlCategories = new InputList<string>());
            set => _httpRangeHeaderRemoveUrlCategories = value;
        }

        [Input("kerberosBypassApps")]
        private InputList<string>? _kerberosBypassApps;

        /// <summary>
        /// Cloud applications that are exempted from Kerberos authentication
        /// </summary>
        public InputList<string> KerberosBypassApps
        {
            get => _kerberosBypassApps ?? (_kerberosBypassApps = new InputList<string>());
            set => _kerberosBypassApps = value;
        }

        [Input("kerberosBypassUrlCategories")]
        private InputList<string>? _kerberosBypassUrlCategories;

        /// <summary>
        /// URL categories that are exempted from Kerberos authentication
        /// </summary>
        public InputList<string> KerberosBypassUrlCategories
        {
            get => _kerberosBypassUrlCategories ?? (_kerberosBypassUrlCategories = new InputList<string>());
            set => _kerberosBypassUrlCategories = value;
        }

        [Input("kerberosBypassUrls")]
        private InputList<string>? _kerberosBypassUrls;

        /// <summary>
        /// Custom URLs that are exempted from Kerberos authentication
        /// </summary>
        public InputList<string> KerberosBypassUrls
        {
            get => _kerberosBypassUrls ?? (_kerberosBypassUrls = new InputList<string>());
            set => _kerberosBypassUrls = value;
        }

        /// <summary>
        /// Value indicating whether to log internal IP address present in X-Forwarded-For (XFF) proxy header or not
        /// </summary>
        [Input("logInternalIp")]
        public Input<bool>? LogInternalIp { get; set; }

        /// <summary>
        /// Value indicating whether or not to use the SSL/TLS client hello SNI for DNS resolution instead of the CONNECT host for
        /// forward proxy connections
        /// </summary>
        [Input("preferSniOverConnHost")]
        public Input<bool>? PreferSniOverConnHost { get; set; }

        [Input("preferSniOverConnHostApps")]
        private InputList<string>? _preferSniOverConnHostApps;

        /// <summary>
        /// Applications that are exempted from the preferSniOverConnHost setting (i.e., prefer SSL/TLS client hello SNI for DNS
        /// resolution instead of the CONNECT host for forward proxy connections)
        /// </summary>
        public InputList<string> PreferSniOverConnHostApps
        {
            get => _preferSniOverConnHostApps ?? (_preferSniOverConnHostApps = new InputList<string>());
            set => _preferSniOverConnHostApps = value;
        }

        /// <summary>
        /// Value indicating whether or not to insert XFF header to all traffic forwarded from ZIA to ZPA, including source
        /// IP-anchored and ZIA-inspected ZPA application traffic.
        /// </summary>
        [Input("sipaXffHeaderEnabled")]
        public Input<bool>? SipaXffHeaderEnabled { get; set; }

        [Input("sniDnsOptimizationBypassUrlCategories")]
        private InputList<string>? _sniDnsOptimizationBypassUrlCategories;

        /// <summary>
        /// URL categories that are excluded from the preferSniOverConnHost setting (i.e., prefer SSL/TLS client hello SNI for DNS
        /// resolution instead of the CONNECT host for forward proxy connections)
        /// </summary>
        public InputList<string> SniDnsOptimizationBypassUrlCategories
        {
            get => _sniDnsOptimizationBypassUrlCategories ?? (_sniDnsOptimizationBypassUrlCategories = new InputList<string>());
            set => _sniDnsOptimizationBypassUrlCategories = value;
        }

        /// <summary>
        /// Value indicating whether to apply configured policies on tunneled HTTP traffic sent via a CONNECT method request on port
        /// 80
        /// </summary>
        [Input("trackHttpTunnelOnHttpPorts")]
        public Input<bool>? TrackHttpTunnelOnHttpPorts { get; set; }

        /// <summary>
        /// Specifies the login session timeout for admins accessing the ZIA Admin Portal
        /// </summary>
        [Input("uiSessionTimeout")]
        public Input<int>? UiSessionTimeout { get; set; }

        /// <summary>
        /// Value indicating whether to apply the Firewall rules configured without a specified location criteria (or with the Road
        /// Warrior location) to remote user traffic forwarded via Z-Tunnel 1.0 or PAC files
        /// </summary>
        [Input("zscalerClientConnector1AndPacRoadWarriorInFirewall")]
        public Input<bool>? ZscalerClientConnector1AndPacRoadWarriorInFirewall { get; set; }

        public AdvancedSettingsState()
        {
        }
        public static new AdvancedSettingsState Empty => new AdvancedSettingsState();
    }
}

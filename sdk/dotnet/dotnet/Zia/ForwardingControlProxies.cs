// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace zscaler.PulumiPackage.Zia
{
    /// <summary>
    /// * [Official documentation](https://help.zscaler.com/zia/about-third-party-proxies)
    /// * [API documentation](https://help.zscaler.com/zia/forwarding-control-policy#/proxies-get)
    /// 
    /// Use the **zia_forwarding_control_proxies** resource allows the creation and management of ZIA forwarding control Proxies for third-party proxy services integration between Zscaler Internet Access and Zscaler Private Access. This resource can then be associated with a ZIA Forwarding Control Rule.
    /// 
    /// ## Example Usage
    /// 
    /// ### No Certificate
    /// 
    /// ### With Certificate
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// 
    /// Visit
    /// 
    /// **zia_forwarding_control_proxies** can be imported by using `&lt;PROXY_ID&gt;` or `&lt;PROXY_NAME&gt;` as the import ID.
    /// 
    /// For example:
    /// 
    /// ```sh
    /// $ pulumi import zia:index/forwardingControlProxies:ForwardingControlProxies example &lt;proxy_id&gt;
    /// ```
    /// 
    /// or
    /// 
    /// ```sh
    /// $ pulumi import zia:index/forwardingControlProxies:ForwardingControlProxies example &lt;proxy_name&gt;
    /// ```
    /// </summary>
    [ZiaResourceType("zia:index/forwardingControlProxies:ForwardingControlProxies")]
    public partial class ForwardingControlProxies : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The IP address or the FQDN of the third-party proxy service
        /// </summary>
        [Output("address")]
        public Output<string?> Address { get; private set; } = null!;

        /// <summary>
        /// (Boolean) Flag indicating whether the added X-Authenticated-User header is Base64 encoded. When enabled, the user ID is encoded using the Base64 encoding method.
        /// </summary>
        [Output("base64EncodeXauHeader")]
        public Output<bool?> Base64EncodeXauHeader { get; private set; } = null!;

        /// <summary>
        /// (Set of Objects) The root certificate used by the third-party proxy to perform SSL inspection. This root certificate is used by Zscaler to validate the SSL leaf certificates signed by the upstream proxy. The required root certificate appears in this drop-down list only if it is uploaded from the Administration &gt; Root Certificates page.
        /// </summary>
        [Output("certs")]
        public Output<ImmutableArray<Outputs.ForwardingControlProxiesCert>> Certs { get; private set; } = null!;

        /// <summary>
        /// (String) Additional notes or information
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// (Boolean) Flag indicating whether X-Authenticated-User header is added by the proxy. Enable to automatically insert authenticated user ID to the HTTP header, X-Authenticated-User.
        /// </summary>
        [Output("insertXauHeader")]
        public Output<bool?> InsertXauHeader { get; private set; } = null!;

        /// <summary>
        /// Proxy name for the third-party proxy services
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The port number on which the third-party proxy service listens to the requests forwarded from Zscaler
        /// </summary>
        [Output("port")]
        public Output<int?> Port { get; private set; } = null!;

        [Output("proxyId")]
        public Output<int> ProxyId { get; private set; } = null!;

        /// <summary>
        /// Gateway type. Supported values: `PROXYCHAIN`, `ZIA`, `ECSELF`
        /// </summary>
        [Output("type")]
        public Output<string?> Type { get; private set; } = null!;


        /// <summary>
        /// Create a ForwardingControlProxies resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ForwardingControlProxies(string name, ForwardingControlProxiesArgs? args = null, CustomResourceOptions? options = null)
            : base("zia:index/forwardingControlProxies:ForwardingControlProxies", name, args ?? new ForwardingControlProxiesArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ForwardingControlProxies(string name, Input<string> id, ForwardingControlProxiesState? state = null, CustomResourceOptions? options = null)
            : base("zia:index/forwardingControlProxies:ForwardingControlProxies", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ForwardingControlProxies resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ForwardingControlProxies Get(string name, Input<string> id, ForwardingControlProxiesState? state = null, CustomResourceOptions? options = null)
        {
            return new ForwardingControlProxies(name, id, state, options);
        }
    }

    public sealed class ForwardingControlProxiesArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The IP address or the FQDN of the third-party proxy service
        /// </summary>
        [Input("address")]
        public Input<string>? Address { get; set; }

        /// <summary>
        /// (Boolean) Flag indicating whether the added X-Authenticated-User header is Base64 encoded. When enabled, the user ID is encoded using the Base64 encoding method.
        /// </summary>
        [Input("base64EncodeXauHeader")]
        public Input<bool>? Base64EncodeXauHeader { get; set; }

        [Input("certs")]
        private InputList<Inputs.ForwardingControlProxiesCertArgs>? _certs;

        /// <summary>
        /// (Set of Objects) The root certificate used by the third-party proxy to perform SSL inspection. This root certificate is used by Zscaler to validate the SSL leaf certificates signed by the upstream proxy. The required root certificate appears in this drop-down list only if it is uploaded from the Administration &gt; Root Certificates page.
        /// </summary>
        public InputList<Inputs.ForwardingControlProxiesCertArgs> Certs
        {
            get => _certs ?? (_certs = new InputList<Inputs.ForwardingControlProxiesCertArgs>());
            set => _certs = value;
        }

        /// <summary>
        /// (String) Additional notes or information
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// (Boolean) Flag indicating whether X-Authenticated-User header is added by the proxy. Enable to automatically insert authenticated user ID to the HTTP header, X-Authenticated-User.
        /// </summary>
        [Input("insertXauHeader")]
        public Input<bool>? InsertXauHeader { get; set; }

        /// <summary>
        /// Proxy name for the third-party proxy services
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The port number on which the third-party proxy service listens to the requests forwarded from Zscaler
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

        /// <summary>
        /// Gateway type. Supported values: `PROXYCHAIN`, `ZIA`, `ECSELF`
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public ForwardingControlProxiesArgs()
        {
        }
        public static new ForwardingControlProxiesArgs Empty => new ForwardingControlProxiesArgs();
    }

    public sealed class ForwardingControlProxiesState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The IP address or the FQDN of the third-party proxy service
        /// </summary>
        [Input("address")]
        public Input<string>? Address { get; set; }

        /// <summary>
        /// (Boolean) Flag indicating whether the added X-Authenticated-User header is Base64 encoded. When enabled, the user ID is encoded using the Base64 encoding method.
        /// </summary>
        [Input("base64EncodeXauHeader")]
        public Input<bool>? Base64EncodeXauHeader { get; set; }

        [Input("certs")]
        private InputList<Inputs.ForwardingControlProxiesCertGetArgs>? _certs;

        /// <summary>
        /// (Set of Objects) The root certificate used by the third-party proxy to perform SSL inspection. This root certificate is used by Zscaler to validate the SSL leaf certificates signed by the upstream proxy. The required root certificate appears in this drop-down list only if it is uploaded from the Administration &gt; Root Certificates page.
        /// </summary>
        public InputList<Inputs.ForwardingControlProxiesCertGetArgs> Certs
        {
            get => _certs ?? (_certs = new InputList<Inputs.ForwardingControlProxiesCertGetArgs>());
            set => _certs = value;
        }

        /// <summary>
        /// (String) Additional notes or information
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// (Boolean) Flag indicating whether X-Authenticated-User header is added by the proxy. Enable to automatically insert authenticated user ID to the HTTP header, X-Authenticated-User.
        /// </summary>
        [Input("insertXauHeader")]
        public Input<bool>? InsertXauHeader { get; set; }

        /// <summary>
        /// Proxy name for the third-party proxy services
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The port number on which the third-party proxy service listens to the requests forwarded from Zscaler
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

        [Input("proxyId")]
        public Input<int>? ProxyId { get; set; }

        /// <summary>
        /// Gateway type. Supported values: `PROXYCHAIN`, `ZIA`, `ECSELF`
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public ForwardingControlProxiesState()
        {
        }
        public static new ForwardingControlProxiesState Empty => new ForwardingControlProxiesState();
    }
}

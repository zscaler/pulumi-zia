// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * * [Official documentation](https://help.zscaler.com/zia/about-traffic-capture-policy)
 * * [API documentation](https://help.zscaler.com/zia/traffic-capture-policy#/trafficCaptureRules-get)
 *
 * The **zia_traffic_capture_rules** resource allows the creation and management of ZIA traffic capture rules in the Zscaler Internet Access.
 *
 * ## Example Usage
 *
 * ## Import
 *
 * Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
 * Visit
 *
 * **zia_traffic_capture_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.
 *
 * For example:
 *
 * ```sh
 * $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_id>
 * ```
 *
 * or
 *
 * ```sh
 * $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_name>
 * ```
 */
export class TrafficCaptureRules extends pulumi.CustomResource {
    /**
     * Get an existing TrafficCaptureRules resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: TrafficCaptureRulesState, opts?: pulumi.CustomResourceOptions): TrafficCaptureRules {
        return new TrafficCaptureRules(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'zia:index/trafficCaptureRules:TrafficCaptureRules';

    /**
     * Returns true if the given object is an instance of TrafficCaptureRules.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is TrafficCaptureRules {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === TrafficCaptureRules.__pulumiType;
    }

    /**
     * The action to be enforced when the traffic matches the rule criteria
     */
    declare public readonly action: pulumi.Output<string | undefined>;
    /**
     * list of application service groups
     */
    declare public readonly appServiceGroups: pulumi.Output<outputs.TrafficCaptureRulesAppServiceGroups | undefined>;
    /**
     * If set to true, the default rule is applied
     */
    declare public readonly defaultRule: pulumi.Output<boolean | undefined>;
    /**
     * list of departments for which rule must be applied
     */
    declare public readonly departments: pulumi.Output<outputs.TrafficCaptureRulesDepartments | undefined>;
    /**
     * Additional information about the rule
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
     */
    declare public readonly destAddresses: pulumi.Output<string[] | undefined>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    declare public readonly destCountries: pulumi.Output<string[]>;
    declare public readonly destIpCategories: pulumi.Output<string[] | undefined>;
    /**
     * list of destination ip groups
     */
    declare public readonly destIpGroups: pulumi.Output<outputs.TrafficCaptureRulesDestIpGroups | undefined>;
    /**
     * This field is applicable for devices that are managed using Zscaler Client Connector.
     */
    declare public readonly deviceGroups: pulumi.Output<outputs.TrafficCaptureRulesDeviceGroups | undefined>;
    /**
     * List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
     */
    declare public readonly deviceTrustLevels: pulumi.Output<string[] | undefined>;
    /**
     * Name-ID pairs of devices for which rule must be applied.
     */
    declare public readonly devices: pulumi.Output<outputs.TrafficCaptureRulesDevices | undefined>;
    /**
     * list of groups for which rule must be applied
     */
    declare public readonly groups: pulumi.Output<outputs.TrafficCaptureRulesGroups | undefined>;
    /**
     * list of Labels that are applicable to the rule.
     */
    declare public readonly labels: pulumi.Output<outputs.TrafficCaptureRulesLabels | undefined>;
    /**
     * list of locations groups
     */
    declare public readonly locationGroups: pulumi.Output<outputs.TrafficCaptureRulesLocationGroups | undefined>;
    /**
     * list of locations for which rule must be applied
     */
    declare public readonly locations: pulumi.Output<outputs.TrafficCaptureRulesLocations | undefined>;
    /**
     * Name of the Firewall Filtering policy rule
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * list of nw application groups
     */
    declare public readonly nwApplicationGroups: pulumi.Output<outputs.TrafficCaptureRulesNwApplicationGroups | undefined>;
    declare public readonly nwApplications: pulumi.Output<string[] | undefined>;
    /**
     * list of nw service groups
     */
    declare public readonly nwServiceGroups: pulumi.Output<outputs.TrafficCaptureRulesNwServiceGroups | undefined>;
    /**
     * list of nw services
     */
    declare public readonly nwServices: pulumi.Output<outputs.TrafficCaptureRulesNwServices | undefined>;
    /**
     * Rule order number. If omitted, the rule will be added to the end of the rule set.
     */
    declare public readonly order: pulumi.Output<number>;
    /**
     * If set to true, a predefined rule is applied
     */
    declare public readonly predefined: pulumi.Output<boolean | undefined>;
    /**
     * Admin rank of the Firewall Filtering policy rule
     */
    declare public readonly rank: pulumi.Output<number | undefined>;
    declare public /*out*/ readonly ruleId: pulumi.Output<number>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    declare public readonly sourceCountries: pulumi.Output<string[]>;
    /**
     * list of source ip groups
     */
    declare public readonly srcIpGroups: pulumi.Output<outputs.TrafficCaptureRulesSrcIpGroups | undefined>;
    /**
     * User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
     */
    declare public readonly srcIps: pulumi.Output<string[] | undefined>;
    /**
     * Determines whether the Firewall Filtering policy rule is enabled or disabled
     */
    declare public readonly state: pulumi.Output<string | undefined>;
    /**
     * The time interval in which the Firewall Filtering policy rule applies
     */
    declare public readonly timeWindows: pulumi.Output<outputs.TrafficCaptureRulesTimeWindows | undefined>;
    /**
     * The percentage of connections sampled for capturing each time the rule is triggered
     */
    declare public readonly txnSampling: pulumi.Output<string | undefined>;
    /**
     * The maximum size of traffic to capture per connection
     */
    declare public readonly txnSizeLimit: pulumi.Output<string | undefined>;
    /**
     * list of users for which rule must be applied
     */
    declare public readonly users: pulumi.Output<outputs.TrafficCaptureRulesUsers | undefined>;
    /**
     * The list of preconfigured workload groups to which the policy must be applied
     */
    declare public readonly workloadGroups: pulumi.Output<outputs.TrafficCaptureRulesWorkloadGroup[]>;

    /**
     * Create a TrafficCaptureRules resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: TrafficCaptureRulesArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: TrafficCaptureRulesArgs | TrafficCaptureRulesState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as TrafficCaptureRulesState | undefined;
            resourceInputs["action"] = state?.action;
            resourceInputs["appServiceGroups"] = state?.appServiceGroups;
            resourceInputs["defaultRule"] = state?.defaultRule;
            resourceInputs["departments"] = state?.departments;
            resourceInputs["description"] = state?.description;
            resourceInputs["destAddresses"] = state?.destAddresses;
            resourceInputs["destCountries"] = state?.destCountries;
            resourceInputs["destIpCategories"] = state?.destIpCategories;
            resourceInputs["destIpGroups"] = state?.destIpGroups;
            resourceInputs["deviceGroups"] = state?.deviceGroups;
            resourceInputs["deviceTrustLevels"] = state?.deviceTrustLevels;
            resourceInputs["devices"] = state?.devices;
            resourceInputs["groups"] = state?.groups;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["locationGroups"] = state?.locationGroups;
            resourceInputs["locations"] = state?.locations;
            resourceInputs["name"] = state?.name;
            resourceInputs["nwApplicationGroups"] = state?.nwApplicationGroups;
            resourceInputs["nwApplications"] = state?.nwApplications;
            resourceInputs["nwServiceGroups"] = state?.nwServiceGroups;
            resourceInputs["nwServices"] = state?.nwServices;
            resourceInputs["order"] = state?.order;
            resourceInputs["predefined"] = state?.predefined;
            resourceInputs["rank"] = state?.rank;
            resourceInputs["ruleId"] = state?.ruleId;
            resourceInputs["sourceCountries"] = state?.sourceCountries;
            resourceInputs["srcIpGroups"] = state?.srcIpGroups;
            resourceInputs["srcIps"] = state?.srcIps;
            resourceInputs["state"] = state?.state;
            resourceInputs["timeWindows"] = state?.timeWindows;
            resourceInputs["txnSampling"] = state?.txnSampling;
            resourceInputs["txnSizeLimit"] = state?.txnSizeLimit;
            resourceInputs["users"] = state?.users;
            resourceInputs["workloadGroups"] = state?.workloadGroups;
        } else {
            const args = argsOrState as TrafficCaptureRulesArgs | undefined;
            if (args?.order === undefined && !opts.urn) {
                throw new Error("Missing required property 'order'");
            }
            resourceInputs["action"] = args?.action;
            resourceInputs["appServiceGroups"] = args?.appServiceGroups;
            resourceInputs["defaultRule"] = args?.defaultRule;
            resourceInputs["departments"] = args?.departments;
            resourceInputs["description"] = args?.description;
            resourceInputs["destAddresses"] = args?.destAddresses;
            resourceInputs["destCountries"] = args?.destCountries;
            resourceInputs["destIpCategories"] = args?.destIpCategories;
            resourceInputs["destIpGroups"] = args?.destIpGroups;
            resourceInputs["deviceGroups"] = args?.deviceGroups;
            resourceInputs["deviceTrustLevels"] = args?.deviceTrustLevels;
            resourceInputs["devices"] = args?.devices;
            resourceInputs["groups"] = args?.groups;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["locationGroups"] = args?.locationGroups;
            resourceInputs["locations"] = args?.locations;
            resourceInputs["name"] = args?.name;
            resourceInputs["nwApplicationGroups"] = args?.nwApplicationGroups;
            resourceInputs["nwApplications"] = args?.nwApplications;
            resourceInputs["nwServiceGroups"] = args?.nwServiceGroups;
            resourceInputs["nwServices"] = args?.nwServices;
            resourceInputs["order"] = args?.order;
            resourceInputs["predefined"] = args?.predefined;
            resourceInputs["rank"] = args?.rank;
            resourceInputs["sourceCountries"] = args?.sourceCountries;
            resourceInputs["srcIpGroups"] = args?.srcIpGroups;
            resourceInputs["srcIps"] = args?.srcIps;
            resourceInputs["state"] = args?.state;
            resourceInputs["timeWindows"] = args?.timeWindows;
            resourceInputs["txnSampling"] = args?.txnSampling;
            resourceInputs["txnSizeLimit"] = args?.txnSizeLimit;
            resourceInputs["users"] = args?.users;
            resourceInputs["workloadGroups"] = args?.workloadGroups;
            resourceInputs["ruleId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(TrafficCaptureRules.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering TrafficCaptureRules resources.
 */
export interface TrafficCaptureRulesState {
    /**
     * The action to be enforced when the traffic matches the rule criteria
     */
    action?: pulumi.Input<string>;
    /**
     * list of application service groups
     */
    appServiceGroups?: pulumi.Input<inputs.TrafficCaptureRulesAppServiceGroups>;
    /**
     * If set to true, the default rule is applied
     */
    defaultRule?: pulumi.Input<boolean>;
    /**
     * list of departments for which rule must be applied
     */
    departments?: pulumi.Input<inputs.TrafficCaptureRulesDepartments>;
    /**
     * Additional information about the rule
     */
    description?: pulumi.Input<string>;
    /**
     * Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
     */
    destAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    destCountries?: pulumi.Input<pulumi.Input<string>[]>;
    destIpCategories?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of destination ip groups
     */
    destIpGroups?: pulumi.Input<inputs.TrafficCaptureRulesDestIpGroups>;
    /**
     * This field is applicable for devices that are managed using Zscaler Client Connector.
     */
    deviceGroups?: pulumi.Input<inputs.TrafficCaptureRulesDeviceGroups>;
    /**
     * List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
     */
    deviceTrustLevels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name-ID pairs of devices for which rule must be applied.
     */
    devices?: pulumi.Input<inputs.TrafficCaptureRulesDevices>;
    /**
     * list of groups for which rule must be applied
     */
    groups?: pulumi.Input<inputs.TrafficCaptureRulesGroups>;
    /**
     * list of Labels that are applicable to the rule.
     */
    labels?: pulumi.Input<inputs.TrafficCaptureRulesLabels>;
    /**
     * list of locations groups
     */
    locationGroups?: pulumi.Input<inputs.TrafficCaptureRulesLocationGroups>;
    /**
     * list of locations for which rule must be applied
     */
    locations?: pulumi.Input<inputs.TrafficCaptureRulesLocations>;
    /**
     * Name of the Firewall Filtering policy rule
     */
    name?: pulumi.Input<string>;
    /**
     * list of nw application groups
     */
    nwApplicationGroups?: pulumi.Input<inputs.TrafficCaptureRulesNwApplicationGroups>;
    nwApplications?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of nw service groups
     */
    nwServiceGroups?: pulumi.Input<inputs.TrafficCaptureRulesNwServiceGroups>;
    /**
     * list of nw services
     */
    nwServices?: pulumi.Input<inputs.TrafficCaptureRulesNwServices>;
    /**
     * Rule order number. If omitted, the rule will be added to the end of the rule set.
     */
    order?: pulumi.Input<number>;
    /**
     * If set to true, a predefined rule is applied
     */
    predefined?: pulumi.Input<boolean>;
    /**
     * Admin rank of the Firewall Filtering policy rule
     */
    rank?: pulumi.Input<number>;
    ruleId?: pulumi.Input<number>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    sourceCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of source ip groups
     */
    srcIpGroups?: pulumi.Input<inputs.TrafficCaptureRulesSrcIpGroups>;
    /**
     * User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
     */
    srcIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether the Firewall Filtering policy rule is enabled or disabled
     */
    state?: pulumi.Input<string>;
    /**
     * The time interval in which the Firewall Filtering policy rule applies
     */
    timeWindows?: pulumi.Input<inputs.TrafficCaptureRulesTimeWindows>;
    /**
     * The percentage of connections sampled for capturing each time the rule is triggered
     */
    txnSampling?: pulumi.Input<string>;
    /**
     * The maximum size of traffic to capture per connection
     */
    txnSizeLimit?: pulumi.Input<string>;
    /**
     * list of users for which rule must be applied
     */
    users?: pulumi.Input<inputs.TrafficCaptureRulesUsers>;
    /**
     * The list of preconfigured workload groups to which the policy must be applied
     */
    workloadGroups?: pulumi.Input<pulumi.Input<inputs.TrafficCaptureRulesWorkloadGroup>[]>;
}

/**
 * The set of arguments for constructing a TrafficCaptureRules resource.
 */
export interface TrafficCaptureRulesArgs {
    /**
     * The action to be enforced when the traffic matches the rule criteria
     */
    action?: pulumi.Input<string>;
    /**
     * list of application service groups
     */
    appServiceGroups?: pulumi.Input<inputs.TrafficCaptureRulesAppServiceGroups>;
    /**
     * If set to true, the default rule is applied
     */
    defaultRule?: pulumi.Input<boolean>;
    /**
     * list of departments for which rule must be applied
     */
    departments?: pulumi.Input<inputs.TrafficCaptureRulesDepartments>;
    /**
     * Additional information about the rule
     */
    description?: pulumi.Input<string>;
    /**
     * Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
     */
    destAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    destCountries?: pulumi.Input<pulumi.Input<string>[]>;
    destIpCategories?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of destination ip groups
     */
    destIpGroups?: pulumi.Input<inputs.TrafficCaptureRulesDestIpGroups>;
    /**
     * This field is applicable for devices that are managed using Zscaler Client Connector.
     */
    deviceGroups?: pulumi.Input<inputs.TrafficCaptureRulesDeviceGroups>;
    /**
     * List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
     */
    deviceTrustLevels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name-ID pairs of devices for which rule must be applied.
     */
    devices?: pulumi.Input<inputs.TrafficCaptureRulesDevices>;
    /**
     * list of groups for which rule must be applied
     */
    groups?: pulumi.Input<inputs.TrafficCaptureRulesGroups>;
    /**
     * list of Labels that are applicable to the rule.
     */
    labels?: pulumi.Input<inputs.TrafficCaptureRulesLabels>;
    /**
     * list of locations groups
     */
    locationGroups?: pulumi.Input<inputs.TrafficCaptureRulesLocationGroups>;
    /**
     * list of locations for which rule must be applied
     */
    locations?: pulumi.Input<inputs.TrafficCaptureRulesLocations>;
    /**
     * Name of the Firewall Filtering policy rule
     */
    name?: pulumi.Input<string>;
    /**
     * list of nw application groups
     */
    nwApplicationGroups?: pulumi.Input<inputs.TrafficCaptureRulesNwApplicationGroups>;
    nwApplications?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of nw service groups
     */
    nwServiceGroups?: pulumi.Input<inputs.TrafficCaptureRulesNwServiceGroups>;
    /**
     * list of nw services
     */
    nwServices?: pulumi.Input<inputs.TrafficCaptureRulesNwServices>;
    /**
     * Rule order number. If omitted, the rule will be added to the end of the rule set.
     */
    order: pulumi.Input<number>;
    /**
     * If set to true, a predefined rule is applied
     */
    predefined?: pulumi.Input<boolean>;
    /**
     * Admin rank of the Firewall Filtering policy rule
     */
    rank?: pulumi.Input<number>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    sourceCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of source ip groups
     */
    srcIpGroups?: pulumi.Input<inputs.TrafficCaptureRulesSrcIpGroups>;
    /**
     * User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
     */
    srcIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines whether the Firewall Filtering policy rule is enabled or disabled
     */
    state?: pulumi.Input<string>;
    /**
     * The time interval in which the Firewall Filtering policy rule applies
     */
    timeWindows?: pulumi.Input<inputs.TrafficCaptureRulesTimeWindows>;
    /**
     * The percentage of connections sampled for capturing each time the rule is triggered
     */
    txnSampling?: pulumi.Input<string>;
    /**
     * The maximum size of traffic to capture per connection
     */
    txnSizeLimit?: pulumi.Input<string>;
    /**
     * list of users for which rule must be applied
     */
    users?: pulumi.Input<inputs.TrafficCaptureRulesUsers>;
    /**
     * The list of preconfigured workload groups to which the policy must be applied
     */
    workloadGroups?: pulumi.Input<pulumi.Input<inputs.TrafficCaptureRulesWorkloadGroup>[]>;
}

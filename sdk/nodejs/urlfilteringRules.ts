// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * * [Official documentation](https://help.zscaler.com/zia/about-url-filtering)
 * * [API documentation](https://help.zscaler.com/zia/url-filtering-policy#/urlFilteringRules-post)
 *
 * The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.
 *
 * ## Example Usage
 *
 * ### ALLOW ACTION
 *
 * ### BLOCK ACTION
 *
 * ### CAUTION ACTION
 *
 * ### ISOLATE ACTION
 *
 * ⚠️ **WARNING 1:**: Creating a URL Filtering rule with the action of `ISOLATE` requires the Cloud Browser Isolation subscription. To learn more, contact Zscaler Support or your local account team.
 *
 * ## Import
 *
 * Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
 * Visit
 *
 * **zia_url_filtering_rules** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.
 *
 * For example:
 *
 * ```sh
 * $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_id>
 * ```
 *
 * or
 *
 * ```sh
 * $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_name>
 * ```
 */
export class URLFilteringRules extends pulumi.CustomResource {
    /**
     * Get an existing URLFilteringRules resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: URLFilteringRulesState, opts?: pulumi.CustomResourceOptions): URLFilteringRules {
        return new URLFilteringRules(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'zia:index/uRLFilteringRules:URLFilteringRules';

    /**
     * Returns true if the given object is an instance of URLFilteringRules.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is URLFilteringRules {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === URLFilteringRules.__pulumiType;
    }

    /**
     * Action taken when traffic matches rule criteria
     */
    declare public readonly action: pulumi.Output<string | undefined>;
    declare public readonly blockOverride: pulumi.Output<boolean | undefined>;
    declare public readonly browserEunTemplateId: pulumi.Output<number | undefined>;
    declare public readonly cbiProfiles: pulumi.Output<outputs.URLFilteringRulesCbiProfile[]>;
    /**
     * If set to true, the CIPA Compliance rule is enabled
     */
    declare public readonly ciparule: pulumi.Output<boolean | undefined>;
    /**
     * Name-ID pairs of departments for which rule must be applied
     */
    declare public readonly departments: pulumi.Output<outputs.URLFilteringRulesDepartments | undefined>;
    /**
     * Additional information about the URL Filtering rule
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * This field is applicable for devices that are managed using Zscaler Client Connector.
     */
    declare public readonly deviceGroups: pulumi.Output<outputs.URLFilteringRulesDeviceGroups | undefined>;
    /**
     * List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
     */
    declare public readonly deviceTrustLevels: pulumi.Output<string[] | undefined>;
    /**
     * Name-ID pairs of devices for which rule must be applied.
     */
    declare public readonly devices: pulumi.Output<outputs.URLFilteringRulesDevices | undefined>;
    /**
     * URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
     */
    declare public readonly endUserNotificationUrl: pulumi.Output<string | undefined>;
    /**
     * Enforce a set a validity time period for the URL Filtering rule.
     */
    declare public readonly enforceTimeValidity: pulumi.Output<boolean | undefined>;
    /**
     * Name-ID pairs of groups for which rule must be applied
     */
    declare public readonly groups: pulumi.Output<outputs.URLFilteringRulesGroups | undefined>;
    /**
     * The URL Filtering rule's label.
     */
    declare public readonly labels: pulumi.Output<outputs.URLFilteringRulesLabels | undefined>;
    /**
     * Name-ID pairs of the location groups to which the rule must be applied.
     */
    declare public readonly locationGroups: pulumi.Output<outputs.URLFilteringRulesLocationGroups | undefined>;
    /**
     * Name-ID pairs of locations for which rule must be applied
     */
    declare public readonly locations: pulumi.Output<outputs.URLFilteringRulesLocations | undefined>;
    /**
     * Name of the Firewall Filtering policy rule
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Order of execution of rule with respect to other URL Filtering rules
     */
    declare public readonly order: pulumi.Output<number>;
    /**
     * Name-ID pairs of groups for which this rule can be overridden.
     */
    declare public readonly overrideGroups: pulumi.Output<outputs.URLFilteringRulesOverrideGroups | undefined>;
    /**
     * Name-ID pairs of users for which this rule can be overridden.
     */
    declare public readonly overrideUsers: pulumi.Output<outputs.URLFilteringRulesOverrideUsers | undefined>;
    /**
     * Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
     */
    declare public readonly protocols: pulumi.Output<string[]>;
    /**
     * Admin rank of the Firewall Filtering policy rule
     */
    declare public readonly rank: pulumi.Output<number | undefined>;
    /**
     * Request method for which the rule must be applied. If not set, rule will be applied to all methods
     */
    declare public readonly requestMethods: pulumi.Output<string[] | undefined>;
    /**
     * URL Filtering Rule ID
     */
    declare public /*out*/ readonly ruleId: pulumi.Output<number>;
    /**
     * Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
     */
    declare public readonly sizeQuota: pulumi.Output<number | undefined>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    declare public readonly sourceCountries: pulumi.Output<string[]>;
    /**
     * list of source ip groups
     */
    declare public readonly sourceIpGroups: pulumi.Output<outputs.URLFilteringRulesSourceIpGroups | undefined>;
    declare public readonly state: pulumi.Output<string | undefined>;
    /**
     * Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
     */
    declare public readonly timeQuota: pulumi.Output<number | undefined>;
    /**
     * Name-ID pairs of time interval during which rule must be enforced.
     */
    declare public readonly timeWindows: pulumi.Output<outputs.URLFilteringRulesTimeWindows | undefined>;
    /**
     * The list of URL Categories to which the SSL inspection rule must be applied.
     * 				See the URL Categories API for the list of available categories:
     * 				https://help.zscaler.com/zia/url-categories#/urlCategories-get
     */
    declare public readonly urlCategories: pulumi.Output<string[] | undefined>;
    /**
     * Supported User Agent Types
     */
    declare public readonly userAgentTypes: pulumi.Output<string[] | undefined>;
    declare public readonly userRiskScoreLevels: pulumi.Output<string[] | undefined>;
    /**
     * Name-ID pairs of users for which rule must be applied
     */
    declare public readonly users: pulumi.Output<outputs.URLFilteringRulesUsers | undefined>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
     */
    declare public readonly validityEndTime: pulumi.Output<string | undefined>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
     */
    declare public readonly validityStartTime: pulumi.Output<string | undefined>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID.
     * 				Use IANA Format TimeZone. Visit https://nodatime.org/TimeZones for the complete IANA timezone list
     */
    declare public readonly validityTimeZoneId: pulumi.Output<string | undefined>;
    /**
     * The list of preconfigured workload groups to which the policy must be applied
     */
    declare public readonly workloadGroups: pulumi.Output<outputs.URLFilteringRulesWorkloadGroup[]>;

    /**
     * Create a URLFilteringRules resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: URLFilteringRulesArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: URLFilteringRulesArgs | URLFilteringRulesState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as URLFilteringRulesState | undefined;
            resourceInputs["action"] = state?.action;
            resourceInputs["blockOverride"] = state?.blockOverride;
            resourceInputs["browserEunTemplateId"] = state?.browserEunTemplateId;
            resourceInputs["cbiProfiles"] = state?.cbiProfiles;
            resourceInputs["ciparule"] = state?.ciparule;
            resourceInputs["departments"] = state?.departments;
            resourceInputs["description"] = state?.description;
            resourceInputs["deviceGroups"] = state?.deviceGroups;
            resourceInputs["deviceTrustLevels"] = state?.deviceTrustLevels;
            resourceInputs["devices"] = state?.devices;
            resourceInputs["endUserNotificationUrl"] = state?.endUserNotificationUrl;
            resourceInputs["enforceTimeValidity"] = state?.enforceTimeValidity;
            resourceInputs["groups"] = state?.groups;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["locationGroups"] = state?.locationGroups;
            resourceInputs["locations"] = state?.locations;
            resourceInputs["name"] = state?.name;
            resourceInputs["order"] = state?.order;
            resourceInputs["overrideGroups"] = state?.overrideGroups;
            resourceInputs["overrideUsers"] = state?.overrideUsers;
            resourceInputs["protocols"] = state?.protocols;
            resourceInputs["rank"] = state?.rank;
            resourceInputs["requestMethods"] = state?.requestMethods;
            resourceInputs["ruleId"] = state?.ruleId;
            resourceInputs["sizeQuota"] = state?.sizeQuota;
            resourceInputs["sourceCountries"] = state?.sourceCountries;
            resourceInputs["sourceIpGroups"] = state?.sourceIpGroups;
            resourceInputs["state"] = state?.state;
            resourceInputs["timeQuota"] = state?.timeQuota;
            resourceInputs["timeWindows"] = state?.timeWindows;
            resourceInputs["urlCategories"] = state?.urlCategories;
            resourceInputs["userAgentTypes"] = state?.userAgentTypes;
            resourceInputs["userRiskScoreLevels"] = state?.userRiskScoreLevels;
            resourceInputs["users"] = state?.users;
            resourceInputs["validityEndTime"] = state?.validityEndTime;
            resourceInputs["validityStartTime"] = state?.validityStartTime;
            resourceInputs["validityTimeZoneId"] = state?.validityTimeZoneId;
            resourceInputs["workloadGroups"] = state?.workloadGroups;
        } else {
            const args = argsOrState as URLFilteringRulesArgs | undefined;
            if (args?.order === undefined && !opts.urn) {
                throw new Error("Missing required property 'order'");
            }
            if (args?.protocols === undefined && !opts.urn) {
                throw new Error("Missing required property 'protocols'");
            }
            resourceInputs["action"] = args?.action;
            resourceInputs["blockOverride"] = args?.blockOverride;
            resourceInputs["browserEunTemplateId"] = args?.browserEunTemplateId;
            resourceInputs["cbiProfiles"] = args?.cbiProfiles;
            resourceInputs["ciparule"] = args?.ciparule;
            resourceInputs["departments"] = args?.departments;
            resourceInputs["description"] = args?.description;
            resourceInputs["deviceGroups"] = args?.deviceGroups;
            resourceInputs["deviceTrustLevels"] = args?.deviceTrustLevels;
            resourceInputs["devices"] = args?.devices;
            resourceInputs["endUserNotificationUrl"] = args?.endUserNotificationUrl;
            resourceInputs["enforceTimeValidity"] = args?.enforceTimeValidity;
            resourceInputs["groups"] = args?.groups;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["locationGroups"] = args?.locationGroups;
            resourceInputs["locations"] = args?.locations;
            resourceInputs["name"] = args?.name;
            resourceInputs["order"] = args?.order;
            resourceInputs["overrideGroups"] = args?.overrideGroups;
            resourceInputs["overrideUsers"] = args?.overrideUsers;
            resourceInputs["protocols"] = args?.protocols;
            resourceInputs["rank"] = args?.rank;
            resourceInputs["requestMethods"] = args?.requestMethods;
            resourceInputs["sizeQuota"] = args?.sizeQuota;
            resourceInputs["sourceCountries"] = args?.sourceCountries;
            resourceInputs["sourceIpGroups"] = args?.sourceIpGroups;
            resourceInputs["state"] = args?.state;
            resourceInputs["timeQuota"] = args?.timeQuota;
            resourceInputs["timeWindows"] = args?.timeWindows;
            resourceInputs["urlCategories"] = args?.urlCategories;
            resourceInputs["userAgentTypes"] = args?.userAgentTypes;
            resourceInputs["userRiskScoreLevels"] = args?.userRiskScoreLevels;
            resourceInputs["users"] = args?.users;
            resourceInputs["validityEndTime"] = args?.validityEndTime;
            resourceInputs["validityStartTime"] = args?.validityStartTime;
            resourceInputs["validityTimeZoneId"] = args?.validityTimeZoneId;
            resourceInputs["workloadGroups"] = args?.workloadGroups;
            resourceInputs["ruleId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(URLFilteringRules.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering URLFilteringRules resources.
 */
export interface URLFilteringRulesState {
    /**
     * Action taken when traffic matches rule criteria
     */
    action?: pulumi.Input<string>;
    blockOverride?: pulumi.Input<boolean>;
    browserEunTemplateId?: pulumi.Input<number>;
    cbiProfiles?: pulumi.Input<pulumi.Input<inputs.URLFilteringRulesCbiProfile>[]>;
    /**
     * If set to true, the CIPA Compliance rule is enabled
     */
    ciparule?: pulumi.Input<boolean>;
    /**
     * Name-ID pairs of departments for which rule must be applied
     */
    departments?: pulumi.Input<inputs.URLFilteringRulesDepartments>;
    /**
     * Additional information about the URL Filtering rule
     */
    description?: pulumi.Input<string>;
    /**
     * This field is applicable for devices that are managed using Zscaler Client Connector.
     */
    deviceGroups?: pulumi.Input<inputs.URLFilteringRulesDeviceGroups>;
    /**
     * List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
     */
    deviceTrustLevels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name-ID pairs of devices for which rule must be applied.
     */
    devices?: pulumi.Input<inputs.URLFilteringRulesDevices>;
    /**
     * URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
     */
    endUserNotificationUrl?: pulumi.Input<string>;
    /**
     * Enforce a set a validity time period for the URL Filtering rule.
     */
    enforceTimeValidity?: pulumi.Input<boolean>;
    /**
     * Name-ID pairs of groups for which rule must be applied
     */
    groups?: pulumi.Input<inputs.URLFilteringRulesGroups>;
    /**
     * The URL Filtering rule's label.
     */
    labels?: pulumi.Input<inputs.URLFilteringRulesLabels>;
    /**
     * Name-ID pairs of the location groups to which the rule must be applied.
     */
    locationGroups?: pulumi.Input<inputs.URLFilteringRulesLocationGroups>;
    /**
     * Name-ID pairs of locations for which rule must be applied
     */
    locations?: pulumi.Input<inputs.URLFilteringRulesLocations>;
    /**
     * Name of the Firewall Filtering policy rule
     */
    name?: pulumi.Input<string>;
    /**
     * Order of execution of rule with respect to other URL Filtering rules
     */
    order?: pulumi.Input<number>;
    /**
     * Name-ID pairs of groups for which this rule can be overridden.
     */
    overrideGroups?: pulumi.Input<inputs.URLFilteringRulesOverrideGroups>;
    /**
     * Name-ID pairs of users for which this rule can be overridden.
     */
    overrideUsers?: pulumi.Input<inputs.URLFilteringRulesOverrideUsers>;
    /**
     * Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Admin rank of the Firewall Filtering policy rule
     */
    rank?: pulumi.Input<number>;
    /**
     * Request method for which the rule must be applied. If not set, rule will be applied to all methods
     */
    requestMethods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * URL Filtering Rule ID
     */
    ruleId?: pulumi.Input<number>;
    /**
     * Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
     */
    sizeQuota?: pulumi.Input<number>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    sourceCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of source ip groups
     */
    sourceIpGroups?: pulumi.Input<inputs.URLFilteringRulesSourceIpGroups>;
    state?: pulumi.Input<string>;
    /**
     * Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
     */
    timeQuota?: pulumi.Input<number>;
    /**
     * Name-ID pairs of time interval during which rule must be enforced.
     */
    timeWindows?: pulumi.Input<inputs.URLFilteringRulesTimeWindows>;
    /**
     * The list of URL Categories to which the SSL inspection rule must be applied.
     * 				See the URL Categories API for the list of available categories:
     * 				https://help.zscaler.com/zia/url-categories#/urlCategories-get
     */
    urlCategories?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Supported User Agent Types
     */
    userAgentTypes?: pulumi.Input<pulumi.Input<string>[]>;
    userRiskScoreLevels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name-ID pairs of users for which rule must be applied
     */
    users?: pulumi.Input<inputs.URLFilteringRulesUsers>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
     */
    validityEndTime?: pulumi.Input<string>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
     */
    validityStartTime?: pulumi.Input<string>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID.
     * 				Use IANA Format TimeZone. Visit https://nodatime.org/TimeZones for the complete IANA timezone list
     */
    validityTimeZoneId?: pulumi.Input<string>;
    /**
     * The list of preconfigured workload groups to which the policy must be applied
     */
    workloadGroups?: pulumi.Input<pulumi.Input<inputs.URLFilteringRulesWorkloadGroup>[]>;
}

/**
 * The set of arguments for constructing a URLFilteringRules resource.
 */
export interface URLFilteringRulesArgs {
    /**
     * Action taken when traffic matches rule criteria
     */
    action?: pulumi.Input<string>;
    blockOverride?: pulumi.Input<boolean>;
    browserEunTemplateId?: pulumi.Input<number>;
    cbiProfiles?: pulumi.Input<pulumi.Input<inputs.URLFilteringRulesCbiProfile>[]>;
    /**
     * If set to true, the CIPA Compliance rule is enabled
     */
    ciparule?: pulumi.Input<boolean>;
    /**
     * Name-ID pairs of departments for which rule must be applied
     */
    departments?: pulumi.Input<inputs.URLFilteringRulesDepartments>;
    /**
     * Additional information about the URL Filtering rule
     */
    description?: pulumi.Input<string>;
    /**
     * This field is applicable for devices that are managed using Zscaler Client Connector.
     */
    deviceGroups?: pulumi.Input<inputs.URLFilteringRulesDeviceGroups>;
    /**
     * List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
     */
    deviceTrustLevels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name-ID pairs of devices for which rule must be applied.
     */
    devices?: pulumi.Input<inputs.URLFilteringRulesDevices>;
    /**
     * URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
     */
    endUserNotificationUrl?: pulumi.Input<string>;
    /**
     * Enforce a set a validity time period for the URL Filtering rule.
     */
    enforceTimeValidity?: pulumi.Input<boolean>;
    /**
     * Name-ID pairs of groups for which rule must be applied
     */
    groups?: pulumi.Input<inputs.URLFilteringRulesGroups>;
    /**
     * The URL Filtering rule's label.
     */
    labels?: pulumi.Input<inputs.URLFilteringRulesLabels>;
    /**
     * Name-ID pairs of the location groups to which the rule must be applied.
     */
    locationGroups?: pulumi.Input<inputs.URLFilteringRulesLocationGroups>;
    /**
     * Name-ID pairs of locations for which rule must be applied
     */
    locations?: pulumi.Input<inputs.URLFilteringRulesLocations>;
    /**
     * Name of the Firewall Filtering policy rule
     */
    name?: pulumi.Input<string>;
    /**
     * Order of execution of rule with respect to other URL Filtering rules
     */
    order: pulumi.Input<number>;
    /**
     * Name-ID pairs of groups for which this rule can be overridden.
     */
    overrideGroups?: pulumi.Input<inputs.URLFilteringRulesOverrideGroups>;
    /**
     * Name-ID pairs of users for which this rule can be overridden.
     */
    overrideUsers?: pulumi.Input<inputs.URLFilteringRulesOverrideUsers>;
    /**
     * Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
     */
    protocols: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Admin rank of the Firewall Filtering policy rule
     */
    rank?: pulumi.Input<number>;
    /**
     * Request method for which the rule must be applied. If not set, rule will be applied to all methods
     */
    requestMethods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
     */
    sizeQuota?: pulumi.Input<number>;
    /**
     * Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
     */
    sourceCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of source ip groups
     */
    sourceIpGroups?: pulumi.Input<inputs.URLFilteringRulesSourceIpGroups>;
    state?: pulumi.Input<string>;
    /**
     * Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
     */
    timeQuota?: pulumi.Input<number>;
    /**
     * Name-ID pairs of time interval during which rule must be enforced.
     */
    timeWindows?: pulumi.Input<inputs.URLFilteringRulesTimeWindows>;
    /**
     * The list of URL Categories to which the SSL inspection rule must be applied.
     * 				See the URL Categories API for the list of available categories:
     * 				https://help.zscaler.com/zia/url-categories#/urlCategories-get
     */
    urlCategories?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Supported User Agent Types
     */
    userAgentTypes?: pulumi.Input<pulumi.Input<string>[]>;
    userRiskScoreLevels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name-ID pairs of users for which rule must be applied
     */
    users?: pulumi.Input<inputs.URLFilteringRulesUsers>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
     */
    validityEndTime?: pulumi.Input<string>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
     */
    validityStartTime?: pulumi.Input<string>;
    /**
     * If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID.
     * 				Use IANA Format TimeZone. Visit https://nodatime.org/TimeZones for the complete IANA timezone list
     */
    validityTimeZoneId?: pulumi.Input<string>;
    /**
     * The list of preconfigured workload groups to which the policy must be applied
     */
    workloadGroups?: pulumi.Input<pulumi.Input<inputs.URLFilteringRulesWorkloadGroup>[]>;
}

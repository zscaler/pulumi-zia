# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['FirewallDNSRuleArgs', 'FirewallDNSRule']

@pulumi.input_type
class FirewallDNSRuleArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[builtins.int],
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 application_groups: Optional[pulumi.Input['FirewallDNSRuleApplicationGroupsArgs']] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_response_code: Optional[pulumi.Input[builtins.str]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 default_rule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input['FirewallDNSRuleDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input['FirewallDNSRuleDestIpGroupsArgs']] = None,
                 dest_ipv6_groups: Optional[pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs']] = None,
                 device_groups: Optional[pulumi.Input['FirewallDNSRuleDeviceGroupsArgs']] = None,
                 devices: Optional[pulumi.Input['FirewallDNSRuleDevicesArgs']] = None,
                 dns_gateway: Optional[pulumi.Input['FirewallDNSRuleDnsGatewayArgs']] = None,
                 dns_rule_request_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 edns_ecs_object: Optional[pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs']] = None,
                 groups: Optional[pulumi.Input['FirewallDNSRuleGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['FirewallDNSRuleLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['FirewallDNSRuleLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['FirewallDNSRuleLocationsArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 predefined: Optional[pulumi.Input[builtins.bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 redirect_ip: Optional[pulumi.Input[builtins.str]] = None,
                 res_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs']] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ipv6_groups: Optional[pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs']] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['FirewallDNSRuleTimeWindowsArgs']] = None,
                 users: Optional[pulumi.Input['FirewallDNSRuleUsersArgs']] = None,
                 zpa_ip_group: Optional[pulumi.Input['FirewallDNSRuleZpaIpGroupArgs']] = None):
        """
        The set of arguments for constructing a FirewallDNSRule resource.
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[builtins.str] action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        :param pulumi.Input['FirewallDNSRuleApplicationGroupsArgs'] application_groups: (List of Objects) DNS application groups to which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] applications: (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        :param pulumi.Input[builtins.str] block_response_code: (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
               `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        :param pulumi.Input[builtins.bool] capture_pcap: (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[builtins.bool] default_rule: (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        :param pulumi.Input['FirewallDNSRuleDepartmentsArgs'] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_addresses: (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_countries: (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_ip_categories: (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        :param pulumi.Input['FirewallDNSRuleDestIpGroupsArgs'] dest_ip_groups: ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        :param pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs'] dest_ipv6_groups: list of destination ip groups
        :param pulumi.Input['FirewallDNSRuleDeviceGroupsArgs'] device_groups: (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['FirewallDNSRuleDevicesArgs'] devices: (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['FirewallDNSRuleDnsGatewayArgs'] dns_gateway: (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_rule_request_types: (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
               `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
               `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
               `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
               `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
               `ZONEMD`, `SVCB`, `HTTPS`,
        :param pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs'] edns_ecs_object: (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        :param pulumi.Input['FirewallDNSRuleGroupsArgs'] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input['FirewallDNSRuleLabelsArgs'] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input['FirewallDNSRuleLocationGroupsArgs'] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input['FirewallDNSRuleLocationsArgs'] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.bool] predefined: (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        :param pulumi.Input[builtins.int] rank: (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        :param pulumi.Input[builtins.str] redirect_ip: (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] res_categories: (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_countries: (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs'] src_ip_groups: (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] src_ips: (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs'] src_ipv6_groups: (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        :param pulumi.Input[builtins.str] state: (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        :param pulumi.Input['FirewallDNSRuleTimeWindowsArgs'] time_windows: (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        :param pulumi.Input['FirewallDNSRuleUsersArgs'] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input['FirewallDNSRuleZpaIpGroupArgs'] zpa_ip_group: (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        pulumi.set(__self__, "order", order)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if application_groups is not None:
            pulumi.set(__self__, "application_groups", application_groups)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if capture_pcap is not None:
            pulumi.set(__self__, "capture_pcap", capture_pcap)
        if default_rule is not None:
            pulumi.set(__self__, "default_rule", default_rule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dest_addresses is not None:
            pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries is not None:
            pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories is not None:
            pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups is not None:
            pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if dest_ipv6_groups is not None:
            pulumi.set(__self__, "dest_ipv6_groups", dest_ipv6_groups)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if dns_gateway is not None:
            pulumi.set(__self__, "dns_gateway", dns_gateway)
        if dns_rule_request_types is not None:
            pulumi.set(__self__, "dns_rule_request_types", dns_rule_request_types)
        if edns_ecs_object is not None:
            pulumi.set(__self__, "edns_ecs_object", edns_ecs_object)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if redirect_ip is not None:
            pulumi.set(__self__, "redirect_ip", redirect_ip)
        if res_categories is not None:
            pulumi.set(__self__, "res_categories", res_categories)
        if source_countries is not None:
            pulumi.set(__self__, "source_countries", source_countries)
        if src_ip_groups is not None:
            pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if src_ipv6_groups is not None:
            pulumi.set(__self__, "src_ipv6_groups", src_ipv6_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if zpa_ip_group is not None:
            pulumi.set(__self__, "zpa_ip_group", zpa_ip_group)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[builtins.int]:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="applicationGroups")
    def application_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleApplicationGroupsArgs']]:
        """
        (List of Objects) DNS application groups to which the rule applies
        """
        return pulumi.get(self, "application_groups")

    @application_groups.setter
    def application_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleApplicationGroupsArgs']]):
        pulumi.set(self, "application_groups", value)

    @property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "applications", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
        `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @capture_pcap.setter
    def capture_pcap(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "capture_pcap", value)

    @property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        """
        return pulumi.get(self, "default_rule")

    @default_rule.setter
    def default_rule(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "default_rule", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['FirewallDNSRuleDepartmentsArgs']]:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['FirewallDNSRuleDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "dest_addresses")

    @dest_addresses.setter
    def dest_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dest_addresses", value)

    @property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "dest_countries")

    @dest_countries.setter
    def dest_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dest_countries", value)

    @property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        """
        return pulumi.get(self, "dest_ip_categories")

    @dest_ip_categories.setter
    def dest_ip_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dest_ip_categories", value)

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleDestIpGroupsArgs']]:
        """
        ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ip_groups")

    @dest_ip_groups.setter
    def dest_ip_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleDestIpGroupsArgs']]):
        pulumi.set(self, "dest_ip_groups", value)

    @property
    @pulumi.getter(name="destIpv6Groups")
    def dest_ipv6_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs']]:
        """
        list of destination ip groups
        """
        return pulumi.get(self, "dest_ipv6_groups")

    @dest_ipv6_groups.setter
    def dest_ipv6_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs']]):
        pulumi.set(self, "dest_ipv6_groups", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleDeviceGroupsArgs']]:
        """
        (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['FirewallDNSRuleDevicesArgs']]:
        """
        (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['FirewallDNSRuleDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="dnsGateway")
    def dns_gateway(self) -> Optional[pulumi.Input['FirewallDNSRuleDnsGatewayArgs']]:
        """
        (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        """
        return pulumi.get(self, "dns_gateway")

    @dns_gateway.setter
    def dns_gateway(self, value: Optional[pulumi.Input['FirewallDNSRuleDnsGatewayArgs']]):
        pulumi.set(self, "dns_gateway", value)

    @property
    @pulumi.getter(name="dnsRuleRequestTypes")
    def dns_rule_request_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
        `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
        `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
        `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
        `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
        `ZONEMD`, `SVCB`, `HTTPS`,
        """
        return pulumi.get(self, "dns_rule_request_types")

    @dns_rule_request_types.setter
    def dns_rule_request_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_rule_request_types", value)

    @property
    @pulumi.getter(name="ednsEcsObject")
    def edns_ecs_object(self) -> Optional[pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs']]:
        """
        (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        """
        return pulumi.get(self, "edns_ecs_object")

    @edns_ecs_object.setter
    def edns_ecs_object(self, value: Optional[pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs']]):
        pulumi.set(self, "edns_ecs_object", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['FirewallDNSRuleGroupsArgs']]:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['FirewallDNSRuleGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['FirewallDNSRuleLabelsArgs']]:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['FirewallDNSRuleLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleLocationGroupsArgs']]:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['FirewallDNSRuleLocationsArgs']]:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['FirewallDNSRuleLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def predefined(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        """
        return pulumi.get(self, "predefined")

    @predefined.setter
    def predefined(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "predefined", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="redirectIp")
    def redirect_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        """
        return pulumi.get(self, "redirect_ip")

    @redirect_ip.setter
    def redirect_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_ip", value)

    @property
    @pulumi.getter(name="resCategories")
    def res_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        """
        return pulumi.get(self, "res_categories")

    @res_categories.setter
    def res_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "res_categories", value)

    @property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "source_countries")

    @source_countries.setter
    def source_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "source_countries", value)

    @property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs']]:
        """
        (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        """
        return pulumi.get(self, "src_ip_groups")

    @src_ip_groups.setter
    def src_ip_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs']]):
        pulumi.set(self, "src_ip_groups", value)

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "src_ips")

    @src_ips.setter
    def src_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "src_ips", value)

    @property
    @pulumi.getter(name="srcIpv6Groups")
    def src_ipv6_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs']]:
        """
        (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        """
        return pulumi.get(self, "src_ipv6_groups")

    @src_ipv6_groups.setter
    def src_ipv6_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs']]):
        pulumi.set(self, "src_ipv6_groups", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['FirewallDNSRuleTimeWindowsArgs']]:
        """
        (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['FirewallDNSRuleTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['FirewallDNSRuleUsersArgs']]:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['FirewallDNSRuleUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="zpaIpGroup")
    def zpa_ip_group(self) -> Optional[pulumi.Input['FirewallDNSRuleZpaIpGroupArgs']]:
        """
        (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        return pulumi.get(self, "zpa_ip_group")

    @zpa_ip_group.setter
    def zpa_ip_group(self, value: Optional[pulumi.Input['FirewallDNSRuleZpaIpGroupArgs']]):
        pulumi.set(self, "zpa_ip_group", value)


@pulumi.input_type
class _FirewallDNSRuleState:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 application_groups: Optional[pulumi.Input['FirewallDNSRuleApplicationGroupsArgs']] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_response_code: Optional[pulumi.Input[builtins.str]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 default_rule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input['FirewallDNSRuleDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input['FirewallDNSRuleDestIpGroupsArgs']] = None,
                 dest_ipv6_groups: Optional[pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs']] = None,
                 device_groups: Optional[pulumi.Input['FirewallDNSRuleDeviceGroupsArgs']] = None,
                 devices: Optional[pulumi.Input['FirewallDNSRuleDevicesArgs']] = None,
                 dns_gateway: Optional[pulumi.Input['FirewallDNSRuleDnsGatewayArgs']] = None,
                 dns_rule_request_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 edns_ecs_object: Optional[pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs']] = None,
                 groups: Optional[pulumi.Input['FirewallDNSRuleGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['FirewallDNSRuleLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['FirewallDNSRuleLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['FirewallDNSRuleLocationsArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 predefined: Optional[pulumi.Input[builtins.bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 redirect_ip: Optional[pulumi.Input[builtins.str]] = None,
                 res_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rule_id: Optional[pulumi.Input[builtins.int]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs']] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ipv6_groups: Optional[pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs']] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['FirewallDNSRuleTimeWindowsArgs']] = None,
                 users: Optional[pulumi.Input['FirewallDNSRuleUsersArgs']] = None,
                 zpa_ip_group: Optional[pulumi.Input['FirewallDNSRuleZpaIpGroupArgs']] = None):
        """
        Input properties used for looking up and filtering FirewallDNSRule resources.
        :param pulumi.Input[builtins.str] action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        :param pulumi.Input['FirewallDNSRuleApplicationGroupsArgs'] application_groups: (List of Objects) DNS application groups to which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] applications: (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        :param pulumi.Input[builtins.str] block_response_code: (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
               `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        :param pulumi.Input[builtins.bool] capture_pcap: (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[builtins.bool] default_rule: (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        :param pulumi.Input['FirewallDNSRuleDepartmentsArgs'] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_addresses: (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_countries: (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_ip_categories: (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        :param pulumi.Input['FirewallDNSRuleDestIpGroupsArgs'] dest_ip_groups: ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        :param pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs'] dest_ipv6_groups: list of destination ip groups
        :param pulumi.Input['FirewallDNSRuleDeviceGroupsArgs'] device_groups: (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['FirewallDNSRuleDevicesArgs'] devices: (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['FirewallDNSRuleDnsGatewayArgs'] dns_gateway: (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_rule_request_types: (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
               `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
               `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
               `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
               `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
               `ZONEMD`, `SVCB`, `HTTPS`,
        :param pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs'] edns_ecs_object: (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        :param pulumi.Input['FirewallDNSRuleGroupsArgs'] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input['FirewallDNSRuleLabelsArgs'] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input['FirewallDNSRuleLocationGroupsArgs'] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input['FirewallDNSRuleLocationsArgs'] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[builtins.bool] predefined: (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        :param pulumi.Input[builtins.int] rank: (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        :param pulumi.Input[builtins.str] redirect_ip: (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] res_categories: (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_countries: (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs'] src_ip_groups: (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] src_ips: (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs'] src_ipv6_groups: (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        :param pulumi.Input[builtins.str] state: (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        :param pulumi.Input['FirewallDNSRuleTimeWindowsArgs'] time_windows: (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        :param pulumi.Input['FirewallDNSRuleUsersArgs'] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input['FirewallDNSRuleZpaIpGroupArgs'] zpa_ip_group: (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if application_groups is not None:
            pulumi.set(__self__, "application_groups", application_groups)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if capture_pcap is not None:
            pulumi.set(__self__, "capture_pcap", capture_pcap)
        if default_rule is not None:
            pulumi.set(__self__, "default_rule", default_rule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dest_addresses is not None:
            pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries is not None:
            pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories is not None:
            pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups is not None:
            pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if dest_ipv6_groups is not None:
            pulumi.set(__self__, "dest_ipv6_groups", dest_ipv6_groups)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if dns_gateway is not None:
            pulumi.set(__self__, "dns_gateway", dns_gateway)
        if dns_rule_request_types is not None:
            pulumi.set(__self__, "dns_rule_request_types", dns_rule_request_types)
        if edns_ecs_object is not None:
            pulumi.set(__self__, "edns_ecs_object", edns_ecs_object)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if redirect_ip is not None:
            pulumi.set(__self__, "redirect_ip", redirect_ip)
        if res_categories is not None:
            pulumi.set(__self__, "res_categories", res_categories)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if source_countries is not None:
            pulumi.set(__self__, "source_countries", source_countries)
        if src_ip_groups is not None:
            pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if src_ipv6_groups is not None:
            pulumi.set(__self__, "src_ipv6_groups", src_ipv6_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if zpa_ip_group is not None:
            pulumi.set(__self__, "zpa_ip_group", zpa_ip_group)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="applicationGroups")
    def application_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleApplicationGroupsArgs']]:
        """
        (List of Objects) DNS application groups to which the rule applies
        """
        return pulumi.get(self, "application_groups")

    @application_groups.setter
    def application_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleApplicationGroupsArgs']]):
        pulumi.set(self, "application_groups", value)

    @property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "applications", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
        `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @capture_pcap.setter
    def capture_pcap(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "capture_pcap", value)

    @property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        """
        return pulumi.get(self, "default_rule")

    @default_rule.setter
    def default_rule(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "default_rule", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['FirewallDNSRuleDepartmentsArgs']]:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['FirewallDNSRuleDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "dest_addresses")

    @dest_addresses.setter
    def dest_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dest_addresses", value)

    @property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "dest_countries")

    @dest_countries.setter
    def dest_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dest_countries", value)

    @property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        """
        return pulumi.get(self, "dest_ip_categories")

    @dest_ip_categories.setter
    def dest_ip_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dest_ip_categories", value)

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleDestIpGroupsArgs']]:
        """
        ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ip_groups")

    @dest_ip_groups.setter
    def dest_ip_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleDestIpGroupsArgs']]):
        pulumi.set(self, "dest_ip_groups", value)

    @property
    @pulumi.getter(name="destIpv6Groups")
    def dest_ipv6_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs']]:
        """
        list of destination ip groups
        """
        return pulumi.get(self, "dest_ipv6_groups")

    @dest_ipv6_groups.setter
    def dest_ipv6_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleDestIpv6GroupsArgs']]):
        pulumi.set(self, "dest_ipv6_groups", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleDeviceGroupsArgs']]:
        """
        (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['FirewallDNSRuleDevicesArgs']]:
        """
        (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['FirewallDNSRuleDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="dnsGateway")
    def dns_gateway(self) -> Optional[pulumi.Input['FirewallDNSRuleDnsGatewayArgs']]:
        """
        (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        """
        return pulumi.get(self, "dns_gateway")

    @dns_gateway.setter
    def dns_gateway(self, value: Optional[pulumi.Input['FirewallDNSRuleDnsGatewayArgs']]):
        pulumi.set(self, "dns_gateway", value)

    @property
    @pulumi.getter(name="dnsRuleRequestTypes")
    def dns_rule_request_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
        `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
        `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
        `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
        `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
        `ZONEMD`, `SVCB`, `HTTPS`,
        """
        return pulumi.get(self, "dns_rule_request_types")

    @dns_rule_request_types.setter
    def dns_rule_request_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_rule_request_types", value)

    @property
    @pulumi.getter(name="ednsEcsObject")
    def edns_ecs_object(self) -> Optional[pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs']]:
        """
        (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        """
        return pulumi.get(self, "edns_ecs_object")

    @edns_ecs_object.setter
    def edns_ecs_object(self, value: Optional[pulumi.Input['FirewallDNSRuleEdnsEcsObjectArgs']]):
        pulumi.set(self, "edns_ecs_object", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['FirewallDNSRuleGroupsArgs']]:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['FirewallDNSRuleGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['FirewallDNSRuleLabelsArgs']]:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['FirewallDNSRuleLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleLocationGroupsArgs']]:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['FirewallDNSRuleLocationsArgs']]:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['FirewallDNSRuleLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def predefined(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        """
        return pulumi.get(self, "predefined")

    @predefined.setter
    def predefined(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "predefined", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="redirectIp")
    def redirect_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        """
        return pulumi.get(self, "redirect_ip")

    @redirect_ip.setter
    def redirect_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_ip", value)

    @property
    @pulumi.getter(name="resCategories")
    def res_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        """
        return pulumi.get(self, "res_categories")

    @res_categories.setter
    def res_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "res_categories", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "source_countries")

    @source_countries.setter
    def source_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "source_countries", value)

    @property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs']]:
        """
        (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        """
        return pulumi.get(self, "src_ip_groups")

    @src_ip_groups.setter
    def src_ip_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleSrcIpGroupsArgs']]):
        pulumi.set(self, "src_ip_groups", value)

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "src_ips")

    @src_ips.setter
    def src_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "src_ips", value)

    @property
    @pulumi.getter(name="srcIpv6Groups")
    def src_ipv6_groups(self) -> Optional[pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs']]:
        """
        (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        """
        return pulumi.get(self, "src_ipv6_groups")

    @src_ipv6_groups.setter
    def src_ipv6_groups(self, value: Optional[pulumi.Input['FirewallDNSRuleSrcIpv6GroupsArgs']]):
        pulumi.set(self, "src_ipv6_groups", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['FirewallDNSRuleTimeWindowsArgs']]:
        """
        (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['FirewallDNSRuleTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['FirewallDNSRuleUsersArgs']]:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['FirewallDNSRuleUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="zpaIpGroup")
    def zpa_ip_group(self) -> Optional[pulumi.Input['FirewallDNSRuleZpaIpGroupArgs']]:
        """
        (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        return pulumi.get(self, "zpa_ip_group")

    @zpa_ip_group.setter
    def zpa_ip_group(self, value: Optional[pulumi.Input['FirewallDNSRuleZpaIpGroupArgs']]):
        pulumi.set(self, "zpa_ip_group", value)


@pulumi.type_token("zia:index/firewallDNSRule:FirewallDNSRule")
class FirewallDNSRule(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 application_groups: Optional[pulumi.Input[Union['FirewallDNSRuleApplicationGroupsArgs', 'FirewallDNSRuleApplicationGroupsArgsDict']]] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_response_code: Optional[pulumi.Input[builtins.str]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 default_rule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input[Union['FirewallDNSRuleDepartmentsArgs', 'FirewallDNSRuleDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDestIpGroupsArgs', 'FirewallDNSRuleDestIpGroupsArgsDict']]] = None,
                 dest_ipv6_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDestIpv6GroupsArgs', 'FirewallDNSRuleDestIpv6GroupsArgsDict']]] = None,
                 device_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDeviceGroupsArgs', 'FirewallDNSRuleDeviceGroupsArgsDict']]] = None,
                 devices: Optional[pulumi.Input[Union['FirewallDNSRuleDevicesArgs', 'FirewallDNSRuleDevicesArgsDict']]] = None,
                 dns_gateway: Optional[pulumi.Input[Union['FirewallDNSRuleDnsGatewayArgs', 'FirewallDNSRuleDnsGatewayArgsDict']]] = None,
                 dns_rule_request_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 edns_ecs_object: Optional[pulumi.Input[Union['FirewallDNSRuleEdnsEcsObjectArgs', 'FirewallDNSRuleEdnsEcsObjectArgsDict']]] = None,
                 groups: Optional[pulumi.Input[Union['FirewallDNSRuleGroupsArgs', 'FirewallDNSRuleGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['FirewallDNSRuleLabelsArgs', 'FirewallDNSRuleLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['FirewallDNSRuleLocationGroupsArgs', 'FirewallDNSRuleLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['FirewallDNSRuleLocationsArgs', 'FirewallDNSRuleLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 predefined: Optional[pulumi.Input[builtins.bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 redirect_ip: Optional[pulumi.Input[builtins.str]] = None,
                 res_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input[Union['FirewallDNSRuleSrcIpGroupsArgs', 'FirewallDNSRuleSrcIpGroupsArgsDict']]] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ipv6_groups: Optional[pulumi.Input[Union['FirewallDNSRuleSrcIpv6GroupsArgs', 'FirewallDNSRuleSrcIpv6GroupsArgsDict']]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['FirewallDNSRuleTimeWindowsArgs', 'FirewallDNSRuleTimeWindowsArgsDict']]] = None,
                 users: Optional[pulumi.Input[Union['FirewallDNSRuleUsersArgs', 'FirewallDNSRuleUsersArgsDict']]] = None,
                 zpa_ip_group: Optional[pulumi.Input[Union['FirewallDNSRuleZpaIpGroupArgs', 'FirewallDNSRuleZpaIpGroupArgsDict']]] = None,
                 __props__=None):
        """
        ## Example Usage

        ### Create Firewall DNS Rules - Redirect Action

        ### Create Firewall DNS Rules - Redirect Request DOH

        ### Create Firewall DNS Rules - Redirect TCP Request

        resource "FirewallDNSRule" "this3" {
            name = "Example_DNS_Rule03"
            description = "Example_DNS_Rule03"
            action = "REDIR_REQ_TCP"
            state = "ENABLED"
            order = 13
            rank = 7
            dest_countries = ["CA", "US"]
            source_countries = ["CA", "US"]
            protocols = ["ANY_RULE"]
            dns_gateway {
              id = 18207342
              name = "DNS_GW01"
            }
        }

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.str] action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        :param pulumi.Input[Union['FirewallDNSRuleApplicationGroupsArgs', 'FirewallDNSRuleApplicationGroupsArgsDict']] application_groups: (List of Objects) DNS application groups to which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] applications: (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        :param pulumi.Input[builtins.str] block_response_code: (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
               `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        :param pulumi.Input[builtins.bool] capture_pcap: (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[builtins.bool] default_rule: (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        :param pulumi.Input[Union['FirewallDNSRuleDepartmentsArgs', 'FirewallDNSRuleDepartmentsArgsDict']] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_addresses: (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_countries: (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_ip_categories: (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        :param pulumi.Input[Union['FirewallDNSRuleDestIpGroupsArgs', 'FirewallDNSRuleDestIpGroupsArgsDict']] dest_ip_groups: ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        :param pulumi.Input[Union['FirewallDNSRuleDestIpv6GroupsArgs', 'FirewallDNSRuleDestIpv6GroupsArgsDict']] dest_ipv6_groups: list of destination ip groups
        :param pulumi.Input[Union['FirewallDNSRuleDeviceGroupsArgs', 'FirewallDNSRuleDeviceGroupsArgsDict']] device_groups: (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['FirewallDNSRuleDevicesArgs', 'FirewallDNSRuleDevicesArgsDict']] devices: (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['FirewallDNSRuleDnsGatewayArgs', 'FirewallDNSRuleDnsGatewayArgsDict']] dns_gateway: (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_rule_request_types: (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
               `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
               `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
               `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
               `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
               `ZONEMD`, `SVCB`, `HTTPS`,
        :param pulumi.Input[Union['FirewallDNSRuleEdnsEcsObjectArgs', 'FirewallDNSRuleEdnsEcsObjectArgsDict']] edns_ecs_object: (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        :param pulumi.Input[Union['FirewallDNSRuleGroupsArgs', 'FirewallDNSRuleGroupsArgsDict']] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[Union['FirewallDNSRuleLabelsArgs', 'FirewallDNSRuleLabelsArgsDict']] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input[Union['FirewallDNSRuleLocationGroupsArgs', 'FirewallDNSRuleLocationGroupsArgsDict']] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input[Union['FirewallDNSRuleLocationsArgs', 'FirewallDNSRuleLocationsArgsDict']] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[builtins.bool] predefined: (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        :param pulumi.Input[builtins.int] rank: (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        :param pulumi.Input[builtins.str] redirect_ip: (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] res_categories: (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_countries: (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input[Union['FirewallDNSRuleSrcIpGroupsArgs', 'FirewallDNSRuleSrcIpGroupsArgsDict']] src_ip_groups: (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] src_ips: (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input[Union['FirewallDNSRuleSrcIpv6GroupsArgs', 'FirewallDNSRuleSrcIpv6GroupsArgsDict']] src_ipv6_groups: (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        :param pulumi.Input[builtins.str] state: (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        :param pulumi.Input[Union['FirewallDNSRuleTimeWindowsArgs', 'FirewallDNSRuleTimeWindowsArgsDict']] time_windows: (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        :param pulumi.Input[Union['FirewallDNSRuleUsersArgs', 'FirewallDNSRuleUsersArgsDict']] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input[Union['FirewallDNSRuleZpaIpGroupArgs', 'FirewallDNSRuleZpaIpGroupArgsDict']] zpa_ip_group: (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: FirewallDNSRuleArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ### Create Firewall DNS Rules - Redirect Action

        ### Create Firewall DNS Rules - Redirect Request DOH

        ### Create Firewall DNS Rules - Redirect TCP Request

        resource "FirewallDNSRule" "this3" {
            name = "Example_DNS_Rule03"
            description = "Example_DNS_Rule03"
            action = "REDIR_REQ_TCP"
            state = "ENABLED"
            order = 13
            rank = 7
            dest_countries = ["CA", "US"]
            source_countries = ["CA", "US"]
            protocols = ["ANY_RULE"]
            dns_gateway {
              id = 18207342
              name = "DNS_GW01"
            }
        }

        :param str resource_name: The name of the resource.
        :param FirewallDNSRuleArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(FirewallDNSRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 application_groups: Optional[pulumi.Input[Union['FirewallDNSRuleApplicationGroupsArgs', 'FirewallDNSRuleApplicationGroupsArgsDict']]] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_response_code: Optional[pulumi.Input[builtins.str]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 default_rule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input[Union['FirewallDNSRuleDepartmentsArgs', 'FirewallDNSRuleDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDestIpGroupsArgs', 'FirewallDNSRuleDestIpGroupsArgsDict']]] = None,
                 dest_ipv6_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDestIpv6GroupsArgs', 'FirewallDNSRuleDestIpv6GroupsArgsDict']]] = None,
                 device_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDeviceGroupsArgs', 'FirewallDNSRuleDeviceGroupsArgsDict']]] = None,
                 devices: Optional[pulumi.Input[Union['FirewallDNSRuleDevicesArgs', 'FirewallDNSRuleDevicesArgsDict']]] = None,
                 dns_gateway: Optional[pulumi.Input[Union['FirewallDNSRuleDnsGatewayArgs', 'FirewallDNSRuleDnsGatewayArgsDict']]] = None,
                 dns_rule_request_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 edns_ecs_object: Optional[pulumi.Input[Union['FirewallDNSRuleEdnsEcsObjectArgs', 'FirewallDNSRuleEdnsEcsObjectArgsDict']]] = None,
                 groups: Optional[pulumi.Input[Union['FirewallDNSRuleGroupsArgs', 'FirewallDNSRuleGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['FirewallDNSRuleLabelsArgs', 'FirewallDNSRuleLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['FirewallDNSRuleLocationGroupsArgs', 'FirewallDNSRuleLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['FirewallDNSRuleLocationsArgs', 'FirewallDNSRuleLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 predefined: Optional[pulumi.Input[builtins.bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 redirect_ip: Optional[pulumi.Input[builtins.str]] = None,
                 res_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input[Union['FirewallDNSRuleSrcIpGroupsArgs', 'FirewallDNSRuleSrcIpGroupsArgsDict']]] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 src_ipv6_groups: Optional[pulumi.Input[Union['FirewallDNSRuleSrcIpv6GroupsArgs', 'FirewallDNSRuleSrcIpv6GroupsArgsDict']]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['FirewallDNSRuleTimeWindowsArgs', 'FirewallDNSRuleTimeWindowsArgsDict']]] = None,
                 users: Optional[pulumi.Input[Union['FirewallDNSRuleUsersArgs', 'FirewallDNSRuleUsersArgsDict']]] = None,
                 zpa_ip_group: Optional[pulumi.Input[Union['FirewallDNSRuleZpaIpGroupArgs', 'FirewallDNSRuleZpaIpGroupArgsDict']]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = FirewallDNSRuleArgs.__new__(FirewallDNSRuleArgs)

            __props__.__dict__["action"] = action
            __props__.__dict__["application_groups"] = application_groups
            __props__.__dict__["applications"] = applications
            __props__.__dict__["block_response_code"] = block_response_code
            __props__.__dict__["capture_pcap"] = capture_pcap
            __props__.__dict__["default_rule"] = default_rule
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            __props__.__dict__["dest_addresses"] = dest_addresses
            __props__.__dict__["dest_countries"] = dest_countries
            __props__.__dict__["dest_ip_categories"] = dest_ip_categories
            __props__.__dict__["dest_ip_groups"] = dest_ip_groups
            __props__.__dict__["dest_ipv6_groups"] = dest_ipv6_groups
            __props__.__dict__["device_groups"] = device_groups
            __props__.__dict__["devices"] = devices
            __props__.__dict__["dns_gateway"] = dns_gateway
            __props__.__dict__["dns_rule_request_types"] = dns_rule_request_types
            __props__.__dict__["edns_ecs_object"] = edns_ecs_object
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["name"] = name
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            __props__.__dict__["predefined"] = predefined
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["rank"] = rank
            __props__.__dict__["redirect_ip"] = redirect_ip
            __props__.__dict__["res_categories"] = res_categories
            __props__.__dict__["source_countries"] = source_countries
            __props__.__dict__["src_ip_groups"] = src_ip_groups
            __props__.__dict__["src_ips"] = src_ips
            __props__.__dict__["src_ipv6_groups"] = src_ipv6_groups
            __props__.__dict__["state"] = state
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["users"] = users
            __props__.__dict__["zpa_ip_group"] = zpa_ip_group
            __props__.__dict__["rule_id"] = None
        super(FirewallDNSRule, __self__).__init__(
            'zia:index/firewallDNSRule:FirewallDNSRule',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            action: Optional[pulumi.Input[builtins.str]] = None,
            application_groups: Optional[pulumi.Input[Union['FirewallDNSRuleApplicationGroupsArgs', 'FirewallDNSRuleApplicationGroupsArgsDict']]] = None,
            applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            block_response_code: Optional[pulumi.Input[builtins.str]] = None,
            capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
            default_rule: Optional[pulumi.Input[builtins.bool]] = None,
            departments: Optional[pulumi.Input[Union['FirewallDNSRuleDepartmentsArgs', 'FirewallDNSRuleDepartmentsArgsDict']]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            dest_ip_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDestIpGroupsArgs', 'FirewallDNSRuleDestIpGroupsArgsDict']]] = None,
            dest_ipv6_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDestIpv6GroupsArgs', 'FirewallDNSRuleDestIpv6GroupsArgsDict']]] = None,
            device_groups: Optional[pulumi.Input[Union['FirewallDNSRuleDeviceGroupsArgs', 'FirewallDNSRuleDeviceGroupsArgsDict']]] = None,
            devices: Optional[pulumi.Input[Union['FirewallDNSRuleDevicesArgs', 'FirewallDNSRuleDevicesArgsDict']]] = None,
            dns_gateway: Optional[pulumi.Input[Union['FirewallDNSRuleDnsGatewayArgs', 'FirewallDNSRuleDnsGatewayArgsDict']]] = None,
            dns_rule_request_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            edns_ecs_object: Optional[pulumi.Input[Union['FirewallDNSRuleEdnsEcsObjectArgs', 'FirewallDNSRuleEdnsEcsObjectArgsDict']]] = None,
            groups: Optional[pulumi.Input[Union['FirewallDNSRuleGroupsArgs', 'FirewallDNSRuleGroupsArgsDict']]] = None,
            labels: Optional[pulumi.Input[Union['FirewallDNSRuleLabelsArgs', 'FirewallDNSRuleLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['FirewallDNSRuleLocationGroupsArgs', 'FirewallDNSRuleLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['FirewallDNSRuleLocationsArgs', 'FirewallDNSRuleLocationsArgsDict']]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            order: Optional[pulumi.Input[builtins.int]] = None,
            predefined: Optional[pulumi.Input[builtins.bool]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            rank: Optional[pulumi.Input[builtins.int]] = None,
            redirect_ip: Optional[pulumi.Input[builtins.str]] = None,
            res_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            rule_id: Optional[pulumi.Input[builtins.int]] = None,
            source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            src_ip_groups: Optional[pulumi.Input[Union['FirewallDNSRuleSrcIpGroupsArgs', 'FirewallDNSRuleSrcIpGroupsArgsDict']]] = None,
            src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            src_ipv6_groups: Optional[pulumi.Input[Union['FirewallDNSRuleSrcIpv6GroupsArgs', 'FirewallDNSRuleSrcIpv6GroupsArgsDict']]] = None,
            state: Optional[pulumi.Input[builtins.str]] = None,
            time_windows: Optional[pulumi.Input[Union['FirewallDNSRuleTimeWindowsArgs', 'FirewallDNSRuleTimeWindowsArgsDict']]] = None,
            users: Optional[pulumi.Input[Union['FirewallDNSRuleUsersArgs', 'FirewallDNSRuleUsersArgsDict']]] = None,
            zpa_ip_group: Optional[pulumi.Input[Union['FirewallDNSRuleZpaIpGroupArgs', 'FirewallDNSRuleZpaIpGroupArgsDict']]] = None) -> 'FirewallDNSRule':
        """
        Get an existing FirewallDNSRule resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.str] action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        :param pulumi.Input[Union['FirewallDNSRuleApplicationGroupsArgs', 'FirewallDNSRuleApplicationGroupsArgsDict']] application_groups: (List of Objects) DNS application groups to which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] applications: (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        :param pulumi.Input[builtins.str] block_response_code: (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
               `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        :param pulumi.Input[builtins.bool] capture_pcap: (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[builtins.bool] default_rule: (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        :param pulumi.Input[Union['FirewallDNSRuleDepartmentsArgs', 'FirewallDNSRuleDepartmentsArgsDict']] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_addresses: (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_countries: (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dest_ip_categories: (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        :param pulumi.Input[Union['FirewallDNSRuleDestIpGroupsArgs', 'FirewallDNSRuleDestIpGroupsArgsDict']] dest_ip_groups: ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        :param pulumi.Input[Union['FirewallDNSRuleDestIpv6GroupsArgs', 'FirewallDNSRuleDestIpv6GroupsArgsDict']] dest_ipv6_groups: list of destination ip groups
        :param pulumi.Input[Union['FirewallDNSRuleDeviceGroupsArgs', 'FirewallDNSRuleDeviceGroupsArgsDict']] device_groups: (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['FirewallDNSRuleDevicesArgs', 'FirewallDNSRuleDevicesArgsDict']] devices: (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['FirewallDNSRuleDnsGatewayArgs', 'FirewallDNSRuleDnsGatewayArgsDict']] dns_gateway: (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_rule_request_types: (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
               `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
               `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
               `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
               `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
               `ZONEMD`, `SVCB`, `HTTPS`,
        :param pulumi.Input[Union['FirewallDNSRuleEdnsEcsObjectArgs', 'FirewallDNSRuleEdnsEcsObjectArgsDict']] edns_ecs_object: (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        :param pulumi.Input[Union['FirewallDNSRuleGroupsArgs', 'FirewallDNSRuleGroupsArgsDict']] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[Union['FirewallDNSRuleLabelsArgs', 'FirewallDNSRuleLabelsArgsDict']] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input[Union['FirewallDNSRuleLocationGroupsArgs', 'FirewallDNSRuleLocationGroupsArgsDict']] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input[Union['FirewallDNSRuleLocationsArgs', 'FirewallDNSRuleLocationsArgsDict']] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[builtins.bool] predefined: (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        :param pulumi.Input[builtins.int] rank: (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        :param pulumi.Input[builtins.str] redirect_ip: (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] res_categories: (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_countries: (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
               **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        :param pulumi.Input[Union['FirewallDNSRuleSrcIpGroupsArgs', 'FirewallDNSRuleSrcIpGroupsArgsDict']] src_ip_groups: (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] src_ips: (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        :param pulumi.Input[Union['FirewallDNSRuleSrcIpv6GroupsArgs', 'FirewallDNSRuleSrcIpv6GroupsArgsDict']] src_ipv6_groups: (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        :param pulumi.Input[builtins.str] state: (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        :param pulumi.Input[Union['FirewallDNSRuleTimeWindowsArgs', 'FirewallDNSRuleTimeWindowsArgsDict']] time_windows: (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        :param pulumi.Input[Union['FirewallDNSRuleUsersArgs', 'FirewallDNSRuleUsersArgsDict']] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input[Union['FirewallDNSRuleZpaIpGroupArgs', 'FirewallDNSRuleZpaIpGroupArgsDict']] zpa_ip_group: (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _FirewallDNSRuleState.__new__(_FirewallDNSRuleState)

        __props__.__dict__["action"] = action
        __props__.__dict__["application_groups"] = application_groups
        __props__.__dict__["applications"] = applications
        __props__.__dict__["block_response_code"] = block_response_code
        __props__.__dict__["capture_pcap"] = capture_pcap
        __props__.__dict__["default_rule"] = default_rule
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["dest_addresses"] = dest_addresses
        __props__.__dict__["dest_countries"] = dest_countries
        __props__.__dict__["dest_ip_categories"] = dest_ip_categories
        __props__.__dict__["dest_ip_groups"] = dest_ip_groups
        __props__.__dict__["dest_ipv6_groups"] = dest_ipv6_groups
        __props__.__dict__["device_groups"] = device_groups
        __props__.__dict__["devices"] = devices
        __props__.__dict__["dns_gateway"] = dns_gateway
        __props__.__dict__["dns_rule_request_types"] = dns_rule_request_types
        __props__.__dict__["edns_ecs_object"] = edns_ecs_object
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["name"] = name
        __props__.__dict__["order"] = order
        __props__.__dict__["predefined"] = predefined
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["rank"] = rank
        __props__.__dict__["redirect_ip"] = redirect_ip
        __props__.__dict__["res_categories"] = res_categories
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["source_countries"] = source_countries
        __props__.__dict__["src_ip_groups"] = src_ip_groups
        __props__.__dict__["src_ips"] = src_ips
        __props__.__dict__["src_ipv6_groups"] = src_ipv6_groups
        __props__.__dict__["state"] = state
        __props__.__dict__["time_windows"] = time_windows
        __props__.__dict__["users"] = users
        __props__.__dict__["zpa_ip_group"] = zpa_ip_group
        return FirewallDNSRule(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="applicationGroups")
    def application_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleApplicationGroups']]:
        """
        (List of Objects) DNS application groups to which the rule applies
        """
        return pulumi.get(self, "application_groups")

    @property
    @pulumi.getter
    def applications(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
        `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        """
        return pulumi.get(self, "block_response_code")

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> pulumi.Output[builtins.bool]:
        """
        (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        """
        return pulumi.get(self, "default_rule")

    @property
    @pulumi.getter
    def departments(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleDepartments']]:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "dest_addresses")

    @property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "dest_countries")

    @property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        """
        return pulumi.get(self, "dest_ip_categories")

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleDestIpGroups']]:
        """
        ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ip_groups")

    @property
    @pulumi.getter(name="destIpv6Groups")
    def dest_ipv6_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleDestIpv6Groups']]:
        """
        list of destination ip groups
        """
        return pulumi.get(self, "dest_ipv6_groups")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleDeviceGroups']]:
        """
        (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter
    def devices(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleDevices']]:
        """
        (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="dnsGateway")
    def dns_gateway(self) -> pulumi.Output['outputs.FirewallDNSRuleDnsGateway']:
        """
        (Set of Objects) The DNS gateway used to redirect traffic, specified when the rule action is to redirect DNS request to an external DNS service. Only one DNS Gateway is supported.
        """
        return pulumi.get(self, "dns_gateway")

    @property
    @pulumi.getter(name="dnsRuleRequestTypes")
    def dns_rule_request_types(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
        `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
        `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
        `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
        `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
        `ZONEMD`, `SVCB`, `HTTPS`,
        """
        return pulumi.get(self, "dns_rule_request_types")

    @property
    @pulumi.getter(name="ednsEcsObject")
    def edns_ecs_object(self) -> pulumi.Output['outputs.FirewallDNSRuleEdnsEcsObject']:
        """
        (List of Objects) The EDNS ECS object which resolves DNS request. Only one object is supported.
        """
        return pulumi.get(self, "edns_ecs_object")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleGroups']]:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleLabels']]:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleLocationGroups']]:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleLocations']]:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> pulumi.Output[builtins.int]:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def predefined(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        """
        return pulumi.get(self, "predefined")

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="redirectIp")
    def redirect_ip(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        """
        return pulumi.get(self, "redirect_ip")

    @property
    @pulumi.getter(name="resCategories")
    def res_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        """
        return pulumi.get(self, "res_categories")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[builtins.int]:
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "source_countries")

    @property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleSrcIpGroups']]:
        """
        (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        """
        return pulumi.get(self, "src_ip_groups")

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "src_ips")

    @property
    @pulumi.getter(name="srcIpv6Groups")
    def src_ipv6_groups(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleSrcIpv6Groups']]:
        """
        (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        """
        return pulumi.get(self, "src_ipv6_groups")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleTimeWindows']]:
        """
        (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter
    def users(self) -> pulumi.Output[Optional['outputs.FirewallDNSRuleUsers']]:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="zpaIpGroup")
    def zpa_ip_group(self) -> pulumi.Output['outputs.FirewallDNSRuleZpaIpGroup']:
        """
        (Set of Objects) The ZPA IP pool specified when the rule action is to resolve domain names of ZPA applications to an ephemeral IP address from a preconfigured IP pool. Only one object is supported.
        """
        return pulumi.get(self, "zpa_ip_group")


# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetSSLInspectionRulesResult',
    'AwaitableGetSSLInspectionRulesResult',
    'get_ssl_inspection_rules',
    'get_ssl_inspection_rules_output',
]

@pulumi.output_type
class GetSSLInspectionRulesResult:
    """
    A collection of values returned by getSSLInspectionRules.
    """
    def __init__(__self__, actions=None, cloud_applications=None, departments=None, description=None, dest_ip_groups=None, device_groups=None, device_trust_levels=None, devices=None, groups=None, id=None, labels=None, last_modified_bies=None, last_modified_time=None, location_groups=None, locations=None, name=None, order=None, platforms=None, proxy_gateways=None, rank=None, road_warrior_for_kerberos=None, source_ip_groups=None, state=None, time_windows=None, url_categories=None, user_agent_types=None, users=None, workload_groups=None, zpa_app_segments=None):
        if actions and not isinstance(actions, list):
            raise TypeError("Expected argument 'actions' to be a list")
        pulumi.set(__self__, "actions", actions)
        if cloud_applications and not isinstance(cloud_applications, list):
            raise TypeError("Expected argument 'cloud_applications' to be a list")
        pulumi.set(__self__, "cloud_applications", cloud_applications)
        if departments and not isinstance(departments, list):
            raise TypeError("Expected argument 'departments' to be a list")
        pulumi.set(__self__, "departments", departments)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if dest_ip_groups and not isinstance(dest_ip_groups, list):
            raise TypeError("Expected argument 'dest_ip_groups' to be a list")
        pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if device_groups and not isinstance(device_groups, list):
            raise TypeError("Expected argument 'device_groups' to be a list")
        pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels and not isinstance(device_trust_levels, list):
            raise TypeError("Expected argument 'device_trust_levels' to be a list")
        pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices and not isinstance(devices, list):
            raise TypeError("Expected argument 'devices' to be a list")
        pulumi.set(__self__, "devices", devices)
        if groups and not isinstance(groups, list):
            raise TypeError("Expected argument 'groups' to be a list")
        pulumi.set(__self__, "groups", groups)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if labels and not isinstance(labels, list):
            raise TypeError("Expected argument 'labels' to be a list")
        pulumi.set(__self__, "labels", labels)
        if last_modified_bies and not isinstance(last_modified_bies, list):
            raise TypeError("Expected argument 'last_modified_bies' to be a list")
        pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if last_modified_time and not isinstance(last_modified_time, int):
            raise TypeError("Expected argument 'last_modified_time' to be a int")
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        if location_groups and not isinstance(location_groups, list):
            raise TypeError("Expected argument 'location_groups' to be a list")
        pulumi.set(__self__, "location_groups", location_groups)
        if locations and not isinstance(locations, list):
            raise TypeError("Expected argument 'locations' to be a list")
        pulumi.set(__self__, "locations", locations)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if order and not isinstance(order, int):
            raise TypeError("Expected argument 'order' to be a int")
        pulumi.set(__self__, "order", order)
        if platforms and not isinstance(platforms, list):
            raise TypeError("Expected argument 'platforms' to be a list")
        pulumi.set(__self__, "platforms", platforms)
        if proxy_gateways and not isinstance(proxy_gateways, list):
            raise TypeError("Expected argument 'proxy_gateways' to be a list")
        pulumi.set(__self__, "proxy_gateways", proxy_gateways)
        if rank and not isinstance(rank, int):
            raise TypeError("Expected argument 'rank' to be a int")
        pulumi.set(__self__, "rank", rank)
        if road_warrior_for_kerberos and not isinstance(road_warrior_for_kerberos, bool):
            raise TypeError("Expected argument 'road_warrior_for_kerberos' to be a bool")
        pulumi.set(__self__, "road_warrior_for_kerberos", road_warrior_for_kerberos)
        if source_ip_groups and not isinstance(source_ip_groups, list):
            raise TypeError("Expected argument 'source_ip_groups' to be a list")
        pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if time_windows and not isinstance(time_windows, list):
            raise TypeError("Expected argument 'time_windows' to be a list")
        pulumi.set(__self__, "time_windows", time_windows)
        if url_categories and not isinstance(url_categories, list):
            raise TypeError("Expected argument 'url_categories' to be a list")
        pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types and not isinstance(user_agent_types, list):
            raise TypeError("Expected argument 'user_agent_types' to be a list")
        pulumi.set(__self__, "user_agent_types", user_agent_types)
        if users and not isinstance(users, list):
            raise TypeError("Expected argument 'users' to be a list")
        pulumi.set(__self__, "users", users)
        if workload_groups and not isinstance(workload_groups, list):
            raise TypeError("Expected argument 'workload_groups' to be a list")
        pulumi.set(__self__, "workload_groups", workload_groups)
        if zpa_app_segments and not isinstance(zpa_app_segments, list):
            raise TypeError("Expected argument 'zpa_app_segments' to be a list")
        pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetSSLInspectionRulesActionResult']:
        """
        Action taken when the traffic matches policy
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> Sequence[builtins.str]:
        """
        The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "cloud_applications")

    @property
    @pulumi.getter
    def departments(self) -> Sequence['outputs.GetSSLInspectionRulesDepartmentResult']:
        """
        ID pairs of departments for which the rule is applied.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The description of the workload group
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Sequence['outputs.GetSSLInspectionRulesDestIpGroupResult']:
        """
        ID pairs of destination IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "dest_ip_groups")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Sequence['outputs.GetSSLInspectionRulesDeviceGroupResult']:
        """
        ID pairs of device groups for which the rule is applied.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Sequence[builtins.str]:
        """
        Lists device trust levels for which the rule must be applied (for devices managed using Zscaler Client Connector).
        """
        return pulumi.get(self, "device_trust_levels")

    @property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetSSLInspectionRulesDeviceResult']:
        """
        ID pairs of devices for which the rule is applied
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetSSLInspectionRulesGroupResult']:
        """
        ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetSSLInspectionRulesLabelResult']:
        """
        ID pairs of labels associated with the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Sequence['outputs.GetSSLInspectionRulesLastModifiedByResult']:
        """
        A nested block with details about who last modified the workload group.
        """
        return pulumi.get(self, "last_modified_bies")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> builtins.int:
        """
        Timestamp when the workload group was last modified.
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Sequence['outputs.GetSSLInspectionRulesLocationGroupResult']:
        """
        ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetSSLInspectionRulesLocationResult']:
        """
        ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the workload group
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> builtins.int:
        """
        Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def platforms(self) -> Sequence[builtins.str]:
        """
        Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        """
        return pulumi.get(self, "platforms")

    @property
    @pulumi.getter(name="proxyGateways")
    def proxy_gateways(self) -> Sequence['outputs.GetSSLInspectionRulesProxyGatewayResult']:
        """
        When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        """
        return pulumi.get(self, "proxy_gateways")

    @property
    @pulumi.getter
    def rank(self) -> builtins.int:
        """
        The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="roadWarriorForKerberos")
    def road_warrior_for_kerberos(self) -> builtins.bool:
        """
        Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        """
        return pulumi.get(self, "road_warrior_for_kerberos")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Sequence['outputs.GetSSLInspectionRulesSourceIpGroupResult']:
        """
        ID pairs of source IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence['outputs.GetSSLInspectionRulesTimeWindowResult']:
        """
        The time intervals during which the rule applies
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Sequence[builtins.str]:
        """
        A list of user agent types the rule applies to.
        """
        return pulumi.get(self, "user_agent_types")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetSSLInspectionRulesUserResult']:
        """
        The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Sequence['outputs.GetSSLInspectionRulesWorkloadGroupResult']:
        """
        The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "workload_groups")

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Sequence['outputs.GetSSLInspectionRulesZpaAppSegmentResult']:
        """
        The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        return pulumi.get(self, "zpa_app_segments")


class AwaitableGetSSLInspectionRulesResult(GetSSLInspectionRulesResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetSSLInspectionRulesResult(
            actions=self.actions,
            cloud_applications=self.cloud_applications,
            departments=self.departments,
            description=self.description,
            dest_ip_groups=self.dest_ip_groups,
            device_groups=self.device_groups,
            device_trust_levels=self.device_trust_levels,
            devices=self.devices,
            groups=self.groups,
            id=self.id,
            labels=self.labels,
            last_modified_bies=self.last_modified_bies,
            last_modified_time=self.last_modified_time,
            location_groups=self.location_groups,
            locations=self.locations,
            name=self.name,
            order=self.order,
            platforms=self.platforms,
            proxy_gateways=self.proxy_gateways,
            rank=self.rank,
            road_warrior_for_kerberos=self.road_warrior_for_kerberos,
            source_ip_groups=self.source_ip_groups,
            state=self.state,
            time_windows=self.time_windows,
            url_categories=self.url_categories,
            user_agent_types=self.user_agent_types,
            users=self.users,
            workload_groups=self.workload_groups,
            zpa_app_segments=self.zpa_app_segments)


def get_ssl_inspection_rules(id: Optional[builtins.int] = None,
                             name: Optional[builtins.str] = None,
                             url_categories: Optional[Sequence[builtins.str]] = None,
                             opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetSSLInspectionRulesResult:
    """
    Use the **zia_ssl_inspection_rules** data source to get information about a ssl inspection rule in the Zscaler Internet Access.

    ## Example Usage


    :param builtins.int id: Unique identifier for the SSL Inspection
    :param builtins.str name: Name of the SSL Inspection
    :param Sequence[builtins.str] url_categories: The list of URL categories to which the DLP policy rule must be applied.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['urlCategories'] = url_categories
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getSSLInspectionRules:getSSLInspectionRules', __args__, opts=opts, typ=GetSSLInspectionRulesResult).value

    return AwaitableGetSSLInspectionRulesResult(
        actions=pulumi.get(__ret__, 'actions'),
        cloud_applications=pulumi.get(__ret__, 'cloud_applications'),
        departments=pulumi.get(__ret__, 'departments'),
        description=pulumi.get(__ret__, 'description'),
        dest_ip_groups=pulumi.get(__ret__, 'dest_ip_groups'),
        device_groups=pulumi.get(__ret__, 'device_groups'),
        device_trust_levels=pulumi.get(__ret__, 'device_trust_levels'),
        devices=pulumi.get(__ret__, 'devices'),
        groups=pulumi.get(__ret__, 'groups'),
        id=pulumi.get(__ret__, 'id'),
        labels=pulumi.get(__ret__, 'labels'),
        last_modified_bies=pulumi.get(__ret__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__ret__, 'last_modified_time'),
        location_groups=pulumi.get(__ret__, 'location_groups'),
        locations=pulumi.get(__ret__, 'locations'),
        name=pulumi.get(__ret__, 'name'),
        order=pulumi.get(__ret__, 'order'),
        platforms=pulumi.get(__ret__, 'platforms'),
        proxy_gateways=pulumi.get(__ret__, 'proxy_gateways'),
        rank=pulumi.get(__ret__, 'rank'),
        road_warrior_for_kerberos=pulumi.get(__ret__, 'road_warrior_for_kerberos'),
        source_ip_groups=pulumi.get(__ret__, 'source_ip_groups'),
        state=pulumi.get(__ret__, 'state'),
        time_windows=pulumi.get(__ret__, 'time_windows'),
        url_categories=pulumi.get(__ret__, 'url_categories'),
        user_agent_types=pulumi.get(__ret__, 'user_agent_types'),
        users=pulumi.get(__ret__, 'users'),
        workload_groups=pulumi.get(__ret__, 'workload_groups'),
        zpa_app_segments=pulumi.get(__ret__, 'zpa_app_segments'))
def get_ssl_inspection_rules_output(id: Optional[pulumi.Input[Optional[builtins.int]]] = None,
                                    name: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                                    url_categories: Optional[pulumi.Input[Optional[Sequence[builtins.str]]]] = None,
                                    opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetSSLInspectionRulesResult]:
    """
    Use the **zia_ssl_inspection_rules** data source to get information about a ssl inspection rule in the Zscaler Internet Access.

    ## Example Usage


    :param builtins.int id: Unique identifier for the SSL Inspection
    :param builtins.str name: Name of the SSL Inspection
    :param Sequence[builtins.str] url_categories: The list of URL categories to which the DLP policy rule must be applied.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['urlCategories'] = url_categories
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zia:index/getSSLInspectionRules:getSSLInspectionRules', __args__, opts=opts, typ=GetSSLInspectionRulesResult)
    return __ret__.apply(lambda __response__: GetSSLInspectionRulesResult(
        actions=pulumi.get(__response__, 'actions'),
        cloud_applications=pulumi.get(__response__, 'cloud_applications'),
        departments=pulumi.get(__response__, 'departments'),
        description=pulumi.get(__response__, 'description'),
        dest_ip_groups=pulumi.get(__response__, 'dest_ip_groups'),
        device_groups=pulumi.get(__response__, 'device_groups'),
        device_trust_levels=pulumi.get(__response__, 'device_trust_levels'),
        devices=pulumi.get(__response__, 'devices'),
        groups=pulumi.get(__response__, 'groups'),
        id=pulumi.get(__response__, 'id'),
        labels=pulumi.get(__response__, 'labels'),
        last_modified_bies=pulumi.get(__response__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__response__, 'last_modified_time'),
        location_groups=pulumi.get(__response__, 'location_groups'),
        locations=pulumi.get(__response__, 'locations'),
        name=pulumi.get(__response__, 'name'),
        order=pulumi.get(__response__, 'order'),
        platforms=pulumi.get(__response__, 'platforms'),
        proxy_gateways=pulumi.get(__response__, 'proxy_gateways'),
        rank=pulumi.get(__response__, 'rank'),
        road_warrior_for_kerberos=pulumi.get(__response__, 'road_warrior_for_kerberos'),
        source_ip_groups=pulumi.get(__response__, 'source_ip_groups'),
        state=pulumi.get(__response__, 'state'),
        time_windows=pulumi.get(__response__, 'time_windows'),
        url_categories=pulumi.get(__response__, 'url_categories'),
        user_agent_types=pulumi.get(__response__, 'user_agent_types'),
        users=pulumi.get(__response__, 'users'),
        workload_groups=pulumi.get(__response__, 'workload_groups'),
        zpa_app_segments=pulumi.get(__response__, 'zpa_app_segments')))

# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = ['SandboxFileSubmissionArgs', 'SandboxFileSubmission']

@pulumi.input_type
class SandboxFileSubmissionArgs:
    def __init__(__self__, *,
                 file_path: pulumi.Input[_builtins.str],
                 submission_method: pulumi.Input[_builtins.str],
                 force: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The set of arguments for constructing a SandboxFileSubmission resource.
        :param pulumi.Input[_builtins.str] file_path: (Required) The path where the raw or archive files for submission are located.
        :param pulumi.Input[_builtins.str] submission_method: (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        :param pulumi.Input[_builtins.bool] force: (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        """
        pulumi.set(__self__, "file_path", file_path)
        pulumi.set(__self__, "submission_method", submission_method)
        if force is not None:
            pulumi.set(__self__, "force", force)

    @_builtins.property
    @pulumi.getter(name="filePath")
    def file_path(self) -> pulumi.Input[_builtins.str]:
        """
        (Required) The path where the raw or archive files for submission are located.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_path", value)

    @_builtins.property
    @pulumi.getter(name="submissionMethod")
    def submission_method(self) -> pulumi.Input[_builtins.str]:
        """
        (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        """
        return pulumi.get(self, "submission_method")

    @submission_method.setter
    def submission_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "submission_method", value)

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force", value)


@pulumi.input_type
class _SandboxFileSubmissionState:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 file_type: Optional[pulumi.Input[_builtins.str]] = None,
                 force: Optional[pulumi.Input[_builtins.bool]] = None,
                 md5: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 sandbox_submission: Optional[pulumi.Input[_builtins.str]] = None,
                 submission_method: Optional[pulumi.Input[_builtins.str]] = None,
                 virus_name: Optional[pulumi.Input[_builtins.str]] = None,
                 virus_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering SandboxFileSubmission resources.
        :param pulumi.Input[_builtins.str] file_path: (Required) The path where the raw or archive files for submission are located.
        :param pulumi.Input[_builtins.bool] force: (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        :param pulumi.Input[_builtins.str] submission_method: (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if sandbox_submission is not None:
            pulumi.set(__self__, "sandbox_submission", sandbox_submission)
        if submission_method is not None:
            pulumi.set(__self__, "submission_method", submission_method)
        if virus_name is not None:
            pulumi.set(__self__, "virus_name", virus_name)
        if virus_type is not None:
            pulumi.set(__self__, "virus_type", virus_type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required) The path where the raw or archive files for submission are located.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_path", value)

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_type")

    @file_type.setter
    def file_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_type", value)

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force", value)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "md5", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="sandboxSubmission")
    def sandbox_submission(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sandbox_submission")

    @sandbox_submission.setter
    def sandbox_submission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sandbox_submission", value)

    @_builtins.property
    @pulumi.getter(name="submissionMethod")
    def submission_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        """
        return pulumi.get(self, "submission_method")

    @submission_method.setter
    def submission_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "submission_method", value)

    @_builtins.property
    @pulumi.getter(name="virusName")
    def virus_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "virus_name")

    @virus_name.setter
    def virus_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virus_name", value)

    @_builtins.property
    @pulumi.getter(name="virusType")
    def virus_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "virus_type")

    @virus_type.setter
    def virus_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virus_type", value)


@pulumi.type_token("zia:index/sandboxFileSubmission:SandboxFileSubmission")
class SandboxFileSubmission(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 force: Optional[pulumi.Input[_builtins.bool]] = None,
                 submission_method: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-sandbox)
        * [API documentation](https://help.zscaler.com/zia/sandbox-submission-api#/zscsb/submit-post)

        The **zia_sandbox_file_submission** resource submits raw or archive files (e.g., ZIP) to Zscaler's Sandbox for analysis. You can submit up to 100 files per day and it supports all file types that are currently supported by Sandbox. The resource also allows the submissions of raw or archive files to the Zscaler service for out-of-band file inspection to generate real-time verdicts for known and unknown files. It leverages capabilities such as Malware Prevention, Advanced Threat Prevention, Sandbox cloud effect, AI/ML-driven file analysis, and integrated third-party threat intelligence feeds to inspect files and classify them as benign or malicious instantaneously.

        ⚠️ **WARNING 1:**: Zscaler Cloud Sandbox is a subscription service and requires additional license. To learn more, contact Zscaler Support or your local account team.

        ⚠️ **WARNING 2:**: The ZIA Terraform provider requires both the `ZIA_CLOUD` and `ZIA_SANDBOX_TOKEN` in order to authenticate to the Zscaler Cloud Sandbox environment. For details on how obtain the API Token visit the Zscaler help portal [About Sandbox API Token](https://help.zscaler.com/zia/about-sandbox-api-token)

        **Note 1**: After files are sent for analysis, you must use GET /sandbox/report/{md5Hash} in order to retrieve the verdict. You can get the Sandbox report 10 minutes after a file is sent for analysis.

        **Note 2**: All file types that are currently supported by the Malware Protection policy and Advanced Threat Protection policy are supported for inspection, and each file is limited to a size of 400 MB.

        ## Example Usage

        ### Submit Raw Or Archive Files

        ### Submits Raw Or Archive For Out-Of-Band File Inspection

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] file_path: (Required) The path where the raw or archive files for submission are located.
        :param pulumi.Input[_builtins.bool] force: (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        :param pulumi.Input[_builtins.str] submission_method: (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: SandboxFileSubmissionArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-sandbox)
        * [API documentation](https://help.zscaler.com/zia/sandbox-submission-api#/zscsb/submit-post)

        The **zia_sandbox_file_submission** resource submits raw or archive files (e.g., ZIP) to Zscaler's Sandbox for analysis. You can submit up to 100 files per day and it supports all file types that are currently supported by Sandbox. The resource also allows the submissions of raw or archive files to the Zscaler service for out-of-band file inspection to generate real-time verdicts for known and unknown files. It leverages capabilities such as Malware Prevention, Advanced Threat Prevention, Sandbox cloud effect, AI/ML-driven file analysis, and integrated third-party threat intelligence feeds to inspect files and classify them as benign or malicious instantaneously.

        ⚠️ **WARNING 1:**: Zscaler Cloud Sandbox is a subscription service and requires additional license. To learn more, contact Zscaler Support or your local account team.

        ⚠️ **WARNING 2:**: The ZIA Terraform provider requires both the `ZIA_CLOUD` and `ZIA_SANDBOX_TOKEN` in order to authenticate to the Zscaler Cloud Sandbox environment. For details on how obtain the API Token visit the Zscaler help portal [About Sandbox API Token](https://help.zscaler.com/zia/about-sandbox-api-token)

        **Note 1**: After files are sent for analysis, you must use GET /sandbox/report/{md5Hash} in order to retrieve the verdict. You can get the Sandbox report 10 minutes after a file is sent for analysis.

        **Note 2**: All file types that are currently supported by the Malware Protection policy and Advanced Threat Protection policy are supported for inspection, and each file is limited to a size of 400 MB.

        ## Example Usage

        ### Submit Raw Or Archive Files

        ### Submits Raw Or Archive For Out-Of-Band File Inspection

        :param str resource_name: The name of the resource.
        :param SandboxFileSubmissionArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(SandboxFileSubmissionArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 force: Optional[pulumi.Input[_builtins.bool]] = None,
                 submission_method: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = SandboxFileSubmissionArgs.__new__(SandboxFileSubmissionArgs)

            if file_path is None and not opts.urn:
                raise TypeError("Missing required property 'file_path'")
            __props__.__dict__["file_path"] = file_path
            __props__.__dict__["force"] = force
            if submission_method is None and not opts.urn:
                raise TypeError("Missing required property 'submission_method'")
            __props__.__dict__["submission_method"] = submission_method
            __props__.__dict__["code"] = None
            __props__.__dict__["file_type"] = None
            __props__.__dict__["md5"] = None
            __props__.__dict__["message"] = None
            __props__.__dict__["sandbox_submission"] = None
            __props__.__dict__["virus_name"] = None
            __props__.__dict__["virus_type"] = None
        super(SandboxFileSubmission, __self__).__init__(
            'zia:index/sandboxFileSubmission:SandboxFileSubmission',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            code: Optional[pulumi.Input[_builtins.int]] = None,
            file_path: Optional[pulumi.Input[_builtins.str]] = None,
            file_type: Optional[pulumi.Input[_builtins.str]] = None,
            force: Optional[pulumi.Input[_builtins.bool]] = None,
            md5: Optional[pulumi.Input[_builtins.str]] = None,
            message: Optional[pulumi.Input[_builtins.str]] = None,
            sandbox_submission: Optional[pulumi.Input[_builtins.str]] = None,
            submission_method: Optional[pulumi.Input[_builtins.str]] = None,
            virus_name: Optional[pulumi.Input[_builtins.str]] = None,
            virus_type: Optional[pulumi.Input[_builtins.str]] = None) -> 'SandboxFileSubmission':
        """
        Get an existing SandboxFileSubmission resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] file_path: (Required) The path where the raw or archive files for submission are located.
        :param pulumi.Input[_builtins.bool] force: (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        :param pulumi.Input[_builtins.str] submission_method: (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _SandboxFileSubmissionState.__new__(_SandboxFileSubmissionState)

        __props__.__dict__["code"] = code
        __props__.__dict__["file_path"] = file_path
        __props__.__dict__["file_type"] = file_type
        __props__.__dict__["force"] = force
        __props__.__dict__["md5"] = md5
        __props__.__dict__["message"] = message
        __props__.__dict__["sandbox_submission"] = sandbox_submission
        __props__.__dict__["submission_method"] = submission_method
        __props__.__dict__["virus_name"] = virus_name
        __props__.__dict__["virus_type"] = virus_type
        return SandboxFileSubmission(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Output[_builtins.int]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="filePath")
    def file_path(self) -> pulumi.Output[_builtins.str]:
        """
        (Required) The path where the raw or archive files for submission are located.
        """
        return pulumi.get(self, "file_path")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "file_type")

    @_builtins.property
    @pulumi.getter
    def force(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        (Optional) Submit file to sandbox even if found malicious during AV scan and a verdict already exists. Supported values are `true` or `false`
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter
    def md5(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "md5")

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="sandboxSubmission")
    def sandbox_submission(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "sandbox_submission")

    @_builtins.property
    @pulumi.getter(name="submissionMethod")
    def submission_method(self) -> pulumi.Output[_builtins.str]:
        """
        (Required) The submission method to be used. Supportedd values are: `submit` and `discan`
        """
        return pulumi.get(self, "submission_method")

    @_builtins.property
    @pulumi.getter(name="virusName")
    def virus_name(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "virus_name")

    @_builtins.property
    @pulumi.getter(name="virusType")
    def virus_type(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "virus_type")


# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['TrafficCaptureRulesArgs', 'TrafficCaptureRules']

@pulumi.input_type
class TrafficCaptureRulesArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[_builtins.int],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 app_service_groups: Optional[pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs']] = None,
                 default_rule: Optional[pulumi.Input[_builtins.bool]] = None,
                 departments: Optional[pulumi.Input['TrafficCaptureRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs']] = None,
                 device_groups: Optional[pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['TrafficCaptureRulesDevicesArgs']] = None,
                 groups: Optional[pulumi.Input['TrafficCaptureRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['TrafficCaptureRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['TrafficCaptureRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['TrafficCaptureRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 nw_application_groups: Optional[pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs']] = None,
                 nw_applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 nw_service_groups: Optional[pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs']] = None,
                 nw_services: Optional[pulumi.Input['TrafficCaptureRulesNwServicesArgs']] = None,
                 predefined: Optional[pulumi.Input[_builtins.bool]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs']] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['TrafficCaptureRulesTimeWindowsArgs']] = None,
                 txn_sampling: Optional[pulumi.Input[_builtins.str]] = None,
                 txn_size_limit: Optional[pulumi.Input[_builtins.str]] = None,
                 users: Optional[pulumi.Input['TrafficCaptureRulesUsersArgs']] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]]] = None):
        """
        The set of arguments for constructing a TrafficCaptureRules resource.
        :param pulumi.Input[_builtins.int] order: Rule order number. If omitted, the rule will be added to the end of the rule set.
        :param pulumi.Input[_builtins.str] action: The action to be enforced when the traffic matches the rule criteria
        :param pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs'] app_service_groups: list of application service groups
        :param pulumi.Input[_builtins.bool] default_rule: If set to true, the default rule is applied
        :param pulumi.Input['TrafficCaptureRulesDepartmentsArgs'] departments: list of departments for which rule must be applied
        :param pulumi.Input[_builtins.str] description: Additional information about the rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_addresses: Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs'] dest_ip_groups: list of destination ip groups
        :param pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs'] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['TrafficCaptureRulesDevicesArgs'] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input['TrafficCaptureRulesGroupsArgs'] groups: list of groups for which rule must be applied
        :param pulumi.Input['TrafficCaptureRulesLabelsArgs'] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input['TrafficCaptureRulesLocationGroupsArgs'] location_groups: list of locations groups
        :param pulumi.Input['TrafficCaptureRulesLocationsArgs'] locations: list of locations for which rule must be applied
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs'] nw_application_groups: list of nw application groups
        :param pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs'] nw_service_groups: list of nw service groups
        :param pulumi.Input['TrafficCaptureRulesNwServicesArgs'] nw_services: list of nw services
        :param pulumi.Input[_builtins.bool] predefined: If set to true, a predefined rule is applied
        :param pulumi.Input[_builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs'] src_ip_groups: list of source ip groups
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] src_ips: User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        :param pulumi.Input[_builtins.str] state: Determines whether the Firewall Filtering policy rule is enabled or disabled
        :param pulumi.Input['TrafficCaptureRulesTimeWindowsArgs'] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[_builtins.str] txn_sampling: The percentage of connections sampled for capturing each time the rule is triggered
        :param pulumi.Input[_builtins.str] txn_size_limit: The maximum size of traffic to capture per connection
        :param pulumi.Input['TrafficCaptureRulesUsersArgs'] users: list of users for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        pulumi.set(__self__, "order", order)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if app_service_groups is not None:
            pulumi.set(__self__, "app_service_groups", app_service_groups)
        if default_rule is not None:
            pulumi.set(__self__, "default_rule", default_rule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dest_addresses is not None:
            pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries is not None:
            pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories is not None:
            pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups is not None:
            pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nw_application_groups is not None:
            pulumi.set(__self__, "nw_application_groups", nw_application_groups)
        if nw_applications is not None:
            pulumi.set(__self__, "nw_applications", nw_applications)
        if nw_service_groups is not None:
            pulumi.set(__self__, "nw_service_groups", nw_service_groups)
        if nw_services is not None:
            pulumi.set(__self__, "nw_services", nw_services)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if source_countries is not None:
            pulumi.set(__self__, "source_countries", source_countries)
        if src_ip_groups is not None:
            pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if txn_sampling is not None:
            pulumi.set(__self__, "txn_sampling", txn_sampling)
        if txn_size_limit is not None:
            pulumi.set(__self__, "txn_size_limit", txn_size_limit)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if workload_groups is not None:
            pulumi.set(__self__, "workload_groups", workload_groups)

    @_builtins.property
    @pulumi.getter
    def order(self) -> pulumi.Input[_builtins.int]:
        """
        Rule order number. If omitted, the rule will be added to the end of the rule set.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to be enforced when the traffic matches the rule criteria
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="appServiceGroups")
    def app_service_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs']]:
        """
        list of application service groups
        """
        return pulumi.get(self, "app_service_groups")

    @app_service_groups.setter
    def app_service_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs']]):
        pulumi.set(self, "app_service_groups", value)

    @_builtins.property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the default rule is applied
        """
        return pulumi.get(self, "default_rule")

    @default_rule.setter
    def default_rule(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_rule", value)

    @_builtins.property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['TrafficCaptureRulesDepartmentsArgs']]:
        """
        list of departments for which rule must be applied
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['TrafficCaptureRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information about the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        """
        return pulumi.get(self, "dest_addresses")

    @dest_addresses.setter
    def dest_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dest_addresses", value)

    @_builtins.property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "dest_countries")

    @dest_countries.setter
    def dest_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dest_countries", value)

    @_builtins.property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "dest_ip_categories")

    @dest_ip_categories.setter
    def dest_ip_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dest_ip_categories", value)

    @_builtins.property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs']]:
        """
        list of destination ip groups
        """
        return pulumi.get(self, "dest_ip_groups")

    @dest_ip_groups.setter
    def dest_ip_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs']]):
        pulumi.set(self, "dest_ip_groups", value)

    @_builtins.property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @_builtins.property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['TrafficCaptureRulesDevicesArgs']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['TrafficCaptureRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesGroupsArgs']]:
        """
        list of groups for which rule must be applied
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['TrafficCaptureRulesLabelsArgs']]:
        """
        list of Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['TrafficCaptureRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesLocationGroupsArgs']]:
        """
        list of locations groups
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['TrafficCaptureRulesLocationsArgs']]:
        """
        list of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['TrafficCaptureRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nwApplicationGroups")
    def nw_application_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs']]:
        """
        list of nw application groups
        """
        return pulumi.get(self, "nw_application_groups")

    @nw_application_groups.setter
    def nw_application_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs']]):
        pulumi.set(self, "nw_application_groups", value)

    @_builtins.property
    @pulumi.getter(name="nwApplications")
    def nw_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "nw_applications")

    @nw_applications.setter
    def nw_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nw_applications", value)

    @_builtins.property
    @pulumi.getter(name="nwServiceGroups")
    def nw_service_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs']]:
        """
        list of nw service groups
        """
        return pulumi.get(self, "nw_service_groups")

    @nw_service_groups.setter
    def nw_service_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs']]):
        pulumi.set(self, "nw_service_groups", value)

    @_builtins.property
    @pulumi.getter(name="nwServices")
    def nw_services(self) -> Optional[pulumi.Input['TrafficCaptureRulesNwServicesArgs']]:
        """
        list of nw services
        """
        return pulumi.get(self, "nw_services")

    @nw_services.setter
    def nw_services(self, value: Optional[pulumi.Input['TrafficCaptureRulesNwServicesArgs']]):
        pulumi.set(self, "nw_services", value)

    @_builtins.property
    @pulumi.getter
    def predefined(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, a predefined rule is applied
        """
        return pulumi.get(self, "predefined")

    @predefined.setter
    def predefined(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "predefined", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Admin rank of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)

    @_builtins.property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "source_countries")

    @source_countries.setter
    def source_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_countries", value)

    @_builtins.property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs']]:
        """
        list of source ip groups
        """
        return pulumi.get(self, "src_ip_groups")

    @src_ip_groups.setter
    def src_ip_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs']]):
        pulumi.set(self, "src_ip_groups", value)

    @_builtins.property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        """
        return pulumi.get(self, "src_ips")

    @src_ips.setter
    def src_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "src_ips", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines whether the Firewall Filtering policy rule is enabled or disabled
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['TrafficCaptureRulesTimeWindowsArgs']]:
        """
        The time interval in which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['TrafficCaptureRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @_builtins.property
    @pulumi.getter(name="txnSampling")
    def txn_sampling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The percentage of connections sampled for capturing each time the rule is triggered
        """
        return pulumi.get(self, "txn_sampling")

    @txn_sampling.setter
    def txn_sampling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txn_sampling", value)

    @_builtins.property
    @pulumi.getter(name="txnSizeLimit")
    def txn_size_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size of traffic to capture per connection
        """
        return pulumi.get(self, "txn_size_limit")

    @txn_size_limit.setter
    def txn_size_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txn_size_limit", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['TrafficCaptureRulesUsersArgs']]:
        """
        list of users for which rule must be applied
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['TrafficCaptureRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @_builtins.property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]]]:
        """
        The list of preconfigured workload groups to which the policy must be applied
        """
        return pulumi.get(self, "workload_groups")

    @workload_groups.setter
    def workload_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]]]):
        pulumi.set(self, "workload_groups", value)


@pulumi.input_type
class _TrafficCaptureRulesState:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 app_service_groups: Optional[pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs']] = None,
                 default_rule: Optional[pulumi.Input[_builtins.bool]] = None,
                 departments: Optional[pulumi.Input['TrafficCaptureRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs']] = None,
                 device_groups: Optional[pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['TrafficCaptureRulesDevicesArgs']] = None,
                 groups: Optional[pulumi.Input['TrafficCaptureRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['TrafficCaptureRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['TrafficCaptureRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['TrafficCaptureRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 nw_application_groups: Optional[pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs']] = None,
                 nw_applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 nw_service_groups: Optional[pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs']] = None,
                 nw_services: Optional[pulumi.Input['TrafficCaptureRulesNwServicesArgs']] = None,
                 order: Optional[pulumi.Input[_builtins.int]] = None,
                 predefined: Optional[pulumi.Input[_builtins.bool]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.int]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs']] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['TrafficCaptureRulesTimeWindowsArgs']] = None,
                 txn_sampling: Optional[pulumi.Input[_builtins.str]] = None,
                 txn_size_limit: Optional[pulumi.Input[_builtins.str]] = None,
                 users: Optional[pulumi.Input['TrafficCaptureRulesUsersArgs']] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]]] = None):
        """
        Input properties used for looking up and filtering TrafficCaptureRules resources.
        :param pulumi.Input[_builtins.str] action: The action to be enforced when the traffic matches the rule criteria
        :param pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs'] app_service_groups: list of application service groups
        :param pulumi.Input[_builtins.bool] default_rule: If set to true, the default rule is applied
        :param pulumi.Input['TrafficCaptureRulesDepartmentsArgs'] departments: list of departments for which rule must be applied
        :param pulumi.Input[_builtins.str] description: Additional information about the rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_addresses: Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs'] dest_ip_groups: list of destination ip groups
        :param pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs'] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['TrafficCaptureRulesDevicesArgs'] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input['TrafficCaptureRulesGroupsArgs'] groups: list of groups for which rule must be applied
        :param pulumi.Input['TrafficCaptureRulesLabelsArgs'] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input['TrafficCaptureRulesLocationGroupsArgs'] location_groups: list of locations groups
        :param pulumi.Input['TrafficCaptureRulesLocationsArgs'] locations: list of locations for which rule must be applied
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs'] nw_application_groups: list of nw application groups
        :param pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs'] nw_service_groups: list of nw service groups
        :param pulumi.Input['TrafficCaptureRulesNwServicesArgs'] nw_services: list of nw services
        :param pulumi.Input[_builtins.int] order: Rule order number. If omitted, the rule will be added to the end of the rule set.
        :param pulumi.Input[_builtins.bool] predefined: If set to true, a predefined rule is applied
        :param pulumi.Input[_builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs'] src_ip_groups: list of source ip groups
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] src_ips: User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        :param pulumi.Input[_builtins.str] state: Determines whether the Firewall Filtering policy rule is enabled or disabled
        :param pulumi.Input['TrafficCaptureRulesTimeWindowsArgs'] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[_builtins.str] txn_sampling: The percentage of connections sampled for capturing each time the rule is triggered
        :param pulumi.Input[_builtins.str] txn_size_limit: The maximum size of traffic to capture per connection
        :param pulumi.Input['TrafficCaptureRulesUsersArgs'] users: list of users for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if app_service_groups is not None:
            pulumi.set(__self__, "app_service_groups", app_service_groups)
        if default_rule is not None:
            pulumi.set(__self__, "default_rule", default_rule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dest_addresses is not None:
            pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries is not None:
            pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories is not None:
            pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups is not None:
            pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nw_application_groups is not None:
            pulumi.set(__self__, "nw_application_groups", nw_application_groups)
        if nw_applications is not None:
            pulumi.set(__self__, "nw_applications", nw_applications)
        if nw_service_groups is not None:
            pulumi.set(__self__, "nw_service_groups", nw_service_groups)
        if nw_services is not None:
            pulumi.set(__self__, "nw_services", nw_services)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if source_countries is not None:
            pulumi.set(__self__, "source_countries", source_countries)
        if src_ip_groups is not None:
            pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if txn_sampling is not None:
            pulumi.set(__self__, "txn_sampling", txn_sampling)
        if txn_size_limit is not None:
            pulumi.set(__self__, "txn_size_limit", txn_size_limit)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if workload_groups is not None:
            pulumi.set(__self__, "workload_groups", workload_groups)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to be enforced when the traffic matches the rule criteria
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="appServiceGroups")
    def app_service_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs']]:
        """
        list of application service groups
        """
        return pulumi.get(self, "app_service_groups")

    @app_service_groups.setter
    def app_service_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesAppServiceGroupsArgs']]):
        pulumi.set(self, "app_service_groups", value)

    @_builtins.property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the default rule is applied
        """
        return pulumi.get(self, "default_rule")

    @default_rule.setter
    def default_rule(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_rule", value)

    @_builtins.property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['TrafficCaptureRulesDepartmentsArgs']]:
        """
        list of departments for which rule must be applied
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['TrafficCaptureRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information about the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        """
        return pulumi.get(self, "dest_addresses")

    @dest_addresses.setter
    def dest_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dest_addresses", value)

    @_builtins.property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "dest_countries")

    @dest_countries.setter
    def dest_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dest_countries", value)

    @_builtins.property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "dest_ip_categories")

    @dest_ip_categories.setter
    def dest_ip_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dest_ip_categories", value)

    @_builtins.property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs']]:
        """
        list of destination ip groups
        """
        return pulumi.get(self, "dest_ip_groups")

    @dest_ip_groups.setter
    def dest_ip_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesDestIpGroupsArgs']]):
        pulumi.set(self, "dest_ip_groups", value)

    @_builtins.property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @_builtins.property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @_builtins.property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['TrafficCaptureRulesDevicesArgs']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['TrafficCaptureRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesGroupsArgs']]:
        """
        list of groups for which rule must be applied
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['TrafficCaptureRulesLabelsArgs']]:
        """
        list of Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['TrafficCaptureRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesLocationGroupsArgs']]:
        """
        list of locations groups
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['TrafficCaptureRulesLocationsArgs']]:
        """
        list of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['TrafficCaptureRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nwApplicationGroups")
    def nw_application_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs']]:
        """
        list of nw application groups
        """
        return pulumi.get(self, "nw_application_groups")

    @nw_application_groups.setter
    def nw_application_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesNwApplicationGroupsArgs']]):
        pulumi.set(self, "nw_application_groups", value)

    @_builtins.property
    @pulumi.getter(name="nwApplications")
    def nw_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "nw_applications")

    @nw_applications.setter
    def nw_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nw_applications", value)

    @_builtins.property
    @pulumi.getter(name="nwServiceGroups")
    def nw_service_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs']]:
        """
        list of nw service groups
        """
        return pulumi.get(self, "nw_service_groups")

    @nw_service_groups.setter
    def nw_service_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesNwServiceGroupsArgs']]):
        pulumi.set(self, "nw_service_groups", value)

    @_builtins.property
    @pulumi.getter(name="nwServices")
    def nw_services(self) -> Optional[pulumi.Input['TrafficCaptureRulesNwServicesArgs']]:
        """
        list of nw services
        """
        return pulumi.get(self, "nw_services")

    @nw_services.setter
    def nw_services(self, value: Optional[pulumi.Input['TrafficCaptureRulesNwServicesArgs']]):
        pulumi.set(self, "nw_services", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule order number. If omitted, the rule will be added to the end of the rule set.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def predefined(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, a predefined rule is applied
        """
        return pulumi.get(self, "predefined")

    @predefined.setter
    def predefined(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "predefined", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Admin rank of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "source_countries")

    @source_countries.setter
    def source_countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_countries", value)

    @_builtins.property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Optional[pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs']]:
        """
        list of source ip groups
        """
        return pulumi.get(self, "src_ip_groups")

    @src_ip_groups.setter
    def src_ip_groups(self, value: Optional[pulumi.Input['TrafficCaptureRulesSrcIpGroupsArgs']]):
        pulumi.set(self, "src_ip_groups", value)

    @_builtins.property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        """
        return pulumi.get(self, "src_ips")

    @src_ips.setter
    def src_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "src_ips", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines whether the Firewall Filtering policy rule is enabled or disabled
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['TrafficCaptureRulesTimeWindowsArgs']]:
        """
        The time interval in which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['TrafficCaptureRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @_builtins.property
    @pulumi.getter(name="txnSampling")
    def txn_sampling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The percentage of connections sampled for capturing each time the rule is triggered
        """
        return pulumi.get(self, "txn_sampling")

    @txn_sampling.setter
    def txn_sampling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txn_sampling", value)

    @_builtins.property
    @pulumi.getter(name="txnSizeLimit")
    def txn_size_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size of traffic to capture per connection
        """
        return pulumi.get(self, "txn_size_limit")

    @txn_size_limit.setter
    def txn_size_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txn_size_limit", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['TrafficCaptureRulesUsersArgs']]:
        """
        list of users for which rule must be applied
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['TrafficCaptureRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @_builtins.property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]]]:
        """
        The list of preconfigured workload groups to which the policy must be applied
        """
        return pulumi.get(self, "workload_groups")

    @workload_groups.setter
    def workload_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficCaptureRulesWorkloadGroupArgs']]]]):
        pulumi.set(self, "workload_groups", value)


@pulumi.type_token("zia:index/trafficCaptureRules:TrafficCaptureRules")
class TrafficCaptureRules(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 app_service_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesAppServiceGroupsArgs', 'TrafficCaptureRulesAppServiceGroupsArgsDict']]] = None,
                 default_rule: Optional[pulumi.Input[_builtins.bool]] = None,
                 departments: Optional[pulumi.Input[Union['TrafficCaptureRulesDepartmentsArgs', 'TrafficCaptureRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesDestIpGroupsArgs', 'TrafficCaptureRulesDestIpGroupsArgsDict']]] = None,
                 device_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesDeviceGroupsArgs', 'TrafficCaptureRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['TrafficCaptureRulesDevicesArgs', 'TrafficCaptureRulesDevicesArgsDict']]] = None,
                 groups: Optional[pulumi.Input[Union['TrafficCaptureRulesGroupsArgs', 'TrafficCaptureRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['TrafficCaptureRulesLabelsArgs', 'TrafficCaptureRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesLocationGroupsArgs', 'TrafficCaptureRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['TrafficCaptureRulesLocationsArgs', 'TrafficCaptureRulesLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 nw_application_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesNwApplicationGroupsArgs', 'TrafficCaptureRulesNwApplicationGroupsArgsDict']]] = None,
                 nw_applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 nw_service_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesNwServiceGroupsArgs', 'TrafficCaptureRulesNwServiceGroupsArgsDict']]] = None,
                 nw_services: Optional[pulumi.Input[Union['TrafficCaptureRulesNwServicesArgs', 'TrafficCaptureRulesNwServicesArgsDict']]] = None,
                 order: Optional[pulumi.Input[_builtins.int]] = None,
                 predefined: Optional[pulumi.Input[_builtins.bool]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesSrcIpGroupsArgs', 'TrafficCaptureRulesSrcIpGroupsArgsDict']]] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['TrafficCaptureRulesTimeWindowsArgs', 'TrafficCaptureRulesTimeWindowsArgsDict']]] = None,
                 txn_sampling: Optional[pulumi.Input[_builtins.str]] = None,
                 txn_size_limit: Optional[pulumi.Input[_builtins.str]] = None,
                 users: Optional[pulumi.Input[Union['TrafficCaptureRulesUsersArgs', 'TrafficCaptureRulesUsersArgsDict']]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TrafficCaptureRulesWorkloadGroupArgs', 'TrafficCaptureRulesWorkloadGroupArgsDict']]]]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-traffic-capture-policy)
        * [API documentation](https://help.zscaler.com/zia/traffic-capture-policy#/trafficCaptureRules-get)

        The **zia_traffic_capture_rules** resource allows the creation and management of ZIA traffic capture rules in the Zscaler Internet Access.

        ## Example Usage

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
        Visit

        **zia_traffic_capture_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] action: The action to be enforced when the traffic matches the rule criteria
        :param pulumi.Input[Union['TrafficCaptureRulesAppServiceGroupsArgs', 'TrafficCaptureRulesAppServiceGroupsArgsDict']] app_service_groups: list of application service groups
        :param pulumi.Input[_builtins.bool] default_rule: If set to true, the default rule is applied
        :param pulumi.Input[Union['TrafficCaptureRulesDepartmentsArgs', 'TrafficCaptureRulesDepartmentsArgsDict']] departments: list of departments for which rule must be applied
        :param pulumi.Input[_builtins.str] description: Additional information about the rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_addresses: Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input[Union['TrafficCaptureRulesDestIpGroupsArgs', 'TrafficCaptureRulesDestIpGroupsArgsDict']] dest_ip_groups: list of destination ip groups
        :param pulumi.Input[Union['TrafficCaptureRulesDeviceGroupsArgs', 'TrafficCaptureRulesDeviceGroupsArgsDict']] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['TrafficCaptureRulesDevicesArgs', 'TrafficCaptureRulesDevicesArgsDict']] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[Union['TrafficCaptureRulesGroupsArgs', 'TrafficCaptureRulesGroupsArgsDict']] groups: list of groups for which rule must be applied
        :param pulumi.Input[Union['TrafficCaptureRulesLabelsArgs', 'TrafficCaptureRulesLabelsArgsDict']] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input[Union['TrafficCaptureRulesLocationGroupsArgs', 'TrafficCaptureRulesLocationGroupsArgsDict']] location_groups: list of locations groups
        :param pulumi.Input[Union['TrafficCaptureRulesLocationsArgs', 'TrafficCaptureRulesLocationsArgsDict']] locations: list of locations for which rule must be applied
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[Union['TrafficCaptureRulesNwApplicationGroupsArgs', 'TrafficCaptureRulesNwApplicationGroupsArgsDict']] nw_application_groups: list of nw application groups
        :param pulumi.Input[Union['TrafficCaptureRulesNwServiceGroupsArgs', 'TrafficCaptureRulesNwServiceGroupsArgsDict']] nw_service_groups: list of nw service groups
        :param pulumi.Input[Union['TrafficCaptureRulesNwServicesArgs', 'TrafficCaptureRulesNwServicesArgsDict']] nw_services: list of nw services
        :param pulumi.Input[_builtins.int] order: Rule order number. If omitted, the rule will be added to the end of the rule set.
        :param pulumi.Input[_builtins.bool] predefined: If set to true, a predefined rule is applied
        :param pulumi.Input[_builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input[Union['TrafficCaptureRulesSrcIpGroupsArgs', 'TrafficCaptureRulesSrcIpGroupsArgsDict']] src_ip_groups: list of source ip groups
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] src_ips: User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        :param pulumi.Input[_builtins.str] state: Determines whether the Firewall Filtering policy rule is enabled or disabled
        :param pulumi.Input[Union['TrafficCaptureRulesTimeWindowsArgs', 'TrafficCaptureRulesTimeWindowsArgsDict']] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[_builtins.str] txn_sampling: The percentage of connections sampled for capturing each time the rule is triggered
        :param pulumi.Input[_builtins.str] txn_size_limit: The maximum size of traffic to capture per connection
        :param pulumi.Input[Union['TrafficCaptureRulesUsersArgs', 'TrafficCaptureRulesUsersArgsDict']] users: list of users for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input[Union['TrafficCaptureRulesWorkloadGroupArgs', 'TrafficCaptureRulesWorkloadGroupArgsDict']]]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: TrafficCaptureRulesArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-traffic-capture-policy)
        * [API documentation](https://help.zscaler.com/zia/traffic-capture-policy#/trafficCaptureRules-get)

        The **zia_traffic_capture_rules** resource allows the creation and management of ZIA traffic capture rules in the Zscaler Internet Access.

        ## Example Usage

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
        Visit

        **zia_traffic_capture_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/trafficCaptureRules:TrafficCaptureRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param TrafficCaptureRulesArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(TrafficCaptureRulesArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 app_service_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesAppServiceGroupsArgs', 'TrafficCaptureRulesAppServiceGroupsArgsDict']]] = None,
                 default_rule: Optional[pulumi.Input[_builtins.bool]] = None,
                 departments: Optional[pulumi.Input[Union['TrafficCaptureRulesDepartmentsArgs', 'TrafficCaptureRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dest_ip_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesDestIpGroupsArgs', 'TrafficCaptureRulesDestIpGroupsArgsDict']]] = None,
                 device_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesDeviceGroupsArgs', 'TrafficCaptureRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['TrafficCaptureRulesDevicesArgs', 'TrafficCaptureRulesDevicesArgsDict']]] = None,
                 groups: Optional[pulumi.Input[Union['TrafficCaptureRulesGroupsArgs', 'TrafficCaptureRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['TrafficCaptureRulesLabelsArgs', 'TrafficCaptureRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesLocationGroupsArgs', 'TrafficCaptureRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['TrafficCaptureRulesLocationsArgs', 'TrafficCaptureRulesLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 nw_application_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesNwApplicationGroupsArgs', 'TrafficCaptureRulesNwApplicationGroupsArgsDict']]] = None,
                 nw_applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 nw_service_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesNwServiceGroupsArgs', 'TrafficCaptureRulesNwServiceGroupsArgsDict']]] = None,
                 nw_services: Optional[pulumi.Input[Union['TrafficCaptureRulesNwServicesArgs', 'TrafficCaptureRulesNwServicesArgsDict']]] = None,
                 order: Optional[pulumi.Input[_builtins.int]] = None,
                 predefined: Optional[pulumi.Input[_builtins.bool]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 src_ip_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesSrcIpGroupsArgs', 'TrafficCaptureRulesSrcIpGroupsArgsDict']]] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['TrafficCaptureRulesTimeWindowsArgs', 'TrafficCaptureRulesTimeWindowsArgsDict']]] = None,
                 txn_sampling: Optional[pulumi.Input[_builtins.str]] = None,
                 txn_size_limit: Optional[pulumi.Input[_builtins.str]] = None,
                 users: Optional[pulumi.Input[Union['TrafficCaptureRulesUsersArgs', 'TrafficCaptureRulesUsersArgsDict']]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TrafficCaptureRulesWorkloadGroupArgs', 'TrafficCaptureRulesWorkloadGroupArgsDict']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = TrafficCaptureRulesArgs.__new__(TrafficCaptureRulesArgs)

            __props__.__dict__["action"] = action
            __props__.__dict__["app_service_groups"] = app_service_groups
            __props__.__dict__["default_rule"] = default_rule
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            __props__.__dict__["dest_addresses"] = dest_addresses
            __props__.__dict__["dest_countries"] = dest_countries
            __props__.__dict__["dest_ip_categories"] = dest_ip_categories
            __props__.__dict__["dest_ip_groups"] = dest_ip_groups
            __props__.__dict__["device_groups"] = device_groups
            __props__.__dict__["device_trust_levels"] = device_trust_levels
            __props__.__dict__["devices"] = devices
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["name"] = name
            __props__.__dict__["nw_application_groups"] = nw_application_groups
            __props__.__dict__["nw_applications"] = nw_applications
            __props__.__dict__["nw_service_groups"] = nw_service_groups
            __props__.__dict__["nw_services"] = nw_services
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            __props__.__dict__["predefined"] = predefined
            __props__.__dict__["rank"] = rank
            __props__.__dict__["source_countries"] = source_countries
            __props__.__dict__["src_ip_groups"] = src_ip_groups
            __props__.__dict__["src_ips"] = src_ips
            __props__.__dict__["state"] = state
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["txn_sampling"] = txn_sampling
            __props__.__dict__["txn_size_limit"] = txn_size_limit
            __props__.__dict__["users"] = users
            __props__.__dict__["workload_groups"] = workload_groups
            __props__.__dict__["rule_id"] = None
        super(TrafficCaptureRules, __self__).__init__(
            'zia:index/trafficCaptureRules:TrafficCaptureRules',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            action: Optional[pulumi.Input[_builtins.str]] = None,
            app_service_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesAppServiceGroupsArgs', 'TrafficCaptureRulesAppServiceGroupsArgsDict']]] = None,
            default_rule: Optional[pulumi.Input[_builtins.bool]] = None,
            departments: Optional[pulumi.Input[Union['TrafficCaptureRulesDepartmentsArgs', 'TrafficCaptureRulesDepartmentsArgsDict']]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            dest_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            dest_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            dest_ip_categories: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            dest_ip_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesDestIpGroupsArgs', 'TrafficCaptureRulesDestIpGroupsArgsDict']]] = None,
            device_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesDeviceGroupsArgs', 'TrafficCaptureRulesDeviceGroupsArgsDict']]] = None,
            device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            devices: Optional[pulumi.Input[Union['TrafficCaptureRulesDevicesArgs', 'TrafficCaptureRulesDevicesArgsDict']]] = None,
            groups: Optional[pulumi.Input[Union['TrafficCaptureRulesGroupsArgs', 'TrafficCaptureRulesGroupsArgsDict']]] = None,
            labels: Optional[pulumi.Input[Union['TrafficCaptureRulesLabelsArgs', 'TrafficCaptureRulesLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesLocationGroupsArgs', 'TrafficCaptureRulesLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['TrafficCaptureRulesLocationsArgs', 'TrafficCaptureRulesLocationsArgsDict']]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            nw_application_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesNwApplicationGroupsArgs', 'TrafficCaptureRulesNwApplicationGroupsArgsDict']]] = None,
            nw_applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            nw_service_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesNwServiceGroupsArgs', 'TrafficCaptureRulesNwServiceGroupsArgsDict']]] = None,
            nw_services: Optional[pulumi.Input[Union['TrafficCaptureRulesNwServicesArgs', 'TrafficCaptureRulesNwServicesArgsDict']]] = None,
            order: Optional[pulumi.Input[_builtins.int]] = None,
            predefined: Optional[pulumi.Input[_builtins.bool]] = None,
            rank: Optional[pulumi.Input[_builtins.int]] = None,
            rule_id: Optional[pulumi.Input[_builtins.int]] = None,
            source_countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            src_ip_groups: Optional[pulumi.Input[Union['TrafficCaptureRulesSrcIpGroupsArgs', 'TrafficCaptureRulesSrcIpGroupsArgsDict']]] = None,
            src_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            state: Optional[pulumi.Input[_builtins.str]] = None,
            time_windows: Optional[pulumi.Input[Union['TrafficCaptureRulesTimeWindowsArgs', 'TrafficCaptureRulesTimeWindowsArgsDict']]] = None,
            txn_sampling: Optional[pulumi.Input[_builtins.str]] = None,
            txn_size_limit: Optional[pulumi.Input[_builtins.str]] = None,
            users: Optional[pulumi.Input[Union['TrafficCaptureRulesUsersArgs', 'TrafficCaptureRulesUsersArgsDict']]] = None,
            workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TrafficCaptureRulesWorkloadGroupArgs', 'TrafficCaptureRulesWorkloadGroupArgsDict']]]]] = None) -> 'TrafficCaptureRules':
        """
        Get an existing TrafficCaptureRules resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] action: The action to be enforced when the traffic matches the rule criteria
        :param pulumi.Input[Union['TrafficCaptureRulesAppServiceGroupsArgs', 'TrafficCaptureRulesAppServiceGroupsArgsDict']] app_service_groups: list of application service groups
        :param pulumi.Input[_builtins.bool] default_rule: If set to true, the default rule is applied
        :param pulumi.Input[Union['TrafficCaptureRulesDepartmentsArgs', 'TrafficCaptureRulesDepartmentsArgsDict']] departments: list of departments for which rule must be applied
        :param pulumi.Input[_builtins.str] description: Additional information about the rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_addresses: Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dest_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input[Union['TrafficCaptureRulesDestIpGroupsArgs', 'TrafficCaptureRulesDestIpGroupsArgsDict']] dest_ip_groups: list of destination ip groups
        :param pulumi.Input[Union['TrafficCaptureRulesDeviceGroupsArgs', 'TrafficCaptureRulesDeviceGroupsArgsDict']] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['TrafficCaptureRulesDevicesArgs', 'TrafficCaptureRulesDevicesArgsDict']] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[Union['TrafficCaptureRulesGroupsArgs', 'TrafficCaptureRulesGroupsArgsDict']] groups: list of groups for which rule must be applied
        :param pulumi.Input[Union['TrafficCaptureRulesLabelsArgs', 'TrafficCaptureRulesLabelsArgsDict']] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input[Union['TrafficCaptureRulesLocationGroupsArgs', 'TrafficCaptureRulesLocationGroupsArgsDict']] location_groups: list of locations groups
        :param pulumi.Input[Union['TrafficCaptureRulesLocationsArgs', 'TrafficCaptureRulesLocationsArgsDict']] locations: list of locations for which rule must be applied
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[Union['TrafficCaptureRulesNwApplicationGroupsArgs', 'TrafficCaptureRulesNwApplicationGroupsArgsDict']] nw_application_groups: list of nw application groups
        :param pulumi.Input[Union['TrafficCaptureRulesNwServiceGroupsArgs', 'TrafficCaptureRulesNwServiceGroupsArgsDict']] nw_service_groups: list of nw service groups
        :param pulumi.Input[Union['TrafficCaptureRulesNwServicesArgs', 'TrafficCaptureRulesNwServicesArgsDict']] nw_services: list of nw services
        :param pulumi.Input[_builtins.int] order: Rule order number. If omitted, the rule will be added to the end of the rule set.
        :param pulumi.Input[_builtins.bool] predefined: If set to true, a predefined rule is applied
        :param pulumi.Input[_builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_countries: Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        :param pulumi.Input[Union['TrafficCaptureRulesSrcIpGroupsArgs', 'TrafficCaptureRulesSrcIpGroupsArgsDict']] src_ip_groups: list of source ip groups
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] src_ips: User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        :param pulumi.Input[_builtins.str] state: Determines whether the Firewall Filtering policy rule is enabled or disabled
        :param pulumi.Input[Union['TrafficCaptureRulesTimeWindowsArgs', 'TrafficCaptureRulesTimeWindowsArgsDict']] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[_builtins.str] txn_sampling: The percentage of connections sampled for capturing each time the rule is triggered
        :param pulumi.Input[_builtins.str] txn_size_limit: The maximum size of traffic to capture per connection
        :param pulumi.Input[Union['TrafficCaptureRulesUsersArgs', 'TrafficCaptureRulesUsersArgsDict']] users: list of users for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input[Union['TrafficCaptureRulesWorkloadGroupArgs', 'TrafficCaptureRulesWorkloadGroupArgsDict']]]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _TrafficCaptureRulesState.__new__(_TrafficCaptureRulesState)

        __props__.__dict__["action"] = action
        __props__.__dict__["app_service_groups"] = app_service_groups
        __props__.__dict__["default_rule"] = default_rule
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["dest_addresses"] = dest_addresses
        __props__.__dict__["dest_countries"] = dest_countries
        __props__.__dict__["dest_ip_categories"] = dest_ip_categories
        __props__.__dict__["dest_ip_groups"] = dest_ip_groups
        __props__.__dict__["device_groups"] = device_groups
        __props__.__dict__["device_trust_levels"] = device_trust_levels
        __props__.__dict__["devices"] = devices
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["name"] = name
        __props__.__dict__["nw_application_groups"] = nw_application_groups
        __props__.__dict__["nw_applications"] = nw_applications
        __props__.__dict__["nw_service_groups"] = nw_service_groups
        __props__.__dict__["nw_services"] = nw_services
        __props__.__dict__["order"] = order
        __props__.__dict__["predefined"] = predefined
        __props__.__dict__["rank"] = rank
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["source_countries"] = source_countries
        __props__.__dict__["src_ip_groups"] = src_ip_groups
        __props__.__dict__["src_ips"] = src_ips
        __props__.__dict__["state"] = state
        __props__.__dict__["time_windows"] = time_windows
        __props__.__dict__["txn_sampling"] = txn_sampling
        __props__.__dict__["txn_size_limit"] = txn_size_limit
        __props__.__dict__["users"] = users
        __props__.__dict__["workload_groups"] = workload_groups
        return TrafficCaptureRules(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The action to be enforced when the traffic matches the rule criteria
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="appServiceGroups")
    def app_service_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesAppServiceGroups']]:
        """
        list of application service groups
        """
        return pulumi.get(self, "app_service_groups")

    @_builtins.property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        If set to true, the default rule is applied
        """
        return pulumi.get(self, "default_rule")

    @_builtins.property
    @pulumi.getter
    def departments(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesDepartments']]:
        """
        list of departments for which rule must be applied
        """
        return pulumi.get(self, "departments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Additional information about the rule
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        Destination addresses. Supports IPv4, FQDNs, or wildcard FQDNs
        """
        return pulumi.get(self, "dest_addresses")

    @_builtins.property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "dest_countries")

    @_builtins.property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        return pulumi.get(self, "dest_ip_categories")

    @_builtins.property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesDestIpGroups']]:
        """
        list of destination ip groups
        """
        return pulumi.get(self, "dest_ip_groups")

    @_builtins.property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesDeviceGroups']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @_builtins.property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @_builtins.property
    @pulumi.getter
    def devices(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesDevices']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesGroups']]:
        """
        list of groups for which rule must be applied
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesLabels']]:
        """
        list of Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesLocationGroups']]:
        """
        list of locations groups
        """
        return pulumi.get(self, "location_groups")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesLocations']]:
        """
        list of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nwApplicationGroups")
    def nw_application_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesNwApplicationGroups']]:
        """
        list of nw application groups
        """
        return pulumi.get(self, "nw_application_groups")

    @_builtins.property
    @pulumi.getter(name="nwApplications")
    def nw_applications(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        return pulumi.get(self, "nw_applications")

    @_builtins.property
    @pulumi.getter(name="nwServiceGroups")
    def nw_service_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesNwServiceGroups']]:
        """
        list of nw service groups
        """
        return pulumi.get(self, "nw_service_groups")

    @_builtins.property
    @pulumi.getter(name="nwServices")
    def nw_services(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesNwServices']]:
        """
        list of nw services
        """
        return pulumi.get(self, "nw_services")

    @_builtins.property
    @pulumi.getter
    def order(self) -> pulumi.Output[_builtins.int]:
        """
        Rule order number. If omitted, the rule will be added to the end of the rule set.
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter
    def predefined(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        If set to true, a predefined rule is applied
        """
        return pulumi.get(self, "predefined")

    @_builtins.property
    @pulumi.getter
    def rank(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        Admin rank of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "rank")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[_builtins.int]:
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "source_countries")

    @_builtins.property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesSrcIpGroups']]:
        """
        list of source ip groups
        """
        return pulumi.get(self, "src_ip_groups")

    @_builtins.property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        """
        return pulumi.get(self, "src_ips")

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Determines whether the Firewall Filtering policy rule is enabled or disabled
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesTimeWindows']]:
        """
        The time interval in which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "time_windows")

    @_builtins.property
    @pulumi.getter(name="txnSampling")
    def txn_sampling(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The percentage of connections sampled for capturing each time the rule is triggered
        """
        return pulumi.get(self, "txn_sampling")

    @_builtins.property
    @pulumi.getter(name="txnSizeLimit")
    def txn_size_limit(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The maximum size of traffic to capture per connection
        """
        return pulumi.get(self, "txn_size_limit")

    @_builtins.property
    @pulumi.getter
    def users(self) -> pulumi.Output[Optional['outputs.TrafficCaptureRulesUsers']]:
        """
        list of users for which rule must be applied
        """
        return pulumi.get(self, "users")

    @_builtins.property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> pulumi.Output[Sequence['outputs.TrafficCaptureRulesWorkloadGroup']]:
        """
        The list of preconfigured workload groups to which the policy must be applied
        """
        return pulumi.get(self, "workload_groups")


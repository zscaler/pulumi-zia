# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AdminUsersAdminScopeEntitiesArgs',
    'AdminUsersAdminScopeEntitiesArgsDict',
    'AdminUsersRoleArgs',
    'AdminUsersRoleArgsDict',
    'CloudAppControlRuleCbiProfileArgs',
    'CloudAppControlRuleCbiProfileArgsDict',
    'CloudAppControlRuleCloudAppRiskProfileArgs',
    'CloudAppControlRuleCloudAppRiskProfileArgsDict',
    'CloudAppControlRuleDepartmentsArgs',
    'CloudAppControlRuleDepartmentsArgsDict',
    'CloudAppControlRuleDeviceGroupsArgs',
    'CloudAppControlRuleDeviceGroupsArgsDict',
    'CloudAppControlRuleDevicesArgs',
    'CloudAppControlRuleDevicesArgsDict',
    'CloudAppControlRuleGroupsArgs',
    'CloudAppControlRuleGroupsArgsDict',
    'CloudAppControlRuleLabelsArgs',
    'CloudAppControlRuleLabelsArgsDict',
    'CloudAppControlRuleLocationGroupsArgs',
    'CloudAppControlRuleLocationGroupsArgsDict',
    'CloudAppControlRuleLocationsArgs',
    'CloudAppControlRuleLocationsArgsDict',
    'CloudAppControlRuleTenancyProfileIdsArgs',
    'CloudAppControlRuleTenancyProfileIdsArgsDict',
    'CloudAppControlRuleTimeWindowsArgs',
    'CloudAppControlRuleTimeWindowsArgsDict',
    'CloudAppControlRuleUsersArgs',
    'CloudAppControlRuleUsersArgsDict',
    'DLPDictionariesExactDataMatchDetailArgs',
    'DLPDictionariesExactDataMatchDetailArgsDict',
    'DLPDictionariesIdmProfileMatchAccuracyArgs',
    'DLPDictionariesIdmProfileMatchAccuracyArgsDict',
    'DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs',
    'DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict',
    'DLPDictionariesPatternArgs',
    'DLPDictionariesPatternArgsDict',
    'DLPDictionariesPhraseArgs',
    'DLPDictionariesPhraseArgsDict',
    'DLPWebRulesAuditorArgs',
    'DLPWebRulesAuditorArgsDict',
    'DLPWebRulesDepartmentsArgs',
    'DLPWebRulesDepartmentsArgsDict',
    'DLPWebRulesDlpEnginesArgs',
    'DLPWebRulesDlpEnginesArgsDict',
    'DLPWebRulesExcludedDepartmentsArgs',
    'DLPWebRulesExcludedDepartmentsArgsDict',
    'DLPWebRulesExcludedDomainProfilesArgs',
    'DLPWebRulesExcludedDomainProfilesArgsDict',
    'DLPWebRulesExcludedGroupsArgs',
    'DLPWebRulesExcludedGroupsArgsDict',
    'DLPWebRulesExcludedUsersArgs',
    'DLPWebRulesExcludedUsersArgsDict',
    'DLPWebRulesGroupsArgs',
    'DLPWebRulesGroupsArgsDict',
    'DLPWebRulesIcapServerArgs',
    'DLPWebRulesIcapServerArgsDict',
    'DLPWebRulesIncludedDomainProfilesArgs',
    'DLPWebRulesIncludedDomainProfilesArgsDict',
    'DLPWebRulesLabelsArgs',
    'DLPWebRulesLabelsArgsDict',
    'DLPWebRulesLocationGroupsArgs',
    'DLPWebRulesLocationGroupsArgsDict',
    'DLPWebRulesLocationsArgs',
    'DLPWebRulesLocationsArgsDict',
    'DLPWebRulesNotificationTemplateArgs',
    'DLPWebRulesNotificationTemplateArgsDict',
    'DLPWebRulesSourceIpGroupsArgs',
    'DLPWebRulesSourceIpGroupsArgsDict',
    'DLPWebRulesTimeWindowsArgs',
    'DLPWebRulesTimeWindowsArgsDict',
    'DLPWebRulesUrlCategoriesArgs',
    'DLPWebRulesUrlCategoriesArgsDict',
    'DLPWebRulesUsersArgs',
    'DLPWebRulesUsersArgsDict',
    'DLPWebRulesWorkloadGroupArgs',
    'DLPWebRulesWorkloadGroupArgsDict',
    'FileTypeControlRulesDepartmentsArgs',
    'FileTypeControlRulesDepartmentsArgsDict',
    'FileTypeControlRulesDeviceGroupsArgs',
    'FileTypeControlRulesDeviceGroupsArgsDict',
    'FileTypeControlRulesDevicesArgs',
    'FileTypeControlRulesDevicesArgsDict',
    'FileTypeControlRulesGroupsArgs',
    'FileTypeControlRulesGroupsArgsDict',
    'FileTypeControlRulesLabelsArgs',
    'FileTypeControlRulesLabelsArgsDict',
    'FileTypeControlRulesLocationGroupsArgs',
    'FileTypeControlRulesLocationGroupsArgsDict',
    'FileTypeControlRulesLocationsArgs',
    'FileTypeControlRulesLocationsArgsDict',
    'FileTypeControlRulesTimeWindowsArgs',
    'FileTypeControlRulesTimeWindowsArgsDict',
    'FileTypeControlRulesUsersArgs',
    'FileTypeControlRulesUsersArgsDict',
    'FileTypeControlRulesZpaAppSegmentArgs',
    'FileTypeControlRulesZpaAppSegmentArgsDict',
    'FirewallDNSRuleApplicationGroupsArgs',
    'FirewallDNSRuleApplicationGroupsArgsDict',
    'FirewallDNSRuleDepartmentsArgs',
    'FirewallDNSRuleDepartmentsArgsDict',
    'FirewallDNSRuleDestIpGroupsArgs',
    'FirewallDNSRuleDestIpGroupsArgsDict',
    'FirewallDNSRuleDestIpv6GroupsArgs',
    'FirewallDNSRuleDestIpv6GroupsArgsDict',
    'FirewallDNSRuleDeviceGroupsArgs',
    'FirewallDNSRuleDeviceGroupsArgsDict',
    'FirewallDNSRuleDevicesArgs',
    'FirewallDNSRuleDevicesArgsDict',
    'FirewallDNSRuleDnsGatewayArgs',
    'FirewallDNSRuleDnsGatewayArgsDict',
    'FirewallDNSRuleEdnsEcsObjectArgs',
    'FirewallDNSRuleEdnsEcsObjectArgsDict',
    'FirewallDNSRuleGroupsArgs',
    'FirewallDNSRuleGroupsArgsDict',
    'FirewallDNSRuleLabelsArgs',
    'FirewallDNSRuleLabelsArgsDict',
    'FirewallDNSRuleLocationGroupsArgs',
    'FirewallDNSRuleLocationGroupsArgsDict',
    'FirewallDNSRuleLocationsArgs',
    'FirewallDNSRuleLocationsArgsDict',
    'FirewallDNSRuleSrcIpGroupsArgs',
    'FirewallDNSRuleSrcIpGroupsArgsDict',
    'FirewallDNSRuleSrcIpv6GroupsArgs',
    'FirewallDNSRuleSrcIpv6GroupsArgsDict',
    'FirewallDNSRuleTimeWindowsArgs',
    'FirewallDNSRuleTimeWindowsArgsDict',
    'FirewallDNSRuleUsersArgs',
    'FirewallDNSRuleUsersArgsDict',
    'FirewallDNSRuleZpaIpGroupArgs',
    'FirewallDNSRuleZpaIpGroupArgsDict',
    'FirewallFilteringNetworkServicesDestTcpPortArgs',
    'FirewallFilteringNetworkServicesDestTcpPortArgsDict',
    'FirewallFilteringNetworkServicesDestUdpPortArgs',
    'FirewallFilteringNetworkServicesDestUdpPortArgsDict',
    'FirewallFilteringNetworkServicesSrcTcpPortArgs',
    'FirewallFilteringNetworkServicesSrcTcpPortArgsDict',
    'FirewallFilteringNetworkServicesSrcUdpPortArgs',
    'FirewallFilteringNetworkServicesSrcUdpPortArgsDict',
    'FirewallFilteringRuleAppServiceGroupsArgs',
    'FirewallFilteringRuleAppServiceGroupsArgsDict',
    'FirewallFilteringRuleAppServicesArgs',
    'FirewallFilteringRuleAppServicesArgsDict',
    'FirewallFilteringRuleDepartmentsArgs',
    'FirewallFilteringRuleDepartmentsArgsDict',
    'FirewallFilteringRuleDestIpGroupsArgs',
    'FirewallFilteringRuleDestIpGroupsArgsDict',
    'FirewallFilteringRuleDeviceGroupsArgs',
    'FirewallFilteringRuleDeviceGroupsArgsDict',
    'FirewallFilteringRuleDevicesArgs',
    'FirewallFilteringRuleDevicesArgsDict',
    'FirewallFilteringRuleGroupsArgs',
    'FirewallFilteringRuleGroupsArgsDict',
    'FirewallFilteringRuleLabelsArgs',
    'FirewallFilteringRuleLabelsArgsDict',
    'FirewallFilteringRuleLocationGroupsArgs',
    'FirewallFilteringRuleLocationGroupsArgsDict',
    'FirewallFilteringRuleLocationsArgs',
    'FirewallFilteringRuleLocationsArgsDict',
    'FirewallFilteringRuleNwApplicationGroupsArgs',
    'FirewallFilteringRuleNwApplicationGroupsArgsDict',
    'FirewallFilteringRuleNwServiceGroupsArgs',
    'FirewallFilteringRuleNwServiceGroupsArgsDict',
    'FirewallFilteringRuleNwServicesArgs',
    'FirewallFilteringRuleNwServicesArgsDict',
    'FirewallFilteringRuleSrcIpGroupsArgs',
    'FirewallFilteringRuleSrcIpGroupsArgsDict',
    'FirewallFilteringRuleTimeWindowsArgs',
    'FirewallFilteringRuleTimeWindowsArgsDict',
    'FirewallFilteringRuleUsersArgs',
    'FirewallFilteringRuleUsersArgsDict',
    'FirewallFilteringRuleWorkloadGroupArgs',
    'FirewallFilteringRuleWorkloadGroupArgsDict',
    'FirewallFilteringRuleZpaAppSegmentArgs',
    'FirewallFilteringRuleZpaAppSegmentArgsDict',
    'FirewallFilteringServiceGroupsServiceArgs',
    'FirewallFilteringServiceGroupsServiceArgsDict',
    'FirewallIPSRuleDepartmentsArgs',
    'FirewallIPSRuleDepartmentsArgsDict',
    'FirewallIPSRuleDestIpGroupsArgs',
    'FirewallIPSRuleDestIpGroupsArgsDict',
    'FirewallIPSRuleDestIpv6GroupsArgs',
    'FirewallIPSRuleDestIpv6GroupsArgsDict',
    'FirewallIPSRuleDeviceGroupsArgs',
    'FirewallIPSRuleDeviceGroupsArgsDict',
    'FirewallIPSRuleDevicesArgs',
    'FirewallIPSRuleDevicesArgsDict',
    'FirewallIPSRuleGroupsArgs',
    'FirewallIPSRuleGroupsArgsDict',
    'FirewallIPSRuleLabelsArgs',
    'FirewallIPSRuleLabelsArgsDict',
    'FirewallIPSRuleLocationGroupsArgs',
    'FirewallIPSRuleLocationGroupsArgsDict',
    'FirewallIPSRuleLocationsArgs',
    'FirewallIPSRuleLocationsArgsDict',
    'FirewallIPSRuleNwServiceGroupsArgs',
    'FirewallIPSRuleNwServiceGroupsArgsDict',
    'FirewallIPSRuleNwServicesArgs',
    'FirewallIPSRuleNwServicesArgsDict',
    'FirewallIPSRuleSrcIpGroupsArgs',
    'FirewallIPSRuleSrcIpGroupsArgsDict',
    'FirewallIPSRuleSrcIpv6GroupsArgs',
    'FirewallIPSRuleSrcIpv6GroupsArgsDict',
    'FirewallIPSRuleThreatCategoriesArgs',
    'FirewallIPSRuleThreatCategoriesArgsDict',
    'FirewallIPSRuleTimeWindowsArgs',
    'FirewallIPSRuleTimeWindowsArgsDict',
    'FirewallIPSRuleUsersArgs',
    'FirewallIPSRuleUsersArgsDict',
    'FirewallIPSRuleZpaAppSegmentArgs',
    'FirewallIPSRuleZpaAppSegmentArgsDict',
    'ForwardingControlRuleAppServiceGroupsArgs',
    'ForwardingControlRuleAppServiceGroupsArgsDict',
    'ForwardingControlRuleDepartmentsArgs',
    'ForwardingControlRuleDepartmentsArgsDict',
    'ForwardingControlRuleDestIpGroupsArgs',
    'ForwardingControlRuleDestIpGroupsArgsDict',
    'ForwardingControlRuleDestIpv6GroupsArgs',
    'ForwardingControlRuleDestIpv6GroupsArgsDict',
    'ForwardingControlRuleEcGroupsArgs',
    'ForwardingControlRuleEcGroupsArgsDict',
    'ForwardingControlRuleGroupsArgs',
    'ForwardingControlRuleGroupsArgsDict',
    'ForwardingControlRuleLabelsArgs',
    'ForwardingControlRuleLabelsArgsDict',
    'ForwardingControlRuleLocationGroupsArgs',
    'ForwardingControlRuleLocationGroupsArgsDict',
    'ForwardingControlRuleLocationsArgs',
    'ForwardingControlRuleLocationsArgsDict',
    'ForwardingControlRuleNwApplicationGroupsArgs',
    'ForwardingControlRuleNwApplicationGroupsArgsDict',
    'ForwardingControlRuleNwServiceGroupsArgs',
    'ForwardingControlRuleNwServiceGroupsArgsDict',
    'ForwardingControlRuleNwServicesArgs',
    'ForwardingControlRuleNwServicesArgsDict',
    'ForwardingControlRuleProxyGatewayArgs',
    'ForwardingControlRuleProxyGatewayArgsDict',
    'ForwardingControlRuleSrcIpGroupsArgs',
    'ForwardingControlRuleSrcIpGroupsArgsDict',
    'ForwardingControlRuleSrcIpv6GroupsArgs',
    'ForwardingControlRuleSrcIpv6GroupsArgsDict',
    'ForwardingControlRuleUsersArgs',
    'ForwardingControlRuleUsersArgsDict',
    'ForwardingControlRuleZpaAppSegmentArgs',
    'ForwardingControlRuleZpaAppSegmentArgsDict',
    'ForwardingControlRuleZpaApplicationSegmentGroupsArgs',
    'ForwardingControlRuleZpaApplicationSegmentGroupsArgsDict',
    'ForwardingControlRuleZpaApplicationSegmentsArgs',
    'ForwardingControlRuleZpaApplicationSegmentsArgsDict',
    'ForwardingControlRuleZpaGatewayArgs',
    'ForwardingControlRuleZpaGatewayArgsDict',
    'ForwardingControlZPAGatewayZpaAppSegmentArgs',
    'ForwardingControlZPAGatewayZpaAppSegmentArgsDict',
    'ForwardingControlZPAGatewayZpaServerGroupArgs',
    'ForwardingControlZPAGatewayZpaServerGroupArgsDict',
    'LocationManagementDynamicLocationGroupsArgs',
    'LocationManagementDynamicLocationGroupsArgsDict',
    'LocationManagementStaticLocationGroupsArgs',
    'LocationManagementStaticLocationGroupsArgsDict',
    'LocationManagementVpnCredentialArgs',
    'LocationManagementVpnCredentialArgsDict',
    'SSLInspectionRulesActionArgs',
    'SSLInspectionRulesActionArgsDict',
    'SSLInspectionRulesActionDecryptSubActionArgs',
    'SSLInspectionRulesActionDecryptSubActionArgsDict',
    'SSLInspectionRulesActionDoNotDecryptSubActionArgs',
    'SSLInspectionRulesActionDoNotDecryptSubActionArgsDict',
    'SSLInspectionRulesActionSslInterceptionCertArgs',
    'SSLInspectionRulesActionSslInterceptionCertArgsDict',
    'SSLInspectionRulesDepartmentsArgs',
    'SSLInspectionRulesDepartmentsArgsDict',
    'SSLInspectionRulesDestIpGroupsArgs',
    'SSLInspectionRulesDestIpGroupsArgsDict',
    'SSLInspectionRulesDeviceGroupsArgs',
    'SSLInspectionRulesDeviceGroupsArgsDict',
    'SSLInspectionRulesDevicesArgs',
    'SSLInspectionRulesDevicesArgsDict',
    'SSLInspectionRulesGroupsArgs',
    'SSLInspectionRulesGroupsArgsDict',
    'SSLInspectionRulesLabelsArgs',
    'SSLInspectionRulesLabelsArgsDict',
    'SSLInspectionRulesLocationGroupsArgs',
    'SSLInspectionRulesLocationGroupsArgsDict',
    'SSLInspectionRulesLocationsArgs',
    'SSLInspectionRulesLocationsArgsDict',
    'SSLInspectionRulesProxyGatewaysArgs',
    'SSLInspectionRulesProxyGatewaysArgsDict',
    'SSLInspectionRulesSourceIpGroupsArgs',
    'SSLInspectionRulesSourceIpGroupsArgsDict',
    'SSLInspectionRulesTimeWindowsArgs',
    'SSLInspectionRulesTimeWindowsArgsDict',
    'SSLInspectionRulesUsersArgs',
    'SSLInspectionRulesUsersArgsDict',
    'SSLInspectionRulesWorkloadGroupArgs',
    'SSLInspectionRulesWorkloadGroupArgsDict',
    'SSLInspectionRulesZpaAppSegmentArgs',
    'SSLInspectionRulesZpaAppSegmentArgsDict',
    'SandboxRulesDepartmentsArgs',
    'SandboxRulesDepartmentsArgsDict',
    'SandboxRulesGroupsArgs',
    'SandboxRulesGroupsArgsDict',
    'SandboxRulesLabelsArgs',
    'SandboxRulesLabelsArgsDict',
    'SandboxRulesLocationGroupsArgs',
    'SandboxRulesLocationGroupsArgsDict',
    'SandboxRulesLocationsArgs',
    'SandboxRulesLocationsArgsDict',
    'SandboxRulesUsersArgs',
    'SandboxRulesUsersArgsDict',
    'SandboxRulesZpaAppSegmentArgs',
    'SandboxRulesZpaAppSegmentArgsDict',
    'TrafficForwardingGRETunnelPrimaryDestVipArgs',
    'TrafficForwardingGRETunnelPrimaryDestVipArgsDict',
    'TrafficForwardingGRETunnelSecondaryDestVipArgs',
    'TrafficForwardingGRETunnelSecondaryDestVipArgsDict',
    'URLCategoriesScopeArgs',
    'URLCategoriesScopeArgsDict',
    'URLCategoriesScopeScopeEntitiesArgs',
    'URLCategoriesScopeScopeEntitiesArgsDict',
    'URLCategoriesScopeScopeGroupMemberEntitiesArgs',
    'URLCategoriesScopeScopeGroupMemberEntitiesArgsDict',
    'URLCategoriesUrlKeywordCountsArgs',
    'URLCategoriesUrlKeywordCountsArgsDict',
    'URLFilteringRulesCbiProfileArgs',
    'URLFilteringRulesCbiProfileArgsDict',
    'URLFilteringRulesDepartmentsArgs',
    'URLFilteringRulesDepartmentsArgsDict',
    'URLFilteringRulesDeviceGroupsArgs',
    'URLFilteringRulesDeviceGroupsArgsDict',
    'URLFilteringRulesDevicesArgs',
    'URLFilteringRulesDevicesArgsDict',
    'URLFilteringRulesGroupsArgs',
    'URLFilteringRulesGroupsArgsDict',
    'URLFilteringRulesLabelsArgs',
    'URLFilteringRulesLabelsArgsDict',
    'URLFilteringRulesLocationGroupsArgs',
    'URLFilteringRulesLocationGroupsArgsDict',
    'URLFilteringRulesLocationsArgs',
    'URLFilteringRulesLocationsArgsDict',
    'URLFilteringRulesOverrideGroupsArgs',
    'URLFilteringRulesOverrideGroupsArgsDict',
    'URLFilteringRulesOverrideUsersArgs',
    'URLFilteringRulesOverrideUsersArgsDict',
    'URLFilteringRulesSourceIpGroupsArgs',
    'URLFilteringRulesSourceIpGroupsArgsDict',
    'URLFilteringRulesTimeWindowsArgs',
    'URLFilteringRulesTimeWindowsArgsDict',
    'URLFilteringRulesUsersArgs',
    'URLFilteringRulesUsersArgsDict',
    'URLFilteringRulesWorkloadGroupArgs',
    'URLFilteringRulesWorkloadGroupArgsDict',
    'UserManagementDepartmentArgs',
    'UserManagementDepartmentArgsDict',
    'UserManagementGroupsArgs',
    'UserManagementGroupsArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaCityArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaNameArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict',
    'GetSandboxReportExploitArgs',
    'GetSandboxReportExploitArgsDict',
    'GetSandboxReportNetworkingArgs',
    'GetSandboxReportNetworkingArgsDict',
    'GetSandboxReportPersistenceArgs',
    'GetSandboxReportPersistenceArgsDict',
    'GetSandboxReportSecurityBypassArgs',
    'GetSandboxReportSecurityBypassArgsDict',
    'GetSandboxReportSpywareArgs',
    'GetSandboxReportSpywareArgsDict',
    'GetSandboxReportStealthArgs',
    'GetSandboxReportStealthArgsDict',
]

MYPY = False

if not MYPY:
    class AdminUsersAdminScopeEntitiesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    AdminUsersAdminScopeEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminUsersAdminScopeEntitiesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AdminUsersRoleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AdminUsersRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminUsersRoleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudAppControlRuleCbiProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The browser isolation profile URL
        """
elif False:
    CloudAppControlRuleCbiProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleCbiProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] url: The browser isolation profile URL
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The browser isolation profile URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class CloudAppControlRuleCloudAppRiskProfileArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
elif False:
    CloudAppControlRuleCloudAppRiskProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleCloudAppRiskProfileArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudAppControlRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleLabelsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleLabelsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleTenancyProfileIdsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleTenancyProfileIdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleTenancyProfileIdsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    CloudAppControlRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPDictionariesExactDataMatchDetailArgsDict(TypedDict):
        dictionary_edm_mapping_id: NotRequired[pulumi.Input[builtins.int]]
        """
        The unique identifier for the EDM mapping
        """
        primary_field: NotRequired[pulumi.Input[builtins.int]]
        """
        The EDM template's primary field.
        """
        schema_id: NotRequired[pulumi.Input[builtins.int]]
        """
        The unique identifier for the EDM template (or schema).
        """
        secondary_field_match_on: NotRequired[pulumi.Input[builtins.str]]
        """
        The EDM secondary field to match on.
        """
        secondary_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        The EDM template's secondary fields.
        """
elif False:
    DLPDictionariesExactDataMatchDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesExactDataMatchDetailArgs:
    def __init__(__self__, *,
                 dictionary_edm_mapping_id: Optional[pulumi.Input[builtins.int]] = None,
                 primary_field: Optional[pulumi.Input[builtins.int]] = None,
                 schema_id: Optional[pulumi.Input[builtins.int]] = None,
                 secondary_field_match_on: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_fields: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[builtins.int] dictionary_edm_mapping_id: The unique identifier for the EDM mapping
        :param pulumi.Input[builtins.int] primary_field: The EDM template's primary field.
        :param pulumi.Input[builtins.int] schema_id: The unique identifier for the EDM template (or schema).
        :param pulumi.Input[builtins.str] secondary_field_match_on: The EDM secondary field to match on.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] secondary_fields: The EDM template's secondary fields.
        """
        if dictionary_edm_mapping_id is not None:
            pulumi.set(__self__, "dictionary_edm_mapping_id", dictionary_edm_mapping_id)
        if primary_field is not None:
            pulumi.set(__self__, "primary_field", primary_field)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if secondary_field_match_on is not None:
            pulumi.set(__self__, "secondary_field_match_on", secondary_field_match_on)
        if secondary_fields is not None:
            pulumi.set(__self__, "secondary_fields", secondary_fields)

    @property
    @pulumi.getter(name="dictionaryEdmMappingId")
    def dictionary_edm_mapping_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The unique identifier for the EDM mapping
        """
        return pulumi.get(self, "dictionary_edm_mapping_id")

    @dictionary_edm_mapping_id.setter
    def dictionary_edm_mapping_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dictionary_edm_mapping_id", value)

    @property
    @pulumi.getter(name="primaryField")
    def primary_field(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The EDM template's primary field.
        """
        return pulumi.get(self, "primary_field")

    @primary_field.setter
    def primary_field(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "primary_field", value)

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The unique identifier for the EDM template (or schema).
        """
        return pulumi.get(self, "schema_id")

    @schema_id.setter
    def schema_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "schema_id", value)

    @property
    @pulumi.getter(name="secondaryFieldMatchOn")
    def secondary_field_match_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EDM secondary field to match on.
        """
        return pulumi.get(self, "secondary_field_match_on")

    @secondary_field_match_on.setter
    def secondary_field_match_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_field_match_on", value)

    @property
    @pulumi.getter(name="secondaryFields")
    def secondary_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        The EDM template's secondary fields.
        """
        return pulumi.get(self, "secondary_fields")

    @secondary_fields.setter
    def secondary_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "secondary_fields", value)


if not MYPY:
    class DLPDictionariesIdmProfileMatchAccuracyArgsDict(TypedDict):
        adp_idm_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict']]]]
        """
        The action applied to a DLP dictionary using patterns
        """
        match_accuracy: NotRequired[pulumi.Input[builtins.str]]
        """
        The IDM template match accuracy.
        """
elif False:
    DLPDictionariesIdmProfileMatchAccuracyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesIdmProfileMatchAccuracyArgs:
    def __init__(__self__, *,
                 adp_idm_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]]] = None,
                 match_accuracy: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]] adp_idm_profiles: The action applied to a DLP dictionary using patterns
        :param pulumi.Input[builtins.str] match_accuracy: The IDM template match accuracy.
        """
        if adp_idm_profiles is not None:
            pulumi.set(__self__, "adp_idm_profiles", adp_idm_profiles)
        if match_accuracy is not None:
            pulumi.set(__self__, "match_accuracy", match_accuracy)

    @property
    @pulumi.getter(name="adpIdmProfiles")
    def adp_idm_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]]]:
        """
        The action applied to a DLP dictionary using patterns
        """
        return pulumi.get(self, "adp_idm_profiles")

    @adp_idm_profiles.setter
    def adp_idm_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]]]):
        pulumi.set(self, "adp_idm_profiles", value)

    @property
    @pulumi.getter(name="matchAccuracy")
    def match_accuracy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IDM template match accuracy.
        """
        return pulumi.get(self, "match_accuracy")

    @match_accuracy.setter
    def match_accuracy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_accuracy", value)


if not MYPY:
    class DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict(TypedDict):
        extensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs:
    def __init__(__self__, *,
                 extensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPDictionariesPatternArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        The action applied to a DLP dictionary using patterns
        """
        pattern: NotRequired[pulumi.Input[builtins.str]]
        """
        DLP dictionary pattern
        """
elif False:
    DLPDictionariesPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesPatternArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 pattern: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: The action applied to a DLP dictionary using patterns
        :param pulumi.Input[builtins.str] pattern: DLP dictionary pattern
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The action applied to a DLP dictionary using patterns
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DLP dictionary pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class DLPDictionariesPhraseArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        phrase: NotRequired[pulumi.Input[builtins.str]]
        """
        DLP dictionary phrase
        """
elif False:
    DLPDictionariesPhraseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesPhraseArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 phrase: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] phrase: DLP dictionary phrase
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if phrase is not None:
            pulumi.set(__self__, "phrase", phrase)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def phrase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DLP dictionary phrase
        """
        return pulumi.get(self, "phrase")

    @phrase.setter
    def phrase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "phrase", value)


if not MYPY:
    class DLPWebRulesAuditorArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
elif False:
    DLPWebRulesAuditorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesAuditorArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesDlpEnginesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesDlpEnginesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesDlpEnginesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesExcludedDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesExcludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesExcludedGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesExcludedUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesIcapServerArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
elif False:
    DLPWebRulesIcapServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesIcapServerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesIncludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesIncludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesIncludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    DLPWebRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesNotificationTemplateArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
elif False:
    DLPWebRulesNotificationTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesNotificationTemplateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesSourceIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesSourceIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesSourceIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesUrlCategoriesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesUrlCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesUrlCategoriesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    DLPWebRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource.
        """
elif False:
    DLPWebRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FileTypeControlRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FileTypeControlRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FileTypeControlRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FileTypeControlRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the application segment.
        """
elif False:
    FileTypeControlRulesZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallDNSRuleApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDnsGatewayArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource.
        """
elif False:
    FirewallDNSRuleDnsGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDnsGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallDNSRuleEdnsEcsObjectArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource.
        """
elif False:
    FirewallDNSRuleEdnsEcsObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleEdnsEcsObjectArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallDNSRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallDNSRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirewallDNSRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallDNSRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleZpaIpGroupArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource.
        """
elif False:
    FirewallDNSRuleZpaIpGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleZpaIpGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallFilteringNetworkServicesDestTcpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[builtins.int]]
        start: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallFilteringNetworkServicesDestTcpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesDestTcpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[builtins.int]] = None,
                 start: Optional[pulumi.Input[builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringNetworkServicesDestUdpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[builtins.int]]
        start: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallFilteringNetworkServicesDestUdpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesDestUdpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[builtins.int]] = None,
                 start: Optional[pulumi.Input[builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringNetworkServicesSrcTcpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[builtins.int]]
        start: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallFilteringNetworkServicesSrcTcpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesSrcTcpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[builtins.int]] = None,
                 start: Optional[pulumi.Input[builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringNetworkServicesSrcUdpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[builtins.int]]
        start: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallFilteringNetworkServicesSrcUdpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesSrcUdpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[builtins.int]] = None,
                 start: Optional[pulumi.Input[builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringRuleAppServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleAppServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleAppServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleAppServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleAppServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleAppServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallFilteringRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirewallFilteringRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleNwApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleNwApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleNwApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallFilteringRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource.
        """
elif False:
    FirewallFilteringRuleWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallFilteringRuleZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the application segment.
        """
elif False:
    FirewallFilteringRuleZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallFilteringServiceGroupsServiceArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
elif False:
    FirewallFilteringServiceGroupsServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringServiceGroupsServiceArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
elif False:
    FirewallIPSRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirewallIPSRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleThreatCategoriesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleThreatCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleThreatCategoriesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    FirewallIPSRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallIPSRuleZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the application segment.
        """
elif False:
    FirewallIPSRuleZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallIPSRuleZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlRuleAppServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleAppServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleAppServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleEcGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleEcGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleEcGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] id: (int) Identifier that uniquely identifies an entity
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ForwardingControlRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleNwApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleNwApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleNwApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleProxyGatewayArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        (int) Identifier that uniquely identifies an entity
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        (string) The configured name of the entity
        """
elif False:
    ForwardingControlRuleProxyGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleProxyGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: (int) Identifier that uniquely identifies an entity
        :param pulumi.Input[builtins.str] name: (string) The configured name of the entity
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        (int) Identifier that uniquely identifies an entity
        """
        name: pulumi.Input[builtins.str]
        """
        (string) The configured name of the entity
        """
elif False:
    ForwardingControlRuleZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: (int) Identifier that uniquely identifies an entity
        :param pulumi.Input[builtins.str] name: (string) The configured name of the entity
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlRuleZpaApplicationSegmentGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleZpaApplicationSegmentGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaApplicationSegmentGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleZpaApplicationSegmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleZpaApplicationSegmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaApplicationSegmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleZpaGatewayArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        (int) Identifier that uniquely identifies an entity
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        (string) The configured name of the entity
        """
elif False:
    ForwardingControlRuleZpaGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: (int) Identifier that uniquely identifies an entity
        :param pulumi.Input[builtins.str] name: (string) The configured name of the entity
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlZPAGatewayZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        name: pulumi.Input[builtins.str]
        """
        The configured name of the entity
        """
elif False:
    ForwardingControlZPAGatewayZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlZPAGatewayZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        :param pulumi.Input[builtins.str] name: The configured name of the entity
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlZPAGatewayZpaServerGroupArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        name: pulumi.Input[builtins.str]
        """
        The configured name of the entity
        """
elif False:
    ForwardingControlZPAGatewayZpaServerGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlZPAGatewayZpaServerGroupArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        :param pulumi.Input[builtins.str] name: The configured name of the entity
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LocationManagementDynamicLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    LocationManagementDynamicLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementDynamicLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class LocationManagementStaticLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    LocationManagementStaticLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementStaticLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class LocationManagementVpnCredentialArgsDict(TypedDict):
        comments: NotRequired[pulumi.Input[builtins.str]]
        fqdn: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.int]]
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        pre_shared_key: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    LocationManagementVpnCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementVpnCredentialArgs:
    def __init__(__self__, *,
                 comments: Optional[pulumi.Input[builtins.str]] = None,
                 fqdn: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.int]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 pre_shared_key: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "pre_shared_key")

    @pre_shared_key.setter
    def pre_shared_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pre_shared_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SSLInspectionRulesActionArgsDict(TypedDict):
        decrypt_sub_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgsDict']]]]
        """
        (Block List) - Action taken when enabling SSL intercept
        """
        do_not_decrypt_sub_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgsDict']]]]
        """
        (Block List) - Action taken when bypassing SSL intercept
        """
        override_default_certificate: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to override the default SSL interception certificate.
        """
        show_eun: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Enable this setting to display end user notifications.
        """
        show_eunatp: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to display the EUN ATP page.
        """
        ssl_interception_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgsDict']]]]
        """
        has the following attributes:
        **NOTE** This block can only be set when `override_default_certificate` is `true`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        (String) - The action type for this rule. Possible values: `BLOCK`.
        """
elif False:
    SSLInspectionRulesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionArgs:
    def __init__(__self__, *,
                 decrypt_sub_actions: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]]] = None,
                 do_not_decrypt_sub_actions: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]]] = None,
                 override_default_certificate: Optional[pulumi.Input[builtins.bool]] = None,
                 show_eun: Optional[pulumi.Input[builtins.bool]] = None,
                 show_eunatp: Optional[pulumi.Input[builtins.bool]] = None,
                 ssl_interception_certs: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]] decrypt_sub_actions: (Block List) - Action taken when enabling SSL intercept
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]] do_not_decrypt_sub_actions: (Block List) - Action taken when bypassing SSL intercept
        :param pulumi.Input[builtins.bool] override_default_certificate: (Boolean) - Whether to override the default SSL interception certificate.
        :param pulumi.Input[builtins.bool] show_eun: (Boolean) - Enable this setting to display end user notifications.
        :param pulumi.Input[builtins.bool] show_eunatp: (Boolean) - Whether to display the EUN ATP page.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]] ssl_interception_certs: has the following attributes:
               **NOTE** This block can only be set when `override_default_certificate` is `true`
        :param pulumi.Input[builtins.str] type: (String) - The action type for this rule. Possible values: `BLOCK`.
        """
        if decrypt_sub_actions is not None:
            pulumi.set(__self__, "decrypt_sub_actions", decrypt_sub_actions)
        if do_not_decrypt_sub_actions is not None:
            pulumi.set(__self__, "do_not_decrypt_sub_actions", do_not_decrypt_sub_actions)
        if override_default_certificate is not None:
            pulumi.set(__self__, "override_default_certificate", override_default_certificate)
        if show_eun is not None:
            pulumi.set(__self__, "show_eun", show_eun)
        if show_eunatp is not None:
            pulumi.set(__self__, "show_eunatp", show_eunatp)
        if ssl_interception_certs is not None:
            pulumi.set(__self__, "ssl_interception_certs", ssl_interception_certs)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="decryptSubActions")
    def decrypt_sub_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]]]:
        """
        (Block List) - Action taken when enabling SSL intercept
        """
        return pulumi.get(self, "decrypt_sub_actions")

    @decrypt_sub_actions.setter
    def decrypt_sub_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]]]):
        pulumi.set(self, "decrypt_sub_actions", value)

    @property
    @pulumi.getter(name="doNotDecryptSubActions")
    def do_not_decrypt_sub_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]]]:
        """
        (Block List) - Action taken when bypassing SSL intercept
        """
        return pulumi.get(self, "do_not_decrypt_sub_actions")

    @do_not_decrypt_sub_actions.setter
    def do_not_decrypt_sub_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]]]):
        pulumi.set(self, "do_not_decrypt_sub_actions", value)

    @property
    @pulumi.getter(name="overrideDefaultCertificate")
    def override_default_certificate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to override the default SSL interception certificate.
        """
        return pulumi.get(self, "override_default_certificate")

    @override_default_certificate.setter
    def override_default_certificate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_default_certificate", value)

    @property
    @pulumi.getter(name="showEun")
    def show_eun(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Enable this setting to display end user notifications.
        """
        return pulumi.get(self, "show_eun")

    @show_eun.setter
    def show_eun(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "show_eun", value)

    @property
    @pulumi.getter(name="showEunatp")
    def show_eunatp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to display the EUN ATP page.
        """
        return pulumi.get(self, "show_eunatp")

    @show_eunatp.setter
    def show_eunatp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "show_eunatp", value)

    @property
    @pulumi.getter(name="sslInterceptionCerts")
    def ssl_interception_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]]]:
        """
        has the following attributes:
        **NOTE** This block can only be set when `override_default_certificate` is `true`
        """
        return pulumi.get(self, "ssl_interception_certs")

    @ssl_interception_certs.setter
    def ssl_interception_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]]]):
        pulumi.set(self, "ssl_interception_certs", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - The action type for this rule. Possible values: `BLOCK`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SSLInspectionRulesActionDecryptSubActionArgsDict(TypedDict):
        block_ssl_traffic_with_no_sni_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        block_undecrypt: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Enable to block traffic from servers that use non-standard encryption methods or require mutual TLS authentication.
        """
        http2_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean)
        """
        min_client_tls_version: NotRequired[pulumi.Input[builtins.str]]
        """
        (String) - The minimum TLS version allowed on the client side: Supported Values are: `CLIENT_TLS_1_0`, `CLIENT_TLS_1_1`, `CLIENT_TLS_1_2`,  `CLIENT_TLS_1_3`.
        """
        min_server_tls_version: NotRequired[pulumi.Input[builtins.str]]
        """
        (String) - The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        """
        ocsp_check: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to enable OCSP check.
        """
        server_certificates: NotRequired[pulumi.Input[builtins.str]]
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
elif False:
    SSLInspectionRulesActionDecryptSubActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionDecryptSubActionArgs:
    def __init__(__self__, *,
                 block_ssl_traffic_with_no_sni_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 block_undecrypt: Optional[pulumi.Input[builtins.bool]] = None,
                 http2_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 min_client_tls_version: Optional[pulumi.Input[builtins.str]] = None,
                 min_server_tls_version: Optional[pulumi.Input[builtins.str]] = None,
                 ocsp_check: Optional[pulumi.Input[builtins.bool]] = None,
                 server_certificates: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] block_ssl_traffic_with_no_sni_enabled: (Boolean) - Whether to block SSL traffic when SNI is not present.
        :param pulumi.Input[builtins.bool] block_undecrypt: (Boolean) - Enable to block traffic from servers that use non-standard encryption methods or require mutual TLS authentication.
        :param pulumi.Input[builtins.bool] http2_enabled: (Boolean)
        :param pulumi.Input[builtins.str] min_client_tls_version: (String) - The minimum TLS version allowed on the client side: Supported Values are: `CLIENT_TLS_1_0`, `CLIENT_TLS_1_1`, `CLIENT_TLS_1_2`,  `CLIENT_TLS_1_3`.
        :param pulumi.Input[builtins.str] min_server_tls_version: (String) - The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        :param pulumi.Input[builtins.bool] ocsp_check: (Boolean) - Whether to enable OCSP check.
        :param pulumi.Input[builtins.str] server_certificates: (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        if block_ssl_traffic_with_no_sni_enabled is not None:
            pulumi.set(__self__, "block_ssl_traffic_with_no_sni_enabled", block_ssl_traffic_with_no_sni_enabled)
        if block_undecrypt is not None:
            pulumi.set(__self__, "block_undecrypt", block_undecrypt)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if min_client_tls_version is not None:
            pulumi.set(__self__, "min_client_tls_version", min_client_tls_version)
        if min_server_tls_version is not None:
            pulumi.set(__self__, "min_server_tls_version", min_server_tls_version)
        if ocsp_check is not None:
            pulumi.set(__self__, "ocsp_check", ocsp_check)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @property
    @pulumi.getter(name="blockSslTrafficWithNoSniEnabled")
    def block_ssl_traffic_with_no_sni_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        return pulumi.get(self, "block_ssl_traffic_with_no_sni_enabled")

    @block_ssl_traffic_with_no_sni_enabled.setter
    def block_ssl_traffic_with_no_sni_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_ssl_traffic_with_no_sni_enabled", value)

    @property
    @pulumi.getter(name="blockUndecrypt")
    def block_undecrypt(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Enable to block traffic from servers that use non-standard encryption methods or require mutual TLS authentication.
        """
        return pulumi.get(self, "block_undecrypt")

    @block_undecrypt.setter
    def block_undecrypt(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_undecrypt", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean)
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="minClientTlsVersion")
    def min_client_tls_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - The minimum TLS version allowed on the client side: Supported Values are: `CLIENT_TLS_1_0`, `CLIENT_TLS_1_1`, `CLIENT_TLS_1_2`,  `CLIENT_TLS_1_3`.
        """
        return pulumi.get(self, "min_client_tls_version")

    @min_client_tls_version.setter
    def min_client_tls_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_client_tls_version", value)

    @property
    @pulumi.getter(name="minServerTlsVersion")
    def min_server_tls_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        """
        return pulumi.get(self, "min_server_tls_version")

    @min_server_tls_version.setter
    def min_server_tls_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_server_tls_version", value)

    @property
    @pulumi.getter(name="ocspCheck")
    def ocsp_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to enable OCSP check.
        """
        return pulumi.get(self, "ocsp_check")

    @ocsp_check.setter
    def ocsp_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ocsp_check", value)

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_certificates", value)


if not MYPY:
    class SSLInspectionRulesActionDoNotDecryptSubActionArgsDict(TypedDict):
        block_ssl_traffic_with_no_sni_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        bypass_other_policies: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to bypass other policies when action is set to `DO_NOT_DECRYPT`.
        """
        min_tls_version: NotRequired[pulumi.Input[builtins.str]]
        """
        (String) -  The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        **NOTE** `min_tls_version` and `server_certificates` CANNOT be set if `bypass_other_policies` is `true`
        """
        ocsp_check: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Boolean) - Whether to enable OCSP check.
        """
        server_certificates: NotRequired[pulumi.Input[builtins.str]]
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
elif False:
    SSLInspectionRulesActionDoNotDecryptSubActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionDoNotDecryptSubActionArgs:
    def __init__(__self__, *,
                 block_ssl_traffic_with_no_sni_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_other_policies: Optional[pulumi.Input[builtins.bool]] = None,
                 min_tls_version: Optional[pulumi.Input[builtins.str]] = None,
                 ocsp_check: Optional[pulumi.Input[builtins.bool]] = None,
                 server_certificates: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] block_ssl_traffic_with_no_sni_enabled: (Boolean) - Whether to block SSL traffic when SNI is not present.
        :param pulumi.Input[builtins.bool] bypass_other_policies: (Boolean) - Whether to bypass other policies when action is set to `DO_NOT_DECRYPT`.
        :param pulumi.Input[builtins.str] min_tls_version: (String) -  The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
               **NOTE** `min_tls_version` and `server_certificates` CANNOT be set if `bypass_other_policies` is `true`
        :param pulumi.Input[builtins.bool] ocsp_check: (Boolean) - Whether to enable OCSP check.
        :param pulumi.Input[builtins.str] server_certificates: (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        if block_ssl_traffic_with_no_sni_enabled is not None:
            pulumi.set(__self__, "block_ssl_traffic_with_no_sni_enabled", block_ssl_traffic_with_no_sni_enabled)
        if bypass_other_policies is not None:
            pulumi.set(__self__, "bypass_other_policies", bypass_other_policies)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if ocsp_check is not None:
            pulumi.set(__self__, "ocsp_check", ocsp_check)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @property
    @pulumi.getter(name="blockSslTrafficWithNoSniEnabled")
    def block_ssl_traffic_with_no_sni_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        return pulumi.get(self, "block_ssl_traffic_with_no_sni_enabled")

    @block_ssl_traffic_with_no_sni_enabled.setter
    def block_ssl_traffic_with_no_sni_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_ssl_traffic_with_no_sni_enabled", value)

    @property
    @pulumi.getter(name="bypassOtherPolicies")
    def bypass_other_policies(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to bypass other policies when action is set to `DO_NOT_DECRYPT`.
        """
        return pulumi.get(self, "bypass_other_policies")

    @bypass_other_policies.setter
    def bypass_other_policies(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bypass_other_policies", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) -  The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        **NOTE** `min_tls_version` and `server_certificates` CANNOT be set if `bypass_other_policies` is `true`
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="ocspCheck")
    def ocsp_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Whether to enable OCSP check.
        """
        return pulumi.get(self, "ocsp_check")

    @ocsp_check.setter
    def ocsp_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ocsp_check", value)

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_certificates", value)


if not MYPY:
    class SSLInspectionRulesActionSslInterceptionCertArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesActionSslInterceptionCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionSslInterceptionCertArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] id: (Integer) - A unique identifier assigned to the workload group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SSLInspectionRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] id: (Integer) - A unique identifier assigned to the workload group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SSLInspectionRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesProxyGatewaysArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesProxyGatewaysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesProxyGatewaysArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesSourceIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesSourceIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesSourceIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource.
        """
elif False:
    SSLInspectionRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: (Integer) - A unique identifier assigned to the workload group
        :param pulumi.Input[builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SSLInspectionRulesZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the application segment.
        """
elif False:
    SSLInspectionRulesZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SandboxRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] id: (Integer) Identifier that uniquely identifies an entity
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SandboxRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the application segment.
        """
elif False:
    SandboxRulesZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TrafficForwardingGRETunnelPrimaryDestVipArgsDict(TypedDict):
        datacenter: NotRequired[pulumi.Input[builtins.str]]
        """
        Data center information
        """
        id: NotRequired[pulumi.Input[builtins.int]]
        """
        GRE cluster virtual IP ID
        """
        virtual_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        GRE cluster virtual IP address (VIP)
        """
elif False:
    TrafficForwardingGRETunnelPrimaryDestVipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficForwardingGRETunnelPrimaryDestVipArgs:
    def __init__(__self__, *,
                 datacenter: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.int]] = None,
                 virtual_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] datacenter: Data center information
        :param pulumi.Input[builtins.int] id: GRE cluster virtual IP ID
        :param pulumi.Input[builtins.str] virtual_ip: GRE cluster virtual IP address (VIP)
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Data center information
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        GRE cluster virtual IP ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GRE cluster virtual IP address (VIP)
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class TrafficForwardingGRETunnelSecondaryDestVipArgsDict(TypedDict):
        datacenter: NotRequired[pulumi.Input[builtins.str]]
        """
        Data center information
        """
        id: NotRequired[pulumi.Input[builtins.int]]
        """
        GRE cluster virtual IP ID
        """
        virtual_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        GRE cluster virtual IP address (VIP)
        """
elif False:
    TrafficForwardingGRETunnelSecondaryDestVipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficForwardingGRETunnelSecondaryDestVipArgs:
    def __init__(__self__, *,
                 datacenter: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.int]] = None,
                 virtual_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] datacenter: Data center information
        :param pulumi.Input[builtins.int] id: GRE cluster virtual IP ID
        :param pulumi.Input[builtins.str] virtual_ip: GRE cluster virtual IP address (VIP)
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Data center information
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        GRE cluster virtual IP ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GRE cluster virtual IP address (VIP)
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class URLCategoriesScopeArgsDict(TypedDict):
        scope_entities: NotRequired[pulumi.Input['URLCategoriesScopeScopeEntitiesArgsDict']]
        """
        list of scope IDs
        """
        scope_group_member_entities: NotRequired[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgsDict']]
        """
        list of scope group member IDs
        """
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    URLCategoriesScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesScopeArgs:
    def __init__(__self__, *,
                 scope_entities: Optional[pulumi.Input['URLCategoriesScopeScopeEntitiesArgs']] = None,
                 scope_group_member_entities: Optional[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['URLCategoriesScopeScopeEntitiesArgs'] scope_entities: list of scope IDs
        :param pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs'] scope_group_member_entities: list of scope group member IDs
        """
        if scope_entities is not None:
            pulumi.set(__self__, "scope_entities", scope_entities)
        if scope_group_member_entities is not None:
            pulumi.set(__self__, "scope_group_member_entities", scope_group_member_entities)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="scopeEntities")
    def scope_entities(self) -> Optional[pulumi.Input['URLCategoriesScopeScopeEntitiesArgs']]:
        """
        list of scope IDs
        """
        return pulumi.get(self, "scope_entities")

    @scope_entities.setter
    def scope_entities(self, value: Optional[pulumi.Input['URLCategoriesScopeScopeEntitiesArgs']]):
        pulumi.set(self, "scope_entities", value)

    @property
    @pulumi.getter(name="scopeGroupMemberEntities")
    def scope_group_member_entities(self) -> Optional[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs']]:
        """
        list of scope group member IDs
        """
        return pulumi.get(self, "scope_group_member_entities")

    @scope_group_member_entities.setter
    def scope_group_member_entities(self, value: Optional[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs']]):
        pulumi.set(self, "scope_group_member_entities", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class URLCategoriesScopeScopeEntitiesArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
elif False:
    URLCategoriesScopeScopeEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesScopeScopeEntitiesArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLCategoriesScopeScopeGroupMemberEntitiesArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
elif False:
    URLCategoriesScopeScopeGroupMemberEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesScopeScopeGroupMemberEntitiesArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLCategoriesUrlKeywordCountsArgsDict(TypedDict):
        retain_parent_keyword_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Count of total keywords with retain parent category.
        """
        retain_parent_url_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Count of URLs with retain parent category.
        """
        total_keyword_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Total keyword count for the category.
        """
        total_url_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Custom URL count for the category.
        """
elif False:
    URLCategoriesUrlKeywordCountsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesUrlKeywordCountsArgs:
    def __init__(__self__, *,
                 retain_parent_keyword_count: Optional[pulumi.Input[builtins.int]] = None,
                 retain_parent_url_count: Optional[pulumi.Input[builtins.int]] = None,
                 total_keyword_count: Optional[pulumi.Input[builtins.int]] = None,
                 total_url_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] retain_parent_keyword_count: Count of total keywords with retain parent category.
        :param pulumi.Input[builtins.int] retain_parent_url_count: Count of URLs with retain parent category.
        :param pulumi.Input[builtins.int] total_keyword_count: Total keyword count for the category.
        :param pulumi.Input[builtins.int] total_url_count: Custom URL count for the category.
        """
        if retain_parent_keyword_count is not None:
            pulumi.set(__self__, "retain_parent_keyword_count", retain_parent_keyword_count)
        if retain_parent_url_count is not None:
            pulumi.set(__self__, "retain_parent_url_count", retain_parent_url_count)
        if total_keyword_count is not None:
            pulumi.set(__self__, "total_keyword_count", total_keyword_count)
        if total_url_count is not None:
            pulumi.set(__self__, "total_url_count", total_url_count)

    @property
    @pulumi.getter(name="retainParentKeywordCount")
    def retain_parent_keyword_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Count of total keywords with retain parent category.
        """
        return pulumi.get(self, "retain_parent_keyword_count")

    @retain_parent_keyword_count.setter
    def retain_parent_keyword_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retain_parent_keyword_count", value)

    @property
    @pulumi.getter(name="retainParentUrlCount")
    def retain_parent_url_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Count of URLs with retain parent category.
        """
        return pulumi.get(self, "retain_parent_url_count")

    @retain_parent_url_count.setter
    def retain_parent_url_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retain_parent_url_count", value)

    @property
    @pulumi.getter(name="totalKeywordCount")
    def total_keyword_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Total keyword count for the category.
        """
        return pulumi.get(self, "total_keyword_count")

    @total_keyword_count.setter
    def total_keyword_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "total_keyword_count", value)

    @property
    @pulumi.getter(name="totalUrlCount")
    def total_url_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Custom URL count for the category.
        """
        return pulumi.get(self, "total_url_count")

    @total_url_count.setter
    def total_url_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "total_url_count", value)


if not MYPY:
    class URLFilteringRulesCbiProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The browser isolation profile URL
        """
elif False:
    URLFilteringRulesCbiProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesCbiProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.str] url: The browser isolation profile URL
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The browser isolation profile URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class URLFilteringRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesLabelsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesLabelsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesOverrideGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesOverrideGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesOverrideGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesOverrideUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesOverrideUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesOverrideUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesSourceIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesSourceIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesSourceIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    URLFilteringRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
elif False:
    URLFilteringRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.int],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserManagementDepartmentArgsDict(TypedDict):
        comments: NotRequired[pulumi.Input[builtins.str]]
        """
        Additional information about this department
        """
        deleted: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.int]]
        idp_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Identity provider (IdP) ID
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        User name. This appears when choosing users for policies.
        """
elif False:
    UserManagementDepartmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserManagementDepartmentArgs:
    def __init__(__self__, *,
                 comments: Optional[pulumi.Input[builtins.str]] = None,
                 deleted: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.int]] = None,
                 idp_id: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] comments: Additional information about this department
        :param pulumi.Input[builtins.int] idp_id: Identity provider (IdP) ID
        :param pulumi.Input[builtins.str] name: User name. This appears when choosing users for policies.
        """
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if deleted is not None:
            pulumi.set(__self__, "deleted", deleted)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Additional information about this department
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter
    def deleted(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "deleted")

    @deleted.setter
    def deleted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "deleted", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Identity provider (IdP) ID
        """
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idp_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name. This appears when choosing users for policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserManagementGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        Unique identfier for the group
        """
elif False:
    UserManagementGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserManagementGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] ids: Unique identfier for the group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        Unique identfier for the group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaArgsDict(TypedDict):
        enable_bandwidth_control: builtins.bool
        """
        (Boolean) Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        """
        enable_caution: builtins.bool
        """
        (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        """
        enable_xff_forwarding: builtins.bool
        """
        (Boolean) Enable `XFF` Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        """
        enforce_aup: builtins.bool
        """
        (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        """
        enforce_authentication: builtins.bool
        """
        (Boolean) Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        """
        enforce_firewall_control: builtins.bool
        """
        (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        """
        managed_bies: Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict']
        """
        (Block List)
        """
        cities: NotRequired[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict']]
        """
        (Block List)
        """
        countries: NotRequired[Sequence[builtins.str]]
        """
        (List of String) One or more countries from a predefined set
        """
        names: NotRequired[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict']]
        """
        Location group name
        """
        profiles: NotRequired[Sequence[builtins.str]]
        """
        (List of String) One or more location profiles from a predefined set
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaArgs:
    def __init__(__self__, *,
                 enable_bandwidth_control: builtins.bool,
                 enable_caution: builtins.bool,
                 enable_xff_forwarding: builtins.bool,
                 enforce_aup: builtins.bool,
                 enforce_authentication: builtins.bool,
                 enforce_firewall_control: builtins.bool,
                 managed_bies: Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs'],
                 cities: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs']] = None,
                 countries: Optional[Sequence[builtins.str]] = None,
                 names: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs']] = None,
                 profiles: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool enable_bandwidth_control: (Boolean) Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        :param builtins.bool enable_caution: (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        :param builtins.bool enable_xff_forwarding: (Boolean) Enable `XFF` Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        :param builtins.bool enforce_aup: (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        :param builtins.bool enforce_authentication: (Boolean) Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        :param builtins.bool enforce_firewall_control: (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        :param Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs'] managed_bies: (Block List)
        :param Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs'] cities: (Block List)
        :param Sequence[builtins.str] countries: (List of String) One or more countries from a predefined set
        :param Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs'] names: Location group name
        :param Sequence[builtins.str] profiles: (List of String) One or more location profiles from a predefined set
        """
        pulumi.set(__self__, "enable_bandwidth_control", enable_bandwidth_control)
        pulumi.set(__self__, "enable_caution", enable_caution)
        pulumi.set(__self__, "enable_xff_forwarding", enable_xff_forwarding)
        pulumi.set(__self__, "enforce_aup", enforce_aup)
        pulumi.set(__self__, "enforce_authentication", enforce_authentication)
        pulumi.set(__self__, "enforce_firewall_control", enforce_firewall_control)
        pulumi.set(__self__, "managed_bies", managed_bies)
        if cities is not None:
            pulumi.set(__self__, "cities", cities)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)

    @property
    @pulumi.getter(name="enableBandwidthControl")
    def enable_bandwidth_control(self) -> builtins.bool:
        """
        (Boolean) Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        """
        return pulumi.get(self, "enable_bandwidth_control")

    @enable_bandwidth_control.setter
    def enable_bandwidth_control(self, value: builtins.bool):
        pulumi.set(self, "enable_bandwidth_control", value)

    @property
    @pulumi.getter(name="enableCaution")
    def enable_caution(self) -> builtins.bool:
        """
        (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        """
        return pulumi.get(self, "enable_caution")

    @enable_caution.setter
    def enable_caution(self, value: builtins.bool):
        pulumi.set(self, "enable_caution", value)

    @property
    @pulumi.getter(name="enableXffForwarding")
    def enable_xff_forwarding(self) -> builtins.bool:
        """
        (Boolean) Enable `XFF` Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        """
        return pulumi.get(self, "enable_xff_forwarding")

    @enable_xff_forwarding.setter
    def enable_xff_forwarding(self, value: builtins.bool):
        pulumi.set(self, "enable_xff_forwarding", value)

    @property
    @pulumi.getter(name="enforceAup")
    def enforce_aup(self) -> builtins.bool:
        """
        (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        """
        return pulumi.get(self, "enforce_aup")

    @enforce_aup.setter
    def enforce_aup(self, value: builtins.bool):
        pulumi.set(self, "enforce_aup", value)

    @property
    @pulumi.getter(name="enforceAuthentication")
    def enforce_authentication(self) -> builtins.bool:
        """
        (Boolean) Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        """
        return pulumi.get(self, "enforce_authentication")

    @enforce_authentication.setter
    def enforce_authentication(self, value: builtins.bool):
        pulumi.set(self, "enforce_authentication", value)

    @property
    @pulumi.getter(name="enforceFirewallControl")
    def enforce_firewall_control(self) -> builtins.bool:
        """
        (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        """
        return pulumi.get(self, "enforce_firewall_control")

    @enforce_firewall_control.setter
    def enforce_firewall_control(self, value: builtins.bool):
        pulumi.set(self, "enforce_firewall_control", value)

    @property
    @pulumi.getter(name="managedBies")
    def managed_bies(self) -> Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs']:
        """
        (Block List)
        """
        return pulumi.get(self, "managed_bies")

    @managed_bies.setter
    def managed_bies(self, value: Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs']):
        pulumi.set(self, "managed_bies", value)

    @property
    @pulumi.getter
    def cities(self) -> Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs']]:
        """
        (Block List)
        """
        return pulumi.get(self, "cities")

    @cities.setter
    def cities(self, value: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs']]):
        pulumi.set(self, "cities", value)

    @property
    @pulumi.getter
    def countries(self) -> Optional[Sequence[builtins.str]]:
        """
        (List of String) One or more countries from a predefined set
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "countries", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs']]:
        """
        Location group name
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs']]):
        pulumi.set(self, "names", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[builtins.str]]:
        """
        (List of String) One or more location profiles from a predefined set
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "profiles", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict(TypedDict):
        match_string: NotRequired[builtins.str]
        """
        (String) String value to be matched or partially matched
        """
        match_type: NotRequired[builtins.str]
        """
        (String) Operator that performs match action
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaCityArgs:
    def __init__(__self__, *,
                 match_string: Optional[builtins.str] = None,
                 match_type: Optional[builtins.str] = None):
        """
        :param builtins.str match_string: (String) String value to be matched or partially matched
        :param builtins.str match_type: (String) Operator that performs match action
        """
        if match_string is not None:
            pulumi.set(__self__, "match_string", match_string)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="matchString")
    def match_string(self) -> Optional[builtins.str]:
        """
        (String) String value to be matched or partially matched
        """
        return pulumi.get(self, "match_string")

    @match_string.setter
    def match_string(self, value: Optional[builtins.str]):
        pulumi.set(self, "match_string", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[builtins.str]:
        """
        (String) Operator that performs match action
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict(TypedDict):
        extensions: Mapping[str, builtins.str]
        """
        (Map of String)
        """
        id: builtins.int
        """
        Unique identifier for the location group
        """
        name: builtins.str
        """
        Location group name
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs:
    def __init__(__self__, *,
                 extensions: Mapping[str, builtins.str],
                 id: builtins.int,
                 name: builtins.str):
        """
        :param Mapping[str, builtins.str] extensions: (Map of String)
        :param builtins.int id: Unique identifier for the location group
        :param builtins.str name: Location group name
        """
        pulumi.set(__self__, "extensions", extensions)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def extensions(self) -> Mapping[str, builtins.str]:
        """
        (Map of String)
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Mapping[str, builtins.str]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        Unique identifier for the location group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Location group name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict(TypedDict):
        match_string: NotRequired[builtins.str]
        """
        (String) String value to be matched or partially matched
        """
        match_type: NotRequired[builtins.str]
        """
        (String) Operator that performs match action
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaNameArgs:
    def __init__(__self__, *,
                 match_string: Optional[builtins.str] = None,
                 match_type: Optional[builtins.str] = None):
        """
        :param builtins.str match_string: (String) String value to be matched or partially matched
        :param builtins.str match_type: (String) Operator that performs match action
        """
        if match_string is not None:
            pulumi.set(__self__, "match_string", match_string)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="matchString")
    def match_string(self) -> Optional[builtins.str]:
        """
        (String) String value to be matched or partially matched
        """
        return pulumi.get(self, "match_string")

    @match_string.setter
    def match_string(self, value: Optional[builtins.str]):
        pulumi.set(self, "match_string", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[builtins.str]:
        """
        (String) Operator that performs match action
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class GetSandboxReportExploitArgsDict(TypedDict):
        risk: builtins.str
        signature: builtins.str
        signature_sources: Sequence[builtins.str]
elif False:
    GetSandboxReportExploitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportExploitArgs:
    def __init__(__self__, *,
                 risk: builtins.str,
                 signature: builtins.str,
                 signature_sources: Sequence[builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @property
    @pulumi.getter
    def risk(self) -> builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: builtins.str):
        pulumi.set(self, "risk", value)

    @property
    @pulumi.getter
    def signature(self) -> builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: builtins.str):
        pulumi.set(self, "signature", value)

    @property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportNetworkingArgsDict(TypedDict):
        risk: builtins.str
        signature: builtins.str
        signature_sources: Sequence[builtins.str]
elif False:
    GetSandboxReportNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportNetworkingArgs:
    def __init__(__self__, *,
                 risk: builtins.str,
                 signature: builtins.str,
                 signature_sources: Sequence[builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @property
    @pulumi.getter
    def risk(self) -> builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: builtins.str):
        pulumi.set(self, "risk", value)

    @property
    @pulumi.getter
    def signature(self) -> builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: builtins.str):
        pulumi.set(self, "signature", value)

    @property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportPersistenceArgsDict(TypedDict):
        risk: builtins.str
        signature: builtins.str
        signature_sources: Sequence[builtins.str]
elif False:
    GetSandboxReportPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportPersistenceArgs:
    def __init__(__self__, *,
                 risk: builtins.str,
                 signature: builtins.str,
                 signature_sources: Sequence[builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @property
    @pulumi.getter
    def risk(self) -> builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: builtins.str):
        pulumi.set(self, "risk", value)

    @property
    @pulumi.getter
    def signature(self) -> builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: builtins.str):
        pulumi.set(self, "signature", value)

    @property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportSecurityBypassArgsDict(TypedDict):
        risk: builtins.str
        signature: builtins.str
        signature_sources: Sequence[builtins.str]
elif False:
    GetSandboxReportSecurityBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportSecurityBypassArgs:
    def __init__(__self__, *,
                 risk: builtins.str,
                 signature: builtins.str,
                 signature_sources: Sequence[builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @property
    @pulumi.getter
    def risk(self) -> builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: builtins.str):
        pulumi.set(self, "risk", value)

    @property
    @pulumi.getter
    def signature(self) -> builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: builtins.str):
        pulumi.set(self, "signature", value)

    @property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportSpywareArgsDict(TypedDict):
        risk: builtins.str
        signature: builtins.str
        signature_sources: Sequence[builtins.str]
elif False:
    GetSandboxReportSpywareArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportSpywareArgs:
    def __init__(__self__, *,
                 risk: builtins.str,
                 signature: builtins.str,
                 signature_sources: Sequence[builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @property
    @pulumi.getter
    def risk(self) -> builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: builtins.str):
        pulumi.set(self, "risk", value)

    @property
    @pulumi.getter
    def signature(self) -> builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: builtins.str):
        pulumi.set(self, "signature", value)

    @property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportStealthArgsDict(TypedDict):
        risk: builtins.str
        signature: builtins.str
        signature_sources: Sequence[builtins.str]
elif False:
    GetSandboxReportStealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportStealthArgs:
    def __init__(__self__, *,
                 risk: builtins.str,
                 signature: builtins.str,
                 signature_sources: Sequence[builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @property
    @pulumi.getter
    def risk(self) -> builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: builtins.str):
        pulumi.set(self, "risk", value)

    @property
    @pulumi.getter
    def signature(self) -> builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: builtins.str):
        pulumi.set(self, "signature", value)

    @property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[builtins.str]):
        pulumi.set(self, "signature_sources", value)



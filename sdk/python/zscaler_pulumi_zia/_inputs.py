# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AdminUsersAdminScopeEntitiesArgs',
    'AdminUsersAdminScopeEntitiesArgsDict',
    'AdminUsersRoleArgs',
    'AdminUsersRoleArgsDict',
    'BandwidthControlRuleBandwidthClassesArgs',
    'BandwidthControlRuleBandwidthClassesArgsDict',
    'BandwidthControlRuleLabelsArgs',
    'BandwidthControlRuleLabelsArgsDict',
    'BandwidthControlRuleLocationGroupsArgs',
    'BandwidthControlRuleLocationGroupsArgsDict',
    'BandwidthControlRuleLocationsArgs',
    'BandwidthControlRuleLocationsArgsDict',
    'BandwidthControlRuleTimeWindowsArgs',
    'BandwidthControlRuleTimeWindowsArgsDict',
    'BrowserControlPolicySmartIsolationGroupsArgs',
    'BrowserControlPolicySmartIsolationGroupsArgsDict',
    'BrowserControlPolicySmartIsolationProfileArgs',
    'BrowserControlPolicySmartIsolationProfileArgsDict',
    'BrowserControlPolicySmartIsolationUsersArgs',
    'BrowserControlPolicySmartIsolationUsersArgsDict',
    'BrowserControlSettingsSmartIsolationGroupsArgs',
    'BrowserControlSettingsSmartIsolationGroupsArgsDict',
    'BrowserControlSettingsSmartIsolationProfileArgs',
    'BrowserControlSettingsSmartIsolationProfileArgsDict',
    'BrowserControlSettingsSmartIsolationUsersArgs',
    'BrowserControlSettingsSmartIsolationUsersArgsDict',
    'CasbDlpRuleAuditorNotificationArgs',
    'CasbDlpRuleAuditorNotificationArgsDict',
    'CasbDlpRuleBucketsArgs',
    'CasbDlpRuleBucketsArgsDict',
    'CasbDlpRuleCasbEmailLabelArgs',
    'CasbDlpRuleCasbEmailLabelArgsDict',
    'CasbDlpRuleCasbTombstoneTemplateArgs',
    'CasbDlpRuleCasbTombstoneTemplateArgsDict',
    'CasbDlpRuleCloudAppTenantsArgs',
    'CasbDlpRuleCloudAppTenantsArgsDict',
    'CasbDlpRuleCriteriaDomainProfilesArgs',
    'CasbDlpRuleCriteriaDomainProfilesArgsDict',
    'CasbDlpRuleDepartmentsArgs',
    'CasbDlpRuleDepartmentsArgsDict',
    'CasbDlpRuleDlpEnginesArgs',
    'CasbDlpRuleDlpEnginesArgsDict',
    'CasbDlpRuleEmailRecipientProfilesArgs',
    'CasbDlpRuleEmailRecipientProfilesArgsDict',
    'CasbDlpRuleEntityGroupsArgs',
    'CasbDlpRuleEntityGroupsArgsDict',
    'CasbDlpRuleExcludedDomainProfilesArgs',
    'CasbDlpRuleExcludedDomainProfilesArgsDict',
    'CasbDlpRuleGroupsArgs',
    'CasbDlpRuleGroupsArgsDict',
    'CasbDlpRuleIncludedDomainProfilesArgs',
    'CasbDlpRuleIncludedDomainProfilesArgsDict',
    'CasbDlpRuleLabelsArgs',
    'CasbDlpRuleLabelsArgsDict',
    'CasbDlpRuleObjectTypesArgs',
    'CasbDlpRuleObjectTypesArgsDict',
    'CasbDlpRuleReceiverArgs',
    'CasbDlpRuleReceiverArgsDict',
    'CasbDlpRuleReceiverTenantArgs',
    'CasbDlpRuleReceiverTenantArgsDict',
    'CasbDlpRuleRedactionProfileArgs',
    'CasbDlpRuleRedactionProfileArgsDict',
    'CasbDlpRuleTagArgs',
    'CasbDlpRuleTagArgsDict',
    'CasbDlpRuleUsersArgs',
    'CasbDlpRuleUsersArgsDict',
    'CasbDlpRuleWatermarkProfileArgs',
    'CasbDlpRuleWatermarkProfileArgsDict',
    'CasbDlpRuleZscalerIncidentReceiverArgs',
    'CasbDlpRuleZscalerIncidentReceiverArgsDict',
    'CasbDlpRulesAuditorNotificationArgs',
    'CasbDlpRulesAuditorNotificationArgsDict',
    'CasbDlpRulesBucketsArgs',
    'CasbDlpRulesBucketsArgsDict',
    'CasbDlpRulesCasbEmailLabelArgs',
    'CasbDlpRulesCasbEmailLabelArgsDict',
    'CasbDlpRulesCasbTombstoneTemplateArgs',
    'CasbDlpRulesCasbTombstoneTemplateArgsDict',
    'CasbDlpRulesCloudAppTenantsArgs',
    'CasbDlpRulesCloudAppTenantsArgsDict',
    'CasbDlpRulesCriteriaDomainProfilesArgs',
    'CasbDlpRulesCriteriaDomainProfilesArgsDict',
    'CasbDlpRulesDepartmentsArgs',
    'CasbDlpRulesDepartmentsArgsDict',
    'CasbDlpRulesDlpEnginesArgs',
    'CasbDlpRulesDlpEnginesArgsDict',
    'CasbDlpRulesEmailRecipientProfilesArgs',
    'CasbDlpRulesEmailRecipientProfilesArgsDict',
    'CasbDlpRulesEntityGroupsArgs',
    'CasbDlpRulesEntityGroupsArgsDict',
    'CasbDlpRulesExcludedDomainProfilesArgs',
    'CasbDlpRulesExcludedDomainProfilesArgsDict',
    'CasbDlpRulesGroupsArgs',
    'CasbDlpRulesGroupsArgsDict',
    'CasbDlpRulesIncludedDomainProfilesArgs',
    'CasbDlpRulesIncludedDomainProfilesArgsDict',
    'CasbDlpRulesLabelsArgs',
    'CasbDlpRulesLabelsArgsDict',
    'CasbDlpRulesObjectTypesArgs',
    'CasbDlpRulesObjectTypesArgsDict',
    'CasbDlpRulesReceiverArgs',
    'CasbDlpRulesReceiverArgsDict',
    'CasbDlpRulesReceiverTenantArgs',
    'CasbDlpRulesReceiverTenantArgsDict',
    'CasbDlpRulesRedactionProfileArgs',
    'CasbDlpRulesRedactionProfileArgsDict',
    'CasbDlpRulesTagArgs',
    'CasbDlpRulesTagArgsDict',
    'CasbDlpRulesUsersArgs',
    'CasbDlpRulesUsersArgsDict',
    'CasbDlpRulesWatermarkProfileArgs',
    'CasbDlpRulesWatermarkProfileArgsDict',
    'CasbDlpRulesZscalerIncidentReceiverArgs',
    'CasbDlpRulesZscalerIncidentReceiverArgsDict',
    'CasbMalwareRuleBucketsArgs',
    'CasbMalwareRuleBucketsArgsDict',
    'CasbMalwareRuleCasbEmailLabelArgs',
    'CasbMalwareRuleCasbEmailLabelArgsDict',
    'CasbMalwareRuleCasbTombstoneTemplateArgs',
    'CasbMalwareRuleCasbTombstoneTemplateArgsDict',
    'CasbMalwareRuleCloudAppTenantIdsArgs',
    'CasbMalwareRuleCloudAppTenantIdsArgsDict',
    'CasbMalwareRuleCloudAppTenantsArgs',
    'CasbMalwareRuleCloudAppTenantsArgsDict',
    'CasbMalwareRuleLabelsArgs',
    'CasbMalwareRuleLabelsArgsDict',
    'CasbMalwareRulesBucketsArgs',
    'CasbMalwareRulesBucketsArgsDict',
    'CasbMalwareRulesCasbEmailLabelArgs',
    'CasbMalwareRulesCasbEmailLabelArgsDict',
    'CasbMalwareRulesCasbTombstoneTemplateArgs',
    'CasbMalwareRulesCasbTombstoneTemplateArgsDict',
    'CasbMalwareRulesCloudAppTenantIdsArgs',
    'CasbMalwareRulesCloudAppTenantIdsArgsDict',
    'CasbMalwareRulesCloudAppTenantsArgs',
    'CasbMalwareRulesCloudAppTenantsArgsDict',
    'CasbMalwareRulesLabelsArgs',
    'CasbMalwareRulesLabelsArgsDict',
    'CloudAppControlRuleCbiProfileArgs',
    'CloudAppControlRuleCbiProfileArgsDict',
    'CloudAppControlRuleCloudAppInstancesArgs',
    'CloudAppControlRuleCloudAppInstancesArgsDict',
    'CloudAppControlRuleCloudAppRiskProfileArgs',
    'CloudAppControlRuleCloudAppRiskProfileArgsDict',
    'CloudAppControlRuleDepartmentsArgs',
    'CloudAppControlRuleDepartmentsArgsDict',
    'CloudAppControlRuleDeviceGroupsArgs',
    'CloudAppControlRuleDeviceGroupsArgsDict',
    'CloudAppControlRuleDevicesArgs',
    'CloudAppControlRuleDevicesArgsDict',
    'CloudAppControlRuleGroupsArgs',
    'CloudAppControlRuleGroupsArgsDict',
    'CloudAppControlRuleLabelsArgs',
    'CloudAppControlRuleLabelsArgsDict',
    'CloudAppControlRuleLocationGroupsArgs',
    'CloudAppControlRuleLocationGroupsArgsDict',
    'CloudAppControlRuleLocationsArgs',
    'CloudAppControlRuleLocationsArgsDict',
    'CloudAppControlRuleTenancyProfileIdsArgs',
    'CloudAppControlRuleTenancyProfileIdsArgsDict',
    'CloudAppControlRuleTimeWindowsArgs',
    'CloudAppControlRuleTimeWindowsArgsDict',
    'CloudAppControlRuleUsersArgs',
    'CloudAppControlRuleUsersArgsDict',
    'CloudApplicationInstanceInstanceIdentifierArgs',
    'CloudApplicationInstanceInstanceIdentifierArgsDict',
    'CloudNSSFeedBucketsArgs',
    'CloudNSSFeedBucketsArgsDict',
    'CloudNSSFeedCasbTenantArgs',
    'CloudNSSFeedCasbTenantArgsDict',
    'CloudNSSFeedDepartmentsArgs',
    'CloudNSSFeedDepartmentsArgsDict',
    'CloudNSSFeedDlpDictionariesArgs',
    'CloudNSSFeedDlpDictionariesArgsDict',
    'CloudNSSFeedDlpEnginesArgs',
    'CloudNSSFeedDlpEnginesArgsDict',
    'CloudNSSFeedExternalCollaboratorsArgs',
    'CloudNSSFeedExternalCollaboratorsArgsDict',
    'CloudNSSFeedExternalOwnersArgs',
    'CloudNSSFeedExternalOwnersArgsDict',
    'CloudNSSFeedInternalCollaboratorsArgs',
    'CloudNSSFeedInternalCollaboratorsArgsDict',
    'CloudNSSFeedItsmObjectTypeArgs',
    'CloudNSSFeedItsmObjectTypeArgsDict',
    'CloudNSSFeedLocationGroupsArgs',
    'CloudNSSFeedLocationGroupsArgsDict',
    'CloudNSSFeedLocationsArgs',
    'CloudNSSFeedLocationsArgsDict',
    'CloudNSSFeedNwServicesArgs',
    'CloudNSSFeedNwServicesArgsDict',
    'CloudNSSFeedRulesArgs',
    'CloudNSSFeedRulesArgsDict',
    'CloudNSSFeedSenderNameArgs',
    'CloudNSSFeedSenderNameArgsDict',
    'CloudNSSFeedUrlCategoriesArgs',
    'CloudNSSFeedUrlCategoriesArgsDict',
    'CloudNSSFeedUsersArgs',
    'CloudNSSFeedUsersArgsDict',
    'CloudNSSFeedVpnCredentialsArgs',
    'CloudNSSFeedVpnCredentialsArgsDict',
    'DLPDictionariesExactDataMatchDetailArgs',
    'DLPDictionariesExactDataMatchDetailArgsDict',
    'DLPDictionariesIdmProfileMatchAccuracyArgs',
    'DLPDictionariesIdmProfileMatchAccuracyArgsDict',
    'DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs',
    'DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict',
    'DLPDictionariesPatternArgs',
    'DLPDictionariesPatternArgsDict',
    'DLPDictionariesPhraseArgs',
    'DLPDictionariesPhraseArgsDict',
    'DLPWebRulesAuditorArgs',
    'DLPWebRulesAuditorArgsDict',
    'DLPWebRulesDepartmentsArgs',
    'DLPWebRulesDepartmentsArgsDict',
    'DLPWebRulesDlpEnginesArgs',
    'DLPWebRulesDlpEnginesArgsDict',
    'DLPWebRulesExcludedDepartmentsArgs',
    'DLPWebRulesExcludedDepartmentsArgsDict',
    'DLPWebRulesExcludedDomainProfilesArgs',
    'DLPWebRulesExcludedDomainProfilesArgsDict',
    'DLPWebRulesExcludedGroupsArgs',
    'DLPWebRulesExcludedGroupsArgsDict',
    'DLPWebRulesExcludedUsersArgs',
    'DLPWebRulesExcludedUsersArgsDict',
    'DLPWebRulesFileTypeCategoriesArgs',
    'DLPWebRulesFileTypeCategoriesArgsDict',
    'DLPWebRulesGroupsArgs',
    'DLPWebRulesGroupsArgsDict',
    'DLPWebRulesIcapServerArgs',
    'DLPWebRulesIcapServerArgsDict',
    'DLPWebRulesIncludedDomainProfilesArgs',
    'DLPWebRulesIncludedDomainProfilesArgsDict',
    'DLPWebRulesLabelsArgs',
    'DLPWebRulesLabelsArgsDict',
    'DLPWebRulesLocationGroupsArgs',
    'DLPWebRulesLocationGroupsArgsDict',
    'DLPWebRulesLocationsArgs',
    'DLPWebRulesLocationsArgsDict',
    'DLPWebRulesNotificationTemplateArgs',
    'DLPWebRulesNotificationTemplateArgsDict',
    'DLPWebRulesReceiverArgs',
    'DLPWebRulesReceiverArgsDict',
    'DLPWebRulesReceiverTenantArgs',
    'DLPWebRulesReceiverTenantArgsDict',
    'DLPWebRulesSourceIpGroupsArgs',
    'DLPWebRulesSourceIpGroupsArgsDict',
    'DLPWebRulesTimeWindowsArgs',
    'DLPWebRulesTimeWindowsArgsDict',
    'DLPWebRulesUrlCategoriesArgs',
    'DLPWebRulesUrlCategoriesArgsDict',
    'DLPWebRulesUsersArgs',
    'DLPWebRulesUsersArgsDict',
    'DLPWebRulesWorkloadGroupArgs',
    'DLPWebRulesWorkloadGroupArgsDict',
    'ExtranetExtranetDnsListArgs',
    'ExtranetExtranetDnsListArgsDict',
    'ExtranetExtranetIpPoolListArgs',
    'ExtranetExtranetIpPoolListArgsDict',
    'FileTypeControlRulesDepartmentsArgs',
    'FileTypeControlRulesDepartmentsArgsDict',
    'FileTypeControlRulesDeviceGroupsArgs',
    'FileTypeControlRulesDeviceGroupsArgsDict',
    'FileTypeControlRulesDevicesArgs',
    'FileTypeControlRulesDevicesArgsDict',
    'FileTypeControlRulesGroupsArgs',
    'FileTypeControlRulesGroupsArgsDict',
    'FileTypeControlRulesLabelsArgs',
    'FileTypeControlRulesLabelsArgsDict',
    'FileTypeControlRulesLocationGroupsArgs',
    'FileTypeControlRulesLocationGroupsArgsDict',
    'FileTypeControlRulesLocationsArgs',
    'FileTypeControlRulesLocationsArgsDict',
    'FileTypeControlRulesTimeWindowsArgs',
    'FileTypeControlRulesTimeWindowsArgsDict',
    'FileTypeControlRulesUsersArgs',
    'FileTypeControlRulesUsersArgsDict',
    'FileTypeControlRulesZpaAppSegmentArgs',
    'FileTypeControlRulesZpaAppSegmentArgsDict',
    'FirewallDNSRuleApplicationGroupsArgs',
    'FirewallDNSRuleApplicationGroupsArgsDict',
    'FirewallDNSRuleDepartmentsArgs',
    'FirewallDNSRuleDepartmentsArgsDict',
    'FirewallDNSRuleDestIpGroupsArgs',
    'FirewallDNSRuleDestIpGroupsArgsDict',
    'FirewallDNSRuleDestIpv6GroupsArgs',
    'FirewallDNSRuleDestIpv6GroupsArgsDict',
    'FirewallDNSRuleDeviceGroupsArgs',
    'FirewallDNSRuleDeviceGroupsArgsDict',
    'FirewallDNSRuleDevicesArgs',
    'FirewallDNSRuleDevicesArgsDict',
    'FirewallDNSRuleDnsGatewayArgs',
    'FirewallDNSRuleDnsGatewayArgsDict',
    'FirewallDNSRuleEdnsEcsObjectArgs',
    'FirewallDNSRuleEdnsEcsObjectArgsDict',
    'FirewallDNSRuleGroupsArgs',
    'FirewallDNSRuleGroupsArgsDict',
    'FirewallDNSRuleLabelsArgs',
    'FirewallDNSRuleLabelsArgsDict',
    'FirewallDNSRuleLocationGroupsArgs',
    'FirewallDNSRuleLocationGroupsArgsDict',
    'FirewallDNSRuleLocationsArgs',
    'FirewallDNSRuleLocationsArgsDict',
    'FirewallDNSRuleSrcIpGroupsArgs',
    'FirewallDNSRuleSrcIpGroupsArgsDict',
    'FirewallDNSRuleSrcIpv6GroupsArgs',
    'FirewallDNSRuleSrcIpv6GroupsArgsDict',
    'FirewallDNSRuleTimeWindowsArgs',
    'FirewallDNSRuleTimeWindowsArgsDict',
    'FirewallDNSRuleUsersArgs',
    'FirewallDNSRuleUsersArgsDict',
    'FirewallDNSRuleZpaIpGroupArgs',
    'FirewallDNSRuleZpaIpGroupArgsDict',
    'FirewallFilteringNetworkServicesDestTcpPortArgs',
    'FirewallFilteringNetworkServicesDestTcpPortArgsDict',
    'FirewallFilteringNetworkServicesDestUdpPortArgs',
    'FirewallFilteringNetworkServicesDestUdpPortArgsDict',
    'FirewallFilteringNetworkServicesSrcTcpPortArgs',
    'FirewallFilteringNetworkServicesSrcTcpPortArgsDict',
    'FirewallFilteringNetworkServicesSrcUdpPortArgs',
    'FirewallFilteringNetworkServicesSrcUdpPortArgsDict',
    'FirewallFilteringRuleAppServiceGroupsArgs',
    'FirewallFilteringRuleAppServiceGroupsArgsDict',
    'FirewallFilteringRuleAppServicesArgs',
    'FirewallFilteringRuleAppServicesArgsDict',
    'FirewallFilteringRuleDepartmentsArgs',
    'FirewallFilteringRuleDepartmentsArgsDict',
    'FirewallFilteringRuleDestIpGroupsArgs',
    'FirewallFilteringRuleDestIpGroupsArgsDict',
    'FirewallFilteringRuleDeviceGroupsArgs',
    'FirewallFilteringRuleDeviceGroupsArgsDict',
    'FirewallFilteringRuleDevicesArgs',
    'FirewallFilteringRuleDevicesArgsDict',
    'FirewallFilteringRuleGroupsArgs',
    'FirewallFilteringRuleGroupsArgsDict',
    'FirewallFilteringRuleLabelsArgs',
    'FirewallFilteringRuleLabelsArgsDict',
    'FirewallFilteringRuleLocationGroupsArgs',
    'FirewallFilteringRuleLocationGroupsArgsDict',
    'FirewallFilteringRuleLocationsArgs',
    'FirewallFilteringRuleLocationsArgsDict',
    'FirewallFilteringRuleNwApplicationGroupsArgs',
    'FirewallFilteringRuleNwApplicationGroupsArgsDict',
    'FirewallFilteringRuleNwServiceGroupsArgs',
    'FirewallFilteringRuleNwServiceGroupsArgsDict',
    'FirewallFilteringRuleNwServicesArgs',
    'FirewallFilteringRuleNwServicesArgsDict',
    'FirewallFilteringRuleSrcIpGroupsArgs',
    'FirewallFilteringRuleSrcIpGroupsArgsDict',
    'FirewallFilteringRuleTimeWindowsArgs',
    'FirewallFilteringRuleTimeWindowsArgsDict',
    'FirewallFilteringRuleUsersArgs',
    'FirewallFilteringRuleUsersArgsDict',
    'FirewallFilteringRuleWorkloadGroupArgs',
    'FirewallFilteringRuleWorkloadGroupArgsDict',
    'FirewallFilteringRuleZpaAppSegmentArgs',
    'FirewallFilteringRuleZpaAppSegmentArgsDict',
    'FirewallFilteringServiceGroupsServiceArgs',
    'FirewallFilteringServiceGroupsServiceArgsDict',
    'ForwardingControlProxiesCertArgs',
    'ForwardingControlProxiesCertArgsDict',
    'ForwardingControlRuleAppServiceGroupsArgs',
    'ForwardingControlRuleAppServiceGroupsArgsDict',
    'ForwardingControlRuleDepartmentsArgs',
    'ForwardingControlRuleDepartmentsArgsDict',
    'ForwardingControlRuleDestIpGroupsArgs',
    'ForwardingControlRuleDestIpGroupsArgsDict',
    'ForwardingControlRuleDestIpv6GroupsArgs',
    'ForwardingControlRuleDestIpv6GroupsArgsDict',
    'ForwardingControlRuleDeviceGroupsArgs',
    'ForwardingControlRuleDeviceGroupsArgsDict',
    'ForwardingControlRuleEcGroupsArgs',
    'ForwardingControlRuleEcGroupsArgsDict',
    'ForwardingControlRuleGroupsArgs',
    'ForwardingControlRuleGroupsArgsDict',
    'ForwardingControlRuleLabelsArgs',
    'ForwardingControlRuleLabelsArgsDict',
    'ForwardingControlRuleLocationGroupsArgs',
    'ForwardingControlRuleLocationGroupsArgsDict',
    'ForwardingControlRuleLocationsArgs',
    'ForwardingControlRuleLocationsArgsDict',
    'ForwardingControlRuleNwApplicationGroupsArgs',
    'ForwardingControlRuleNwApplicationGroupsArgsDict',
    'ForwardingControlRuleNwServiceGroupsArgs',
    'ForwardingControlRuleNwServiceGroupsArgsDict',
    'ForwardingControlRuleNwServicesArgs',
    'ForwardingControlRuleNwServicesArgsDict',
    'ForwardingControlRuleProxyGatewayArgs',
    'ForwardingControlRuleProxyGatewayArgsDict',
    'ForwardingControlRuleSrcIpGroupsArgs',
    'ForwardingControlRuleSrcIpGroupsArgsDict',
    'ForwardingControlRuleSrcIpv6GroupsArgs',
    'ForwardingControlRuleSrcIpv6GroupsArgsDict',
    'ForwardingControlRuleUsersArgs',
    'ForwardingControlRuleUsersArgsDict',
    'ForwardingControlRuleZpaAppSegmentArgs',
    'ForwardingControlRuleZpaAppSegmentArgsDict',
    'ForwardingControlRuleZpaApplicationSegmentGroupsArgs',
    'ForwardingControlRuleZpaApplicationSegmentGroupsArgsDict',
    'ForwardingControlRuleZpaApplicationSegmentsArgs',
    'ForwardingControlRuleZpaApplicationSegmentsArgsDict',
    'ForwardingControlRuleZpaGatewayArgs',
    'ForwardingControlRuleZpaGatewayArgsDict',
    'ForwardingControlZPAGatewayZpaAppSegmentArgs',
    'ForwardingControlZPAGatewayZpaAppSegmentArgsDict',
    'ForwardingControlZPAGatewayZpaServerGroupArgs',
    'ForwardingControlZPAGatewayZpaServerGroupArgsDict',
    'IPSFirewallRuleDepartmentsArgs',
    'IPSFirewallRuleDepartmentsArgsDict',
    'IPSFirewallRuleDestIpGroupsArgs',
    'IPSFirewallRuleDestIpGroupsArgsDict',
    'IPSFirewallRuleDestIpv6GroupsArgs',
    'IPSFirewallRuleDestIpv6GroupsArgsDict',
    'IPSFirewallRuleDeviceGroupsArgs',
    'IPSFirewallRuleDeviceGroupsArgsDict',
    'IPSFirewallRuleDevicesArgs',
    'IPSFirewallRuleDevicesArgsDict',
    'IPSFirewallRuleGroupsArgs',
    'IPSFirewallRuleGroupsArgsDict',
    'IPSFirewallRuleLabelsArgs',
    'IPSFirewallRuleLabelsArgsDict',
    'IPSFirewallRuleLocationGroupsArgs',
    'IPSFirewallRuleLocationGroupsArgsDict',
    'IPSFirewallRuleLocationsArgs',
    'IPSFirewallRuleLocationsArgsDict',
    'IPSFirewallRuleNwServiceGroupsArgs',
    'IPSFirewallRuleNwServiceGroupsArgsDict',
    'IPSFirewallRuleNwServicesArgs',
    'IPSFirewallRuleNwServicesArgsDict',
    'IPSFirewallRuleSrcIpGroupsArgs',
    'IPSFirewallRuleSrcIpGroupsArgsDict',
    'IPSFirewallRuleSrcIpv6GroupsArgs',
    'IPSFirewallRuleSrcIpv6GroupsArgsDict',
    'IPSFirewallRuleThreatCategoriesArgs',
    'IPSFirewallRuleThreatCategoriesArgsDict',
    'IPSFirewallRuleTimeWindowsArgs',
    'IPSFirewallRuleTimeWindowsArgsDict',
    'IPSFirewallRuleUsersArgs',
    'IPSFirewallRuleUsersArgsDict',
    'IPSFirewallRuleZpaAppSegmentArgs',
    'IPSFirewallRuleZpaAppSegmentArgsDict',
    'LocationManagementExtranetArgs',
    'LocationManagementExtranetArgsDict',
    'LocationManagementExtranetDnArgs',
    'LocationManagementExtranetDnArgsDict',
    'LocationManagementExtranetIpPoolArgs',
    'LocationManagementExtranetIpPoolArgsDict',
    'LocationManagementStaticLocationGroupsArgs',
    'LocationManagementStaticLocationGroupsArgsDict',
    'LocationManagementVpnCredentialArgs',
    'LocationManagementVpnCredentialArgsDict',
    'NatControlRulesDepartmentsArgs',
    'NatControlRulesDepartmentsArgsDict',
    'NatControlRulesDestIpGroupsArgs',
    'NatControlRulesDestIpGroupsArgsDict',
    'NatControlRulesDestIpv6GroupsArgs',
    'NatControlRulesDestIpv6GroupsArgsDict',
    'NatControlRulesDeviceGroupsArgs',
    'NatControlRulesDeviceGroupsArgsDict',
    'NatControlRulesDevicesArgs',
    'NatControlRulesDevicesArgsDict',
    'NatControlRulesGroupsArgs',
    'NatControlRulesGroupsArgsDict',
    'NatControlRulesLabelsArgs',
    'NatControlRulesLabelsArgsDict',
    'NatControlRulesLocationGroupsArgs',
    'NatControlRulesLocationGroupsArgsDict',
    'NatControlRulesLocationsArgs',
    'NatControlRulesLocationsArgsDict',
    'NatControlRulesNwServiceGroupsArgs',
    'NatControlRulesNwServiceGroupsArgsDict',
    'NatControlRulesNwServicesArgs',
    'NatControlRulesNwServicesArgsDict',
    'NatControlRulesSrcIpGroupsArgs',
    'NatControlRulesSrcIpGroupsArgsDict',
    'NatControlRulesSrcIpv6GroupsArgs',
    'NatControlRulesSrcIpv6GroupsArgsDict',
    'NatControlRulesTimeWindowsArgs',
    'NatControlRulesTimeWindowsArgsDict',
    'NatControlRulesUsersArgs',
    'NatControlRulesUsersArgsDict',
    'RiskProfilesCustomTagsArgs',
    'RiskProfilesCustomTagsArgsDict',
    'SSLInspectionRulesActionArgs',
    'SSLInspectionRulesActionArgsDict',
    'SSLInspectionRulesActionDecryptSubActionArgs',
    'SSLInspectionRulesActionDecryptSubActionArgsDict',
    'SSLInspectionRulesActionDoNotDecryptSubActionArgs',
    'SSLInspectionRulesActionDoNotDecryptSubActionArgsDict',
    'SSLInspectionRulesActionSslInterceptionCertArgs',
    'SSLInspectionRulesActionSslInterceptionCertArgsDict',
    'SSLInspectionRulesDepartmentsArgs',
    'SSLInspectionRulesDepartmentsArgsDict',
    'SSLInspectionRulesDestIpGroupsArgs',
    'SSLInspectionRulesDestIpGroupsArgsDict',
    'SSLInspectionRulesDeviceGroupsArgs',
    'SSLInspectionRulesDeviceGroupsArgsDict',
    'SSLInspectionRulesDevicesArgs',
    'SSLInspectionRulesDevicesArgsDict',
    'SSLInspectionRulesGroupsArgs',
    'SSLInspectionRulesGroupsArgsDict',
    'SSLInspectionRulesLabelsArgs',
    'SSLInspectionRulesLabelsArgsDict',
    'SSLInspectionRulesLocationGroupsArgs',
    'SSLInspectionRulesLocationGroupsArgsDict',
    'SSLInspectionRulesLocationsArgs',
    'SSLInspectionRulesLocationsArgsDict',
    'SSLInspectionRulesProxyGatewaysArgs',
    'SSLInspectionRulesProxyGatewaysArgsDict',
    'SSLInspectionRulesSourceIpGroupsArgs',
    'SSLInspectionRulesSourceIpGroupsArgsDict',
    'SSLInspectionRulesTimeWindowsArgs',
    'SSLInspectionRulesTimeWindowsArgsDict',
    'SSLInspectionRulesUsersArgs',
    'SSLInspectionRulesUsersArgsDict',
    'SSLInspectionRulesWorkloadGroupArgs',
    'SSLInspectionRulesWorkloadGroupArgsDict',
    'SSLInspectionRulesZpaAppSegmentArgs',
    'SSLInspectionRulesZpaAppSegmentArgsDict',
    'SandboxRulesDepartmentsArgs',
    'SandboxRulesDepartmentsArgsDict',
    'SandboxRulesGroupsArgs',
    'SandboxRulesGroupsArgsDict',
    'SandboxRulesLabelsArgs',
    'SandboxRulesLabelsArgsDict',
    'SandboxRulesLocationGroupsArgs',
    'SandboxRulesLocationGroupsArgsDict',
    'SandboxRulesLocationsArgs',
    'SandboxRulesLocationsArgsDict',
    'SandboxRulesUsersArgs',
    'SandboxRulesUsersArgsDict',
    'SandboxRulesZpaAppSegmentArgs',
    'SandboxRulesZpaAppSegmentArgsDict',
    'SubCloudDcArgs',
    'SubCloudDcArgsDict',
    'SubCloudExclusionArgs',
    'SubCloudExclusionArgsDict',
    'SubCloudExclusionDatacenterArgs',
    'SubCloudExclusionDatacenterArgsDict',
    'TrafficCaptureRulesAppServiceGroupsArgs',
    'TrafficCaptureRulesAppServiceGroupsArgsDict',
    'TrafficCaptureRulesDepartmentsArgs',
    'TrafficCaptureRulesDepartmentsArgsDict',
    'TrafficCaptureRulesDestIpGroupsArgs',
    'TrafficCaptureRulesDestIpGroupsArgsDict',
    'TrafficCaptureRulesDeviceGroupsArgs',
    'TrafficCaptureRulesDeviceGroupsArgsDict',
    'TrafficCaptureRulesDevicesArgs',
    'TrafficCaptureRulesDevicesArgsDict',
    'TrafficCaptureRulesGroupsArgs',
    'TrafficCaptureRulesGroupsArgsDict',
    'TrafficCaptureRulesLabelsArgs',
    'TrafficCaptureRulesLabelsArgsDict',
    'TrafficCaptureRulesLocationGroupsArgs',
    'TrafficCaptureRulesLocationGroupsArgsDict',
    'TrafficCaptureRulesLocationsArgs',
    'TrafficCaptureRulesLocationsArgsDict',
    'TrafficCaptureRulesNwApplicationGroupsArgs',
    'TrafficCaptureRulesNwApplicationGroupsArgsDict',
    'TrafficCaptureRulesNwServiceGroupsArgs',
    'TrafficCaptureRulesNwServiceGroupsArgsDict',
    'TrafficCaptureRulesNwServicesArgs',
    'TrafficCaptureRulesNwServicesArgsDict',
    'TrafficCaptureRulesSrcIpGroupsArgs',
    'TrafficCaptureRulesSrcIpGroupsArgsDict',
    'TrafficCaptureRulesTimeWindowsArgs',
    'TrafficCaptureRulesTimeWindowsArgsDict',
    'TrafficCaptureRulesUsersArgs',
    'TrafficCaptureRulesUsersArgsDict',
    'TrafficCaptureRulesWorkloadGroupArgs',
    'TrafficCaptureRulesWorkloadGroupArgsDict',
    'TrafficForwardingGRETunnelPrimaryDestVipArgs',
    'TrafficForwardingGRETunnelPrimaryDestVipArgsDict',
    'TrafficForwardingGRETunnelSecondaryDestVipArgs',
    'TrafficForwardingGRETunnelSecondaryDestVipArgsDict',
    'URLCategoriesPredefinedUrlKeywordCountArgs',
    'URLCategoriesPredefinedUrlKeywordCountArgsDict',
    'URLCategoriesScopeArgs',
    'URLCategoriesScopeArgsDict',
    'URLCategoriesScopeScopeEntitiesArgs',
    'URLCategoriesScopeScopeEntitiesArgsDict',
    'URLCategoriesScopeScopeGroupMemberEntitiesArgs',
    'URLCategoriesScopeScopeGroupMemberEntitiesArgsDict',
    'URLCategoriesUrlKeywordCountsArgs',
    'URLCategoriesUrlKeywordCountsArgsDict',
    'URLFilteringRulesCbiProfileArgs',
    'URLFilteringRulesCbiProfileArgsDict',
    'URLFilteringRulesDepartmentsArgs',
    'URLFilteringRulesDepartmentsArgsDict',
    'URLFilteringRulesDeviceGroupsArgs',
    'URLFilteringRulesDeviceGroupsArgsDict',
    'URLFilteringRulesDevicesArgs',
    'URLFilteringRulesDevicesArgsDict',
    'URLFilteringRulesGroupsArgs',
    'URLFilteringRulesGroupsArgsDict',
    'URLFilteringRulesLabelsArgs',
    'URLFilteringRulesLabelsArgsDict',
    'URLFilteringRulesLocationGroupsArgs',
    'URLFilteringRulesLocationGroupsArgsDict',
    'URLFilteringRulesLocationsArgs',
    'URLFilteringRulesLocationsArgsDict',
    'URLFilteringRulesOverrideGroupsArgs',
    'URLFilteringRulesOverrideGroupsArgsDict',
    'URLFilteringRulesOverrideUsersArgs',
    'URLFilteringRulesOverrideUsersArgsDict',
    'URLFilteringRulesSourceIpGroupsArgs',
    'URLFilteringRulesSourceIpGroupsArgsDict',
    'URLFilteringRulesTimeWindowsArgs',
    'URLFilteringRulesTimeWindowsArgsDict',
    'URLFilteringRulesUsersArgs',
    'URLFilteringRulesUsersArgsDict',
    'URLFilteringRulesWorkloadGroupArgs',
    'URLFilteringRulesWorkloadGroupArgsDict',
    'UserManagementDepartmentArgs',
    'UserManagementDepartmentArgsDict',
    'UserManagementGroupsArgs',
    'UserManagementGroupsArgsDict',
    'VirtualServiceEdgeClusterVirtualZenNodesArgs',
    'VirtualServiceEdgeClusterVirtualZenNodesArgsDict',
    'WorkloadGroupsExpressionJsonArgs',
    'WorkloadGroupsExpressionJsonArgsDict',
    'WorkloadGroupsExpressionJsonExpressionContainerArgs',
    'WorkloadGroupsExpressionJsonExpressionContainerArgsDict',
    'WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgs',
    'WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgsDict',
    'WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgs',
    'WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaCityArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict',
    'GetLocationGroupsDynamicLocationGroupCriteriaNameArgs',
    'GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict',
    'GetSandboxReportExploitArgs',
    'GetSandboxReportExploitArgsDict',
    'GetSandboxReportNetworkingArgs',
    'GetSandboxReportNetworkingArgsDict',
    'GetSandboxReportPersistenceArgs',
    'GetSandboxReportPersistenceArgsDict',
    'GetSandboxReportSecurityBypassArgs',
    'GetSandboxReportSecurityBypassArgsDict',
    'GetSandboxReportSpywareArgs',
    'GetSandboxReportSpywareArgsDict',
    'GetSandboxReportStealthArgs',
    'GetSandboxReportStealthArgsDict',
]

MYPY = False

if not MYPY:
    class AdminUsersAdminScopeEntitiesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    AdminUsersAdminScopeEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminUsersAdminScopeEntitiesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AdminUsersRoleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    AdminUsersRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminUsersRoleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BandwidthControlRuleBandwidthClassesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Number) Identifier that uniquely identifies an entity
        """
elif False:
    BandwidthControlRuleBandwidthClassesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthControlRuleBandwidthClassesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Number) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Number) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BandwidthControlRuleLabelsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Number) Identifier that uniquely identifies an entity
        """
elif False:
    BandwidthControlRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthControlRuleLabelsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Number) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Number) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BandwidthControlRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Number) Identifier that uniquely identifies an entity
        """
elif False:
    BandwidthControlRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthControlRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Number) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Number) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BandwidthControlRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Number) Identifier that uniquely identifies an entity
        """
elif False:
    BandwidthControlRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthControlRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Number) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Number) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BandwidthControlRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Number) Identifier that uniquely identifies an entity
        """
elif False:
    BandwidthControlRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthControlRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Number) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Number) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BrowserControlPolicySmartIsolationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        A unique identifier for an entity.
        """
elif False:
    BrowserControlPolicySmartIsolationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserControlPolicySmartIsolationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: A unique identifier for an entity.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        A unique identifier for an entity.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BrowserControlPolicySmartIsolationProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The universally unique identifier (UUID) for the browser isolation profile
        """
elif False:
    BrowserControlPolicySmartIsolationProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserControlPolicySmartIsolationProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The universally unique identifier (UUID) for the browser isolation profile
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The universally unique identifier (UUID) for the browser isolation profile
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BrowserControlPolicySmartIsolationUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        A unique identifier for an entity.
        """
elif False:
    BrowserControlPolicySmartIsolationUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserControlPolicySmartIsolationUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: A unique identifier for an entity.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        A unique identifier for an entity.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BrowserControlSettingsSmartIsolationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        A unique identifier for an entity.
        """
elif False:
    BrowserControlSettingsSmartIsolationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserControlSettingsSmartIsolationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: A unique identifier for an entity.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        A unique identifier for an entity.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class BrowserControlSettingsSmartIsolationProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The universally unique identifier (UUID) for the browser isolation profile
        """
elif False:
    BrowserControlSettingsSmartIsolationProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserControlSettingsSmartIsolationProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The universally unique identifier (UUID) for the browser isolation profile
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The universally unique identifier (UUID) for the browser isolation profile
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BrowserControlSettingsSmartIsolationUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        A unique identifier for an entity.
        """
elif False:
    BrowserControlSettingsSmartIsolationUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserControlSettingsSmartIsolationUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: A unique identifier for an entity.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        A unique identifier for an entity.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleAuditorNotificationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleAuditorNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleAuditorNotificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleBucketsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleBucketsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleCasbEmailLabelArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleCasbEmailLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleCasbEmailLabelArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleCasbTombstoneTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleCasbTombstoneTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleCasbTombstoneTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleCloudAppTenantsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleCloudAppTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleCloudAppTenantsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleCriteriaDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleCriteriaDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleCriteriaDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleDlpEnginesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleDlpEnginesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleDlpEnginesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleEmailRecipientProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleEmailRecipientProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleEmailRecipientProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleEntityGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleEntityGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleEntityGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleExcludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleExcludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleExcludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleIncludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleIncludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleIncludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleObjectTypesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleObjectTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleObjectTypesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleReceiverArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for the receiver
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the receiver
        """
        tenant: NotRequired[pulumi.Input['CasbDlpRuleReceiverTenantArgsDict']]
        """
        Tenant information for the receiver
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the receiver
        """
elif False:
    CasbDlpRuleReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleReceiverArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant: Optional[pulumi.Input['CasbDlpRuleReceiverTenantArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the receiver
        :param pulumi.Input[_builtins.str] name: Name of the receiver
        :param pulumi.Input['CasbDlpRuleReceiverTenantArgs'] tenant: Tenant information for the receiver
        :param pulumi.Input[_builtins.str] type: Type of the receiver
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for the receiver
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the receiver
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input['CasbDlpRuleReceiverTenantArgs']]:
        """
        Tenant information for the receiver
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input['CasbDlpRuleReceiverTenantArgs']]):
        pulumi.set(self, "tenant", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the receiver
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CasbDlpRuleReceiverTenantArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the tenant
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the tenant
        """
elif False:
    CasbDlpRuleReceiverTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleReceiverTenantArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the tenant
        :param pulumi.Input[_builtins.str] name: Name of the tenant
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the tenant
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the tenant
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CasbDlpRuleRedactionProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleRedactionProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleRedactionProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleTagArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleTagArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRuleWatermarkProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleWatermarkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleWatermarkProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRuleZscalerIncidentReceiverArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRuleZscalerIncidentReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRuleZscalerIncidentReceiverArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesAuditorNotificationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesAuditorNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesAuditorNotificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesBucketsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesBucketsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesCasbEmailLabelArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesCasbEmailLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesCasbEmailLabelArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesCasbTombstoneTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesCasbTombstoneTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesCasbTombstoneTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesCloudAppTenantsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesCloudAppTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesCloudAppTenantsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesCriteriaDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesCriteriaDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesCriteriaDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesDlpEnginesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesDlpEnginesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesDlpEnginesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesEmailRecipientProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesEmailRecipientProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesEmailRecipientProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesEntityGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesEntityGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesEntityGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesExcludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesExcludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesExcludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesIncludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesIncludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesIncludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesObjectTypesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesObjectTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesObjectTypesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesReceiverArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for the receiver
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the receiver
        """
        tenant: NotRequired[pulumi.Input['CasbDlpRulesReceiverTenantArgsDict']]
        """
        Tenant information for the receiver
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the receiver
        """
elif False:
    CasbDlpRulesReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesReceiverArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant: Optional[pulumi.Input['CasbDlpRulesReceiverTenantArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the receiver
        :param pulumi.Input[_builtins.str] name: Name of the receiver
        :param pulumi.Input['CasbDlpRulesReceiverTenantArgs'] tenant: Tenant information for the receiver
        :param pulumi.Input[_builtins.str] type: Type of the receiver
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for the receiver
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the receiver
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input['CasbDlpRulesReceiverTenantArgs']]:
        """
        Tenant information for the receiver
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input['CasbDlpRulesReceiverTenantArgs']]):
        pulumi.set(self, "tenant", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the receiver
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CasbDlpRulesReceiverTenantArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the tenant
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the tenant
        """
elif False:
    CasbDlpRulesReceiverTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesReceiverTenantArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the tenant
        :param pulumi.Input[_builtins.str] name: Name of the tenant
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the tenant
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the tenant
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CasbDlpRulesRedactionProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesRedactionProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesRedactionProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesTagArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesTagArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbDlpRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbDlpRulesWatermarkProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesWatermarkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesWatermarkProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbDlpRulesZscalerIncidentReceiverArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbDlpRulesZscalerIncidentReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbDlpRulesZscalerIncidentReceiverArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRuleBucketsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbMalwareRuleBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRuleBucketsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbMalwareRuleCasbEmailLabelArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRuleCasbEmailLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRuleCasbEmailLabelArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRuleCasbTombstoneTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRuleCasbTombstoneTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRuleCasbTombstoneTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRuleCloudAppTenantIdsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRuleCloudAppTenantIdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRuleCloudAppTenantIdsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRuleCloudAppTenantsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRuleCloudAppTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRuleCloudAppTenantsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRulesBucketsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CasbMalwareRulesBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRulesBucketsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CasbMalwareRulesCasbEmailLabelArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRulesCasbEmailLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRulesCasbEmailLabelArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRulesCasbTombstoneTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRulesCasbTombstoneTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRulesCasbTombstoneTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRulesCloudAppTenantIdsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRulesCloudAppTenantIdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRulesCloudAppTenantIdsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRulesCloudAppTenantsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRulesCloudAppTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRulesCloudAppTenantsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CasbMalwareRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CasbMalwareRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CasbMalwareRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudAppControlRuleCbiProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The browser isolation profile URL
        """
elif False:
    CloudAppControlRuleCbiProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleCbiProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The browser isolation profile URL
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The browser isolation profile URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class CloudAppControlRuleCloudAppInstancesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleCloudAppInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleCloudAppInstancesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleCloudAppRiskProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CloudAppControlRuleCloudAppRiskProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleCloudAppRiskProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudAppControlRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleLabelsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleLabelsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleTenancyProfileIdsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleTenancyProfileIdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleTenancyProfileIdsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudAppControlRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudAppControlRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAppControlRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudApplicationInstanceInstanceIdentifierArgsDict(TypedDict):
        identifier_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the cloud application instance.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Unique identifier for the cloud application instance.
        """
        instance_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifying string for the instance.
        """
        instance_identifier_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifying string for the instance.
        """
elif False:
    CloudApplicationInstanceInstanceIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudApplicationInstanceInstanceIdentifierArgs:
    def __init__(__self__, *,
                 identifier_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_identifier_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identifier_type: Type of the cloud application instance.
        :param pulumi.Input[_builtins.int] instance_id: Unique identifier for the cloud application instance.
        :param pulumi.Input[_builtins.str] instance_identifier: Unique identifying string for the instance.
        :param pulumi.Input[_builtins.str] instance_identifier_name: Unique identifying string for the instance.
        """
        if identifier_type is not None:
            pulumi.set(__self__, "identifier_type", identifier_type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_identifier is not None:
            pulumi.set(__self__, "instance_identifier", instance_identifier)
        if instance_identifier_name is not None:
            pulumi.set(__self__, "instance_identifier_name", instance_identifier_name)

    @_builtins.property
    @pulumi.getter(name="identifierType")
    def identifier_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the cloud application instance.
        """
        return pulumi.get(self, "identifier_type")

    @identifier_type.setter
    def identifier_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identifier_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Unique identifier for the cloud application instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceIdentifier")
    def instance_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifying string for the instance.
        """
        return pulumi.get(self, "instance_identifier")

    @instance_identifier.setter
    def instance_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_identifier", value)

    @_builtins.property
    @pulumi.getter(name="instanceIdentifierName")
    def instance_identifier_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifying string for the instance.
        """
        return pulumi.get(self, "instance_identifier_name")

    @instance_identifier_name.setter
    def instance_identifier_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_identifier_name", value)


if not MYPY:
    class CloudNSSFeedBucketsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedBucketsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedCasbTenantArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedCasbTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedCasbTenantArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedDlpDictionariesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedDlpDictionariesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedDlpDictionariesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedDlpEnginesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedDlpEnginesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedDlpEnginesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedExternalCollaboratorsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedExternalCollaboratorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedExternalCollaboratorsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedExternalOwnersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedExternalOwnersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedExternalOwnersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedInternalCollaboratorsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedInternalCollaboratorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedInternalCollaboratorsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedItsmObjectTypeArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedItsmObjectTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedItsmObjectTypeArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedRulesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedRulesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedSenderNameArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedSenderNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedSenderNameArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedUrlCategoriesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedUrlCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedUrlCategoriesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class CloudNSSFeedVpnCredentialsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    CloudNSSFeedVpnCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudNSSFeedVpnCredentialsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPDictionariesExactDataMatchDetailArgsDict(TypedDict):
        dictionary_edm_mapping_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique identifier for the EDM mapping
        """
        primary_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The EDM template's primary field.
        """
        schema_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique identifier for the EDM template (or schema).
        """
        secondary_field_match_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EDM secondary field to match on.
        """
        secondary_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The EDM template's secondary fields.
        """
elif False:
    DLPDictionariesExactDataMatchDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesExactDataMatchDetailArgs:
    def __init__(__self__, *,
                 dictionary_edm_mapping_id: Optional[pulumi.Input[_builtins.int]] = None,
                 primary_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 schema_id: Optional[pulumi.Input[_builtins.int]] = None,
                 secondary_field_match_on: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.int] dictionary_edm_mapping_id: The unique identifier for the EDM mapping
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] primary_fields: The EDM template's primary field.
        :param pulumi.Input[_builtins.int] schema_id: The unique identifier for the EDM template (or schema).
        :param pulumi.Input[_builtins.str] secondary_field_match_on: The EDM secondary field to match on.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] secondary_fields: The EDM template's secondary fields.
        """
        if dictionary_edm_mapping_id is not None:
            pulumi.set(__self__, "dictionary_edm_mapping_id", dictionary_edm_mapping_id)
        if primary_fields is not None:
            pulumi.set(__self__, "primary_fields", primary_fields)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if secondary_field_match_on is not None:
            pulumi.set(__self__, "secondary_field_match_on", secondary_field_match_on)
        if secondary_fields is not None:
            pulumi.set(__self__, "secondary_fields", secondary_fields)

    @_builtins.property
    @pulumi.getter(name="dictionaryEdmMappingId")
    def dictionary_edm_mapping_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique identifier for the EDM mapping
        """
        return pulumi.get(self, "dictionary_edm_mapping_id")

    @dictionary_edm_mapping_id.setter
    def dictionary_edm_mapping_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dictionary_edm_mapping_id", value)

    @_builtins.property
    @pulumi.getter(name="primaryFields")
    def primary_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The EDM template's primary field.
        """
        return pulumi.get(self, "primary_fields")

    @primary_fields.setter
    def primary_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "primary_fields", value)

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique identifier for the EDM template (or schema).
        """
        return pulumi.get(self, "schema_id")

    @schema_id.setter
    def schema_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "schema_id", value)

    @_builtins.property
    @pulumi.getter(name="secondaryFieldMatchOn")
    def secondary_field_match_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EDM secondary field to match on.
        """
        return pulumi.get(self, "secondary_field_match_on")

    @secondary_field_match_on.setter
    def secondary_field_match_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_field_match_on", value)

    @_builtins.property
    @pulumi.getter(name="secondaryFields")
    def secondary_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The EDM template's secondary fields.
        """
        return pulumi.get(self, "secondary_fields")

    @secondary_fields.setter
    def secondary_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "secondary_fields", value)


if not MYPY:
    class DLPDictionariesIdmProfileMatchAccuracyArgsDict(TypedDict):
        adp_idm_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict']]]]
        """
        The action applied to a DLP dictionary using patterns
        """
        match_accuracy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IDM template match accuracy.
        """
elif False:
    DLPDictionariesIdmProfileMatchAccuracyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesIdmProfileMatchAccuracyArgs:
    def __init__(__self__, *,
                 adp_idm_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]]] = None,
                 match_accuracy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]] adp_idm_profiles: The action applied to a DLP dictionary using patterns
        :param pulumi.Input[_builtins.str] match_accuracy: The IDM template match accuracy.
        """
        if adp_idm_profiles is not None:
            pulumi.set(__self__, "adp_idm_profiles", adp_idm_profiles)
        if match_accuracy is not None:
            pulumi.set(__self__, "match_accuracy", match_accuracy)

    @_builtins.property
    @pulumi.getter(name="adpIdmProfiles")
    def adp_idm_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]]]:
        """
        The action applied to a DLP dictionary using patterns
        """
        return pulumi.get(self, "adp_idm_profiles")

    @adp_idm_profiles.setter
    def adp_idm_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs']]]]):
        pulumi.set(self, "adp_idm_profiles", value)

    @_builtins.property
    @pulumi.getter(name="matchAccuracy")
    def match_accuracy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IDM template match accuracy.
        """
        return pulumi.get(self, "match_accuracy")

    @match_accuracy.setter
    def match_accuracy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_accuracy", value)


if not MYPY:
    class DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict(TypedDict):
        extensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extensions map
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Identifier that uniquely identifies an entity
        """
elif False:
    DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesIdmProfileMatchAccuracyAdpIdmProfileArgs:
    def __init__(__self__, *,
                 extensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extensions: Extensions map
        :param pulumi.Input[_builtins.int] id: Identifier that uniquely identifies an entity
        """
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extensions map
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extensions", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPDictionariesPatternArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action applied to a DLP dictionary using patterns
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        DLP dictionary pattern
        """
elif False:
    DLPDictionariesPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesPatternArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action applied to a DLP dictionary using patterns
        :param pulumi.Input[_builtins.str] pattern: DLP dictionary pattern
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action applied to a DLP dictionary using patterns
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DLP dictionary pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class DLPDictionariesPhraseArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        phrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        DLP dictionary phrase (0-128 characters)
        """
elif False:
    DLPDictionariesPhraseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPDictionariesPhraseArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 phrase: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] phrase: DLP dictionary phrase (0-128 characters)
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if phrase is not None:
            pulumi.set(__self__, "phrase", phrase)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def phrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DLP dictionary phrase (0-128 characters)
        """
        return pulumi.get(self, "phrase")

    @phrase.setter
    def phrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phrase", value)


if not MYPY:
    class DLPWebRulesAuditorArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DLPWebRulesAuditorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesAuditorArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesDlpEnginesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesDlpEnginesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesDlpEnginesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesExcludedDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesExcludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesExcludedGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesExcludedUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesExcludedUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesExcludedUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesFileTypeCategoriesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesFileTypeCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesFileTypeCategoriesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesIcapServerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DLPWebRulesIcapServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesIcapServerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesIncludedDomainProfilesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesIncludedDomainProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesIncludedDomainProfilesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DLPWebRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesNotificationTemplateArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DLPWebRulesNotificationTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesNotificationTemplateArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DLPWebRulesReceiverArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for the receiver
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the receiver
        """
        tenant: NotRequired[pulumi.Input['DLPWebRulesReceiverTenantArgsDict']]
        """
        Tenant information for the receiver
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the receiver
        """
elif False:
    DLPWebRulesReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesReceiverArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant: Optional[pulumi.Input['DLPWebRulesReceiverTenantArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the receiver
        :param pulumi.Input[_builtins.str] name: Name of the receiver
        :param pulumi.Input['DLPWebRulesReceiverTenantArgs'] tenant: Tenant information for the receiver
        :param pulumi.Input[_builtins.str] type: Type of the receiver
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for the receiver
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the receiver
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input['DLPWebRulesReceiverTenantArgs']]:
        """
        Tenant information for the receiver
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input['DLPWebRulesReceiverTenantArgs']]):
        pulumi.set(self, "tenant", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the receiver
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DLPWebRulesReceiverTenantArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the tenant
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the tenant
        """
elif False:
    DLPWebRulesReceiverTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesReceiverTenantArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the tenant
        :param pulumi.Input[_builtins.str] name: Name of the tenant
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the tenant
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the tenant
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DLPWebRulesSourceIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesSourceIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesSourceIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesUrlCategoriesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesUrlCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesUrlCategoriesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    DLPWebRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class DLPWebRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource.
        """
elif False:
    DLPWebRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DLPWebRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[_builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExtranetExtranetDnsListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (String) The name of the IP pool.
        """
        primary_dns_server: pulumi.Input[_builtins.str]
        """
        (String) The IP address of the primary DNS server.
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) The unique identifier for the extranet.
        """
        secondary_dns_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) The IP address of the secondary DNS server.
        """
        use_as_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) Whether this IP pool is the designated default.
        """
elif False:
    ExtranetExtranetDnsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtranetExtranetDnsListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 primary_dns_server: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 secondary_dns_server: Optional[pulumi.Input[_builtins.str]] = None,
                 use_as_default: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (String) The name of the IP pool.
        :param pulumi.Input[_builtins.str] primary_dns_server: (String) The IP address of the primary DNS server.
        :param pulumi.Input[_builtins.int] id: (Integer) The unique identifier for the extranet.
        :param pulumi.Input[_builtins.str] secondary_dns_server: (String) The IP address of the secondary DNS server.
        :param pulumi.Input[_builtins.bool] use_as_default: (Boolean) Whether this IP pool is the designated default.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_dns_server", primary_dns_server)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if secondary_dns_server is not None:
            pulumi.set(__self__, "secondary_dns_server", secondary_dns_server)
        if use_as_default is not None:
            pulumi.set(__self__, "use_as_default", use_as_default)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (String) The name of the IP pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="primaryDnsServer")
    def primary_dns_server(self) -> pulumi.Input[_builtins.str]:
        """
        (String) The IP address of the primary DNS server.
        """
        return pulumi.get(self, "primary_dns_server")

    @primary_dns_server.setter
    def primary_dns_server(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary_dns_server", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) The unique identifier for the extranet.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="secondaryDnsServer")
    def secondary_dns_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) The IP address of the secondary DNS server.
        """
        return pulumi.get(self, "secondary_dns_server")

    @secondary_dns_server.setter
    def secondary_dns_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_dns_server", value)

    @_builtins.property
    @pulumi.getter(name="useAsDefault")
    def use_as_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) Whether this IP pool is the designated default.
        """
        return pulumi.get(self, "use_as_default")

    @use_as_default.setter
    def use_as_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_as_default", value)


if not MYPY:
    class ExtranetExtranetIpPoolListArgsDict(TypedDict):
        ip_end: pulumi.Input[_builtins.str]
        """
        (String) The ending IP address of the pool.
        """
        ip_start: pulumi.Input[_builtins.str]
        """
        (String) The starting IP address of the pool.
        """
        name: pulumi.Input[_builtins.str]
        """
        (String) The name of the IP pool.
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) The unique identifier for the extranet.
        """
        use_as_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) Whether this IP pool is the designated default.
        """
elif False:
    ExtranetExtranetIpPoolListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtranetExtranetIpPoolListArgs:
    def __init__(__self__, *,
                 ip_end: pulumi.Input[_builtins.str],
                 ip_start: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 use_as_default: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_end: (String) The ending IP address of the pool.
        :param pulumi.Input[_builtins.str] ip_start: (String) The starting IP address of the pool.
        :param pulumi.Input[_builtins.str] name: (String) The name of the IP pool.
        :param pulumi.Input[_builtins.int] id: (Integer) The unique identifier for the extranet.
        :param pulumi.Input[_builtins.bool] use_as_default: (Boolean) Whether this IP pool is the designated default.
        """
        pulumi.set(__self__, "ip_end", ip_end)
        pulumi.set(__self__, "ip_start", ip_start)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_as_default is not None:
            pulumi.set(__self__, "use_as_default", use_as_default)

    @_builtins.property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> pulumi.Input[_builtins.str]:
        """
        (String) The ending IP address of the pool.
        """
        return pulumi.get(self, "ip_end")

    @ip_end.setter
    def ip_end(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_end", value)

    @_builtins.property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> pulumi.Input[_builtins.str]:
        """
        (String) The starting IP address of the pool.
        """
        return pulumi.get(self, "ip_start")

    @ip_start.setter
    def ip_start(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_start", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (String) The name of the IP pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) The unique identifier for the extranet.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useAsDefault")
    def use_as_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) Whether this IP pool is the designated default.
        """
        return pulumi.get(self, "use_as_default")

    @use_as_default.setter
    def use_as_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_as_default", value)


if not MYPY:
    class FileTypeControlRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FileTypeControlRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FileTypeControlRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FileTypeControlRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FileTypeControlRulesZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the application segment.
        """
elif False:
    FileTypeControlRulesZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileTypeControlRulesZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[_builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallDNSRuleApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleDnsGatewayArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleDnsGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleDnsGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Unique identifier for the Firewall Filtering policy rule
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallDNSRuleEdnsEcsObjectArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleEdnsEcsObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleEdnsEcsObjectArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Unique identifier for the Firewall Filtering policy rule
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallDNSRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Unique identifier for the Firewall Filtering policy rule
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirewallDNSRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identifier for the Firewall Filtering policy rule
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallDNSRuleZpaIpGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
elif False:
    FirewallDNSRuleZpaIpGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallDNSRuleZpaIpGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Unique identifier for the Firewall Filtering policy rule
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        Unique identifier for the Firewall Filtering policy rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallFilteringNetworkServicesDestTcpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.int]]
        start: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallFilteringNetworkServicesDestTcpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesDestTcpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.int]] = None,
                 start: Optional[pulumi.Input[_builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringNetworkServicesDestUdpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.int]]
        start: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallFilteringNetworkServicesDestUdpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesDestUdpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.int]] = None,
                 start: Optional[pulumi.Input[_builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringNetworkServicesSrcTcpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.int]]
        start: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallFilteringNetworkServicesSrcTcpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesSrcTcpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.int]] = None,
                 start: Optional[pulumi.Input[_builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringNetworkServicesSrcUdpPortArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.int]]
        start: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallFilteringNetworkServicesSrcUdpPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringNetworkServicesSrcUdpPortArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.int]] = None,
                 start: Optional[pulumi.Input[_builtins.int]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class FirewallFilteringRuleAppServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleAppServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleAppServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleAppServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleAppServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleAppServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallFilteringRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirewallFilteringRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleNwApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleNwApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleNwApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    FirewallFilteringRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class FirewallFilteringRuleWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource.
        """
elif False:
    FirewallFilteringRuleWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[_builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallFilteringRuleZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the application segment.
        """
elif False:
    FirewallFilteringRuleZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringRuleZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[_builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FirewallFilteringServiceGroupsServiceArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    FirewallFilteringServiceGroupsServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFilteringServiceGroupsServiceArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlProxiesCertArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) Identifier that uniquely identifies the certificate
        """
elif False:
    ForwardingControlProxiesCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlProxiesCertArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) Identifier that uniquely identifies the certificate
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) Identifier that uniquely identifies the certificate
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ForwardingControlRuleAppServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleAppServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleAppServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleEcGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleEcGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleEcGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (int) Identifier that uniquely identifies an entity
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ForwardingControlRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleNwApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleNwApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleNwApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleProxyGatewayArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        (int) Identifier that uniquely identifies an entity
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (string) The configured name of the entity
        """
elif False:
    ForwardingControlRuleProxyGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleProxyGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (int) Identifier that uniquely identifies an entity
        :param pulumi.Input[_builtins.str] name: (string) The configured name of the entity
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        (int) Identifier that uniquely identifies an entity
        """
        name: pulumi.Input[_builtins.str]
        """
        (string) The configured name of the entity
        """
elif False:
    ForwardingControlRuleZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: (int) Identifier that uniquely identifies an entity
        :param pulumi.Input[_builtins.str] name: (string) The configured name of the entity
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlRuleZpaApplicationSegmentGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleZpaApplicationSegmentGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaApplicationSegmentGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleZpaApplicationSegmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (int) Identifier that uniquely identifies an entity
        """
elif False:
    ForwardingControlRuleZpaApplicationSegmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaApplicationSegmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (int) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class ForwardingControlRuleZpaGatewayArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        (int) Identifier that uniquely identifies an entity
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (string) The configured name of the entity
        """
elif False:
    ForwardingControlRuleZpaGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlRuleZpaGatewayArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (int) Identifier that uniquely identifies an entity
        :param pulumi.Input[_builtins.str] name: (string) The configured name of the entity
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlZPAGatewayZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        name: pulumi.Input[_builtins.str]
        """
        The configured name of the entity
        """
elif False:
    ForwardingControlZPAGatewayZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlZPAGatewayZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        :param pulumi.Input[_builtins.str] name: The configured name of the entity
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ForwardingControlZPAGatewayZpaServerGroupArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        name: pulumi.Input[_builtins.str]
        """
        The configured name of the entity
        """
elif False:
    ForwardingControlZPAGatewayZpaServerGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardingControlZPAGatewayZpaServerGroupArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        :param pulumi.Input[_builtins.str] name: The configured name of the entity
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        An external identifier used for an entity that is managed outside of ZIA. Examples include zpaServerGroup and zpaAppSegments. This field is not applicable to ZIA-managed entities.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The configured name of the entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IPSFirewallRuleDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) Identifier that uniquely identifies an entity
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class IPSFirewallRuleLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleThreatCategoriesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleThreatCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleThreatCategoriesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    IPSFirewallRuleUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class IPSFirewallRuleZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the application segment.
        """
elif False:
    IPSFirewallRuleZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPSFirewallRuleZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[_builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LocationManagementExtranetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    LocationManagementExtranetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementExtranetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LocationManagementExtranetDnArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    LocationManagementExtranetDnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementExtranetDnArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LocationManagementExtranetIpPoolArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    LocationManagementExtranetIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementExtranetIpPoolArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LocationManagementStaticLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    LocationManagementStaticLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementStaticLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class LocationManagementVpnCredentialArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.int]]
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        pre_shared_key: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LocationManagementVpnCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationManagementVpnCredentialArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 pre_shared_key: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "pre_shared_key")

    @pre_shared_key.setter
    def pre_shared_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_shared_key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NatControlRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesDestIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesDestIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesDestIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    NatControlRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NatControlRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesSrcIpv6GroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesSrcIpv6GroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesSrcIpv6GroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class NatControlRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    NatControlRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatControlRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class RiskProfilesCustomTagsArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    RiskProfilesCustomTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskProfilesCustomTagsArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesActionArgsDict(TypedDict):
        decrypt_sub_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgsDict']]]]
        """
        (Block List) - Action taken when enabling SSL intercept
        """
        do_not_decrypt_sub_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgsDict']]]]
        """
        (Block List) - Action taken when bypassing SSL intercept
        """
        override_default_certificate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to override the default SSL interception certificate.
        """
        show_eun: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Enable this setting to display end user notifications.
        """
        show_eunatp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to display the EUN ATP page.
        """
        ssl_interception_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgsDict']]]]
        """
        has the following attributes:
        **NOTE** This block can only be set when `override_default_certificate` is `true`
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) - The action type for this rule. Possible values: `BLOCK`.
        """
elif False:
    SSLInspectionRulesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionArgs:
    def __init__(__self__, *,
                 decrypt_sub_actions: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]]] = None,
                 do_not_decrypt_sub_actions: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]]] = None,
                 override_default_certificate: Optional[pulumi.Input[_builtins.bool]] = None,
                 show_eun: Optional[pulumi.Input[_builtins.bool]] = None,
                 show_eunatp: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssl_interception_certs: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]] decrypt_sub_actions: (Block List) - Action taken when enabling SSL intercept
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]] do_not_decrypt_sub_actions: (Block List) - Action taken when bypassing SSL intercept
        :param pulumi.Input[_builtins.bool] override_default_certificate: (Boolean) - Whether to override the default SSL interception certificate.
        :param pulumi.Input[_builtins.bool] show_eun: (Boolean) - Enable this setting to display end user notifications.
        :param pulumi.Input[_builtins.bool] show_eunatp: (Boolean) - Whether to display the EUN ATP page.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]] ssl_interception_certs: has the following attributes:
               **NOTE** This block can only be set when `override_default_certificate` is `true`
        :param pulumi.Input[_builtins.str] type: (String) - The action type for this rule. Possible values: `BLOCK`.
        """
        if decrypt_sub_actions is not None:
            pulumi.set(__self__, "decrypt_sub_actions", decrypt_sub_actions)
        if do_not_decrypt_sub_actions is not None:
            pulumi.set(__self__, "do_not_decrypt_sub_actions", do_not_decrypt_sub_actions)
        if override_default_certificate is not None:
            pulumi.set(__self__, "override_default_certificate", override_default_certificate)
        if show_eun is not None:
            pulumi.set(__self__, "show_eun", show_eun)
        if show_eunatp is not None:
            pulumi.set(__self__, "show_eunatp", show_eunatp)
        if ssl_interception_certs is not None:
            pulumi.set(__self__, "ssl_interception_certs", ssl_interception_certs)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="decryptSubActions")
    def decrypt_sub_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]]]:
        """
        (Block List) - Action taken when enabling SSL intercept
        """
        return pulumi.get(self, "decrypt_sub_actions")

    @decrypt_sub_actions.setter
    def decrypt_sub_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDecryptSubActionArgs']]]]):
        pulumi.set(self, "decrypt_sub_actions", value)

    @_builtins.property
    @pulumi.getter(name="doNotDecryptSubActions")
    def do_not_decrypt_sub_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]]]:
        """
        (Block List) - Action taken when bypassing SSL intercept
        """
        return pulumi.get(self, "do_not_decrypt_sub_actions")

    @do_not_decrypt_sub_actions.setter
    def do_not_decrypt_sub_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionDoNotDecryptSubActionArgs']]]]):
        pulumi.set(self, "do_not_decrypt_sub_actions", value)

    @_builtins.property
    @pulumi.getter(name="overrideDefaultCertificate")
    def override_default_certificate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to override the default SSL interception certificate.
        """
        return pulumi.get(self, "override_default_certificate")

    @override_default_certificate.setter
    def override_default_certificate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_default_certificate", value)

    @_builtins.property
    @pulumi.getter(name="showEun")
    def show_eun(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Enable this setting to display end user notifications.
        """
        return pulumi.get(self, "show_eun")

    @show_eun.setter
    def show_eun(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "show_eun", value)

    @_builtins.property
    @pulumi.getter(name="showEunatp")
    def show_eunatp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to display the EUN ATP page.
        """
        return pulumi.get(self, "show_eunatp")

    @show_eunatp.setter
    def show_eunatp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "show_eunatp", value)

    @_builtins.property
    @pulumi.getter(name="sslInterceptionCerts")
    def ssl_interception_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]]]:
        """
        has the following attributes:
        **NOTE** This block can only be set when `override_default_certificate` is `true`
        """
        return pulumi.get(self, "ssl_interception_certs")

    @ssl_interception_certs.setter
    def ssl_interception_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionSslInterceptionCertArgs']]]]):
        pulumi.set(self, "ssl_interception_certs", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) - The action type for this rule. Possible values: `BLOCK`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SSLInspectionRulesActionDecryptSubActionArgsDict(TypedDict):
        block_ssl_traffic_with_no_sni_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        block_undecrypt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Enable to block traffic from servers that use non-standard encryption methods or require mutual TLS authentication.
        """
        http2_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean)
        """
        min_client_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) - The minimum TLS version allowed on the client side: Supported Values are: `CLIENT_TLS_1_0`, `CLIENT_TLS_1_1`, `CLIENT_TLS_1_2`,  `CLIENT_TLS_1_3`.
        """
        min_server_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) - The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        """
        ocsp_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to enable OCSP check.
        """
        server_certificates: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
elif False:
    SSLInspectionRulesActionDecryptSubActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionDecryptSubActionArgs:
    def __init__(__self__, *,
                 block_ssl_traffic_with_no_sni_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_undecrypt: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_client_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 min_server_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 server_certificates: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_ssl_traffic_with_no_sni_enabled: (Boolean) - Whether to block SSL traffic when SNI is not present.
        :param pulumi.Input[_builtins.bool] block_undecrypt: (Boolean) - Enable to block traffic from servers that use non-standard encryption methods or require mutual TLS authentication.
        :param pulumi.Input[_builtins.bool] http2_enabled: (Boolean)
        :param pulumi.Input[_builtins.str] min_client_tls_version: (String) - The minimum TLS version allowed on the client side: Supported Values are: `CLIENT_TLS_1_0`, `CLIENT_TLS_1_1`, `CLIENT_TLS_1_2`,  `CLIENT_TLS_1_3`.
        :param pulumi.Input[_builtins.str] min_server_tls_version: (String) - The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        :param pulumi.Input[_builtins.bool] ocsp_check: (Boolean) - Whether to enable OCSP check.
        :param pulumi.Input[_builtins.str] server_certificates: (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        if block_ssl_traffic_with_no_sni_enabled is not None:
            pulumi.set(__self__, "block_ssl_traffic_with_no_sni_enabled", block_ssl_traffic_with_no_sni_enabled)
        if block_undecrypt is not None:
            pulumi.set(__self__, "block_undecrypt", block_undecrypt)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if min_client_tls_version is not None:
            pulumi.set(__self__, "min_client_tls_version", min_client_tls_version)
        if min_server_tls_version is not None:
            pulumi.set(__self__, "min_server_tls_version", min_server_tls_version)
        if ocsp_check is not None:
            pulumi.set(__self__, "ocsp_check", ocsp_check)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @_builtins.property
    @pulumi.getter(name="blockSslTrafficWithNoSniEnabled")
    def block_ssl_traffic_with_no_sni_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        return pulumi.get(self, "block_ssl_traffic_with_no_sni_enabled")

    @block_ssl_traffic_with_no_sni_enabled.setter
    def block_ssl_traffic_with_no_sni_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_ssl_traffic_with_no_sni_enabled", value)

    @_builtins.property
    @pulumi.getter(name="blockUndecrypt")
    def block_undecrypt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Enable to block traffic from servers that use non-standard encryption methods or require mutual TLS authentication.
        """
        return pulumi.get(self, "block_undecrypt")

    @block_undecrypt.setter
    def block_undecrypt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_undecrypt", value)

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean)
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_enabled", value)

    @_builtins.property
    @pulumi.getter(name="minClientTlsVersion")
    def min_client_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) - The minimum TLS version allowed on the client side: Supported Values are: `CLIENT_TLS_1_0`, `CLIENT_TLS_1_1`, `CLIENT_TLS_1_2`,  `CLIENT_TLS_1_3`.
        """
        return pulumi.get(self, "min_client_tls_version")

    @min_client_tls_version.setter
    def min_client_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_client_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="minServerTlsVersion")
    def min_server_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) - The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        """
        return pulumi.get(self, "min_server_tls_version")

    @min_server_tls_version.setter
    def min_server_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_server_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="ocspCheck")
    def ocsp_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to enable OCSP check.
        """
        return pulumi.get(self, "ocsp_check")

    @ocsp_check.setter
    def ocsp_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ocsp_check", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_certificates", value)


if not MYPY:
    class SSLInspectionRulesActionDoNotDecryptSubActionArgsDict(TypedDict):
        block_ssl_traffic_with_no_sni_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        bypass_other_policies: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to bypass other policies when action is set to `DO_NOT_DECRYPT`.
        """
        min_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) -  The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        **NOTE** `min_tls_version` and `server_certificates` CANNOT be set if `bypass_other_policies` is `true`
        """
        ocsp_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Boolean) - Whether to enable OCSP check.
        """
        server_certificates: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
elif False:
    SSLInspectionRulesActionDoNotDecryptSubActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionDoNotDecryptSubActionArgs:
    def __init__(__self__, *,
                 block_ssl_traffic_with_no_sni_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 bypass_other_policies: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 server_certificates: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_ssl_traffic_with_no_sni_enabled: (Boolean) - Whether to block SSL traffic when SNI is not present.
        :param pulumi.Input[_builtins.bool] bypass_other_policies: (Boolean) - Whether to bypass other policies when action is set to `DO_NOT_DECRYPT`.
        :param pulumi.Input[_builtins.str] min_tls_version: (String) -  The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
               **NOTE** `min_tls_version` and `server_certificates` CANNOT be set if `bypass_other_policies` is `true`
        :param pulumi.Input[_builtins.bool] ocsp_check: (Boolean) - Whether to enable OCSP check.
        :param pulumi.Input[_builtins.str] server_certificates: (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        if block_ssl_traffic_with_no_sni_enabled is not None:
            pulumi.set(__self__, "block_ssl_traffic_with_no_sni_enabled", block_ssl_traffic_with_no_sni_enabled)
        if bypass_other_policies is not None:
            pulumi.set(__self__, "bypass_other_policies", bypass_other_policies)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if ocsp_check is not None:
            pulumi.set(__self__, "ocsp_check", ocsp_check)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @_builtins.property
    @pulumi.getter(name="blockSslTrafficWithNoSniEnabled")
    def block_ssl_traffic_with_no_sni_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to block SSL traffic when SNI is not present.
        """
        return pulumi.get(self, "block_ssl_traffic_with_no_sni_enabled")

    @block_ssl_traffic_with_no_sni_enabled.setter
    def block_ssl_traffic_with_no_sni_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_ssl_traffic_with_no_sni_enabled", value)

    @_builtins.property
    @pulumi.getter(name="bypassOtherPolicies")
    def bypass_other_policies(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to bypass other policies when action is set to `DO_NOT_DECRYPT`.
        """
        return pulumi.get(self, "bypass_other_policies")

    @bypass_other_policies.setter
    def bypass_other_policies(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bypass_other_policies", value)

    @_builtins.property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) -  The minimum TLS version allowed on the server side: Supported Values are: `SERVER_TLS_1_0`, `SERVER_TLS_1_1`, `SERVER_TLS_1_2`,  `SERVER_TLS_1_3`.
        **NOTE** `min_tls_version` and `server_certificates` CANNOT be set if `bypass_other_policies` is `true`
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="ocspCheck")
    def ocsp_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Boolean) - Whether to enable OCSP check.
        """
        return pulumi.get(self, "ocsp_check")

    @ocsp_check.setter
    def ocsp_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ocsp_check", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) - Action to take on server certificates. Valid values might include `ALLOW`, `BLOCK`, or `PASS_THRU`.
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_certificates", value)


if not MYPY:
    class SSLInspectionRulesActionSslInterceptionCertArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesActionSslInterceptionCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesActionSslInterceptionCertArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) - A unique identifier assigned to the workload group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SSLInspectionRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) - A unique identifier assigned to the workload group
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SSLInspectionRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesProxyGatewaysArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesProxyGatewaysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesProxyGatewaysArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesSourceIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesSourceIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesSourceIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
elif False:
    SSLInspectionRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) - A unique identifier assigned to the workload group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SSLInspectionRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource.
        """
elif False:
    SSLInspectionRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) - A unique identifier assigned to the workload group
        :param pulumi.Input[_builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        (Integer) - A unique identifier assigned to the workload group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SSLInspectionRulesZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the application segment.
        """
elif False:
    SSLInspectionRulesZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SSLInspectionRulesZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[_builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SandboxRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) Identifier that uniquely identifies an entity
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SandboxRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        (Integer) Identifier that uniquely identifies an entity
        """
elif False:
    SandboxRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: (Integer) Identifier that uniquely identifies an entity
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class SandboxRulesZpaAppSegmentArgsDict(TypedDict):
        external_id: pulumi.Input[_builtins.str]
        """
        External ID of the application segment.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the application segment.
        """
elif False:
    SandboxRulesZpaAppSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SandboxRulesZpaAppSegmentArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] external_id: External ID of the application segment.
        :param pulumi.Input[_builtins.str] name: Name of the application segment.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[_builtins.str]:
        """
        External ID of the application segment.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the application segment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SubCloudDcArgsDict(TypedDict):
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) Country where the excluded data center is located.
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer) Unique identifier for the datacenter.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) Datacenter name.
        """
elif False:
    SubCloudDcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubCloudDcArgs:
    def __init__(__self__, *,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] country: (String) Country where the excluded data center is located.
        :param pulumi.Input[_builtins.int] id: (Integer) Unique identifier for the datacenter.
        :param pulumi.Input[_builtins.str] name: (String) Datacenter name.
        """
        if country is not None:
            pulumi.set(__self__, "country", country)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) Country where the excluded data center is located.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer) Unique identifier for the datacenter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) Datacenter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SubCloudExclusionArgsDict(TypedDict):
        country: pulumi.Input[_builtins.str]
        """
        (String) Country where the excluded data center is located.
        """
        datacenter: pulumi.Input['SubCloudExclusionDatacenterArgsDict']
        """
        (List) The excluded datacenter reference.
        """
        end_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Integer, Optional) Exclusion end time (Unix timestamp). Either `end_time` or `end_time_utc` must be set.
        """
        end_time_utc: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String, Optional) Data center disabled until (UTC). Format: `MM/DD/YYYY HH:MM:SS am/pm`. If set, overrides `end_time`.
        """
elif False:
    SubCloudExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubCloudExclusionArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[_builtins.str],
                 datacenter: pulumi.Input['SubCloudExclusionDatacenterArgs'],
                 end_time: Optional[pulumi.Input[_builtins.int]] = None,
                 end_time_utc: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] country: (String) Country where the excluded data center is located.
        :param pulumi.Input['SubCloudExclusionDatacenterArgs'] datacenter: (List) The excluded datacenter reference.
        :param pulumi.Input[_builtins.int] end_time: (Integer, Optional) Exclusion end time (Unix timestamp). Either `end_time` or `end_time_utc` must be set.
        :param pulumi.Input[_builtins.str] end_time_utc: (String, Optional) Data center disabled until (UTC). Format: `MM/DD/YYYY HH:MM:SS am/pm`. If set, overrides `end_time`.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "datacenter", datacenter)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if end_time_utc is not None:
            pulumi.set(__self__, "end_time_utc", end_time_utc)

    @_builtins.property
    @pulumi.getter
    def country(self) -> pulumi.Input[_builtins.str]:
        """
        (String) Country where the excluded data center is located.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> pulumi.Input['SubCloudExclusionDatacenterArgs']:
        """
        (List) The excluded datacenter reference.
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: pulumi.Input['SubCloudExclusionDatacenterArgs']):
        pulumi.set(self, "datacenter", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Integer, Optional) Exclusion end time (Unix timestamp). Either `end_time` or `end_time_utc` must be set.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String, Optional) Data center disabled until (UTC). Format: `MM/DD/YYYY HH:MM:SS am/pm`. If set, overrides `end_time`.
        """
        return pulumi.get(self, "end_time_utc")

    @end_time_utc.setter
    def end_time_utc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time_utc", value)


if not MYPY:
    class SubCloudExclusionDatacenterArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        (Integer) Unique identifier for the datacenter.
        """
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) Country where the excluded data center is located.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) Datacenter name.
        """
elif False:
    SubCloudExclusionDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubCloudExclusionDatacenterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: (Integer) Unique identifier for the datacenter.
        :param pulumi.Input[_builtins.str] country: (String) Country where the excluded data center is located.
        :param pulumi.Input[_builtins.str] name: (String) Datacenter name.
        """
        pulumi.set(__self__, "id", id)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        (Integer) Unique identifier for the datacenter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) Country where the excluded data center is located.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) Datacenter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TrafficCaptureRulesAppServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesAppServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesAppServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesDestIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesDestIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesDestIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesLabelsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TrafficCaptureRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesLabelsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TrafficCaptureRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesNwApplicationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesNwApplicationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesNwApplicationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesNwServiceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesNwServiceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesNwServiceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesNwServicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesNwServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesNwServicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesSrcIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesSrcIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesSrcIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    TrafficCaptureRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class TrafficCaptureRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource.
        """
elif False:
    TrafficCaptureRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficCaptureRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[_builtins.str] name: The name of the resource.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TrafficForwardingGRETunnelPrimaryDestVipArgsDict(TypedDict):
        datacenter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data center information
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        GRE cluster virtual IP ID
        """
        virtual_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        GRE cluster virtual IP address (VIP)
        """
elif False:
    TrafficForwardingGRETunnelPrimaryDestVipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficForwardingGRETunnelPrimaryDestVipArgs:
    def __init__(__self__, *,
                 datacenter: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 virtual_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] datacenter: Data center information
        :param pulumi.Input[_builtins.int] id: GRE cluster virtual IP ID
        :param pulumi.Input[_builtins.str] virtual_ip: GRE cluster virtual IP address (VIP)
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data center information
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datacenter", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        GRE cluster virtual IP ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GRE cluster virtual IP address (VIP)
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class TrafficForwardingGRETunnelSecondaryDestVipArgsDict(TypedDict):
        datacenter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data center information
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        GRE cluster virtual IP ID
        """
        virtual_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        GRE cluster virtual IP address (VIP)
        """
elif False:
    TrafficForwardingGRETunnelSecondaryDestVipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficForwardingGRETunnelSecondaryDestVipArgs:
    def __init__(__self__, *,
                 datacenter: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 virtual_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] datacenter: Data center information
        :param pulumi.Input[_builtins.int] id: GRE cluster virtual IP ID
        :param pulumi.Input[_builtins.str] virtual_ip: GRE cluster virtual IP address (VIP)
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data center information
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "datacenter", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        GRE cluster virtual IP ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="virtualIp")
    def virtual_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GRE cluster virtual IP address (VIP)
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class URLCategoriesPredefinedUrlKeywordCountArgsDict(TypedDict):
        retain_parent_keyword_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count of total keywords with retain parent category.
        """
        retain_parent_url_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count of URLs with retain parent category.
        """
        total_keyword_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total keyword count for the category.
        """
        total_url_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Custom URL count for the category.
        """
elif False:
    URLCategoriesPredefinedUrlKeywordCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesPredefinedUrlKeywordCountArgs:
    def __init__(__self__, *,
                 retain_parent_keyword_count: Optional[pulumi.Input[_builtins.int]] = None,
                 retain_parent_url_count: Optional[pulumi.Input[_builtins.int]] = None,
                 total_keyword_count: Optional[pulumi.Input[_builtins.int]] = None,
                 total_url_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] retain_parent_keyword_count: Count of total keywords with retain parent category.
        :param pulumi.Input[_builtins.int] retain_parent_url_count: Count of URLs with retain parent category.
        :param pulumi.Input[_builtins.int] total_keyword_count: Total keyword count for the category.
        :param pulumi.Input[_builtins.int] total_url_count: Custom URL count for the category.
        """
        if retain_parent_keyword_count is not None:
            pulumi.set(__self__, "retain_parent_keyword_count", retain_parent_keyword_count)
        if retain_parent_url_count is not None:
            pulumi.set(__self__, "retain_parent_url_count", retain_parent_url_count)
        if total_keyword_count is not None:
            pulumi.set(__self__, "total_keyword_count", total_keyword_count)
        if total_url_count is not None:
            pulumi.set(__self__, "total_url_count", total_url_count)

    @_builtins.property
    @pulumi.getter(name="retainParentKeywordCount")
    def retain_parent_keyword_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count of total keywords with retain parent category.
        """
        return pulumi.get(self, "retain_parent_keyword_count")

    @retain_parent_keyword_count.setter
    def retain_parent_keyword_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retain_parent_keyword_count", value)

    @_builtins.property
    @pulumi.getter(name="retainParentUrlCount")
    def retain_parent_url_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count of URLs with retain parent category.
        """
        return pulumi.get(self, "retain_parent_url_count")

    @retain_parent_url_count.setter
    def retain_parent_url_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retain_parent_url_count", value)

    @_builtins.property
    @pulumi.getter(name="totalKeywordCount")
    def total_keyword_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total keyword count for the category.
        """
        return pulumi.get(self, "total_keyword_count")

    @total_keyword_count.setter
    def total_keyword_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_keyword_count", value)

    @_builtins.property
    @pulumi.getter(name="totalUrlCount")
    def total_url_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Custom URL count for the category.
        """
        return pulumi.get(self, "total_url_count")

    @total_url_count.setter
    def total_url_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_url_count", value)


if not MYPY:
    class URLCategoriesScopeArgsDict(TypedDict):
        scope_entities: NotRequired[pulumi.Input['URLCategoriesScopeScopeEntitiesArgsDict']]
        """
        list of scope IDs
        """
        scope_group_member_entities: NotRequired[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgsDict']]
        """
        list of scope group member IDs
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    URLCategoriesScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesScopeArgs:
    def __init__(__self__, *,
                 scope_entities: Optional[pulumi.Input['URLCategoriesScopeScopeEntitiesArgs']] = None,
                 scope_group_member_entities: Optional[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['URLCategoriesScopeScopeEntitiesArgs'] scope_entities: list of scope IDs
        :param pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs'] scope_group_member_entities: list of scope group member IDs
        """
        if scope_entities is not None:
            pulumi.set(__self__, "scope_entities", scope_entities)
        if scope_group_member_entities is not None:
            pulumi.set(__self__, "scope_group_member_entities", scope_group_member_entities)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="scopeEntities")
    def scope_entities(self) -> Optional[pulumi.Input['URLCategoriesScopeScopeEntitiesArgs']]:
        """
        list of scope IDs
        """
        return pulumi.get(self, "scope_entities")

    @scope_entities.setter
    def scope_entities(self, value: Optional[pulumi.Input['URLCategoriesScopeScopeEntitiesArgs']]):
        pulumi.set(self, "scope_entities", value)

    @_builtins.property
    @pulumi.getter(name="scopeGroupMemberEntities")
    def scope_group_member_entities(self) -> Optional[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs']]:
        """
        list of scope group member IDs
        """
        return pulumi.get(self, "scope_group_member_entities")

    @scope_group_member_entities.setter
    def scope_group_member_entities(self, value: Optional[pulumi.Input['URLCategoriesScopeScopeGroupMemberEntitiesArgs']]):
        pulumi.set(self, "scope_group_member_entities", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class URLCategoriesScopeScopeEntitiesArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    URLCategoriesScopeScopeEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesScopeScopeEntitiesArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLCategoriesScopeScopeGroupMemberEntitiesArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    URLCategoriesScopeScopeGroupMemberEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesScopeScopeGroupMemberEntitiesArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLCategoriesUrlKeywordCountsArgsDict(TypedDict):
        retain_parent_keyword_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count of total keywords with retain parent category.
        """
        retain_parent_url_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count of URLs with retain parent category.
        """
        total_keyword_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total keyword count for the category.
        """
        total_url_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Custom URL count for the category.
        """
elif False:
    URLCategoriesUrlKeywordCountsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLCategoriesUrlKeywordCountsArgs:
    def __init__(__self__, *,
                 retain_parent_keyword_count: Optional[pulumi.Input[_builtins.int]] = None,
                 retain_parent_url_count: Optional[pulumi.Input[_builtins.int]] = None,
                 total_keyword_count: Optional[pulumi.Input[_builtins.int]] = None,
                 total_url_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] retain_parent_keyword_count: Count of total keywords with retain parent category.
        :param pulumi.Input[_builtins.int] retain_parent_url_count: Count of URLs with retain parent category.
        :param pulumi.Input[_builtins.int] total_keyword_count: Total keyword count for the category.
        :param pulumi.Input[_builtins.int] total_url_count: Custom URL count for the category.
        """
        if retain_parent_keyword_count is not None:
            pulumi.set(__self__, "retain_parent_keyword_count", retain_parent_keyword_count)
        if retain_parent_url_count is not None:
            pulumi.set(__self__, "retain_parent_url_count", retain_parent_url_count)
        if total_keyword_count is not None:
            pulumi.set(__self__, "total_keyword_count", total_keyword_count)
        if total_url_count is not None:
            pulumi.set(__self__, "total_url_count", total_url_count)

    @_builtins.property
    @pulumi.getter(name="retainParentKeywordCount")
    def retain_parent_keyword_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count of total keywords with retain parent category.
        """
        return pulumi.get(self, "retain_parent_keyword_count")

    @retain_parent_keyword_count.setter
    def retain_parent_keyword_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retain_parent_keyword_count", value)

    @_builtins.property
    @pulumi.getter(name="retainParentUrlCount")
    def retain_parent_url_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count of URLs with retain parent category.
        """
        return pulumi.get(self, "retain_parent_url_count")

    @retain_parent_url_count.setter
    def retain_parent_url_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retain_parent_url_count", value)

    @_builtins.property
    @pulumi.getter(name="totalKeywordCount")
    def total_keyword_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total keyword count for the category.
        """
        return pulumi.get(self, "total_keyword_count")

    @total_keyword_count.setter
    def total_keyword_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_keyword_count", value)

    @_builtins.property
    @pulumi.getter(name="totalUrlCount")
    def total_url_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Custom URL count for the category.
        """
        return pulumi.get(self, "total_url_count")

    @total_url_count.setter
    def total_url_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_url_count", value)


if not MYPY:
    class URLFilteringRulesCbiProfileArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
        profile_seq: NotRequired[pulumi.Input[_builtins.int]]
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The browser isolation profile URL
        """
elif False:
    URLFilteringRulesCbiProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesCbiProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 profile_seq: Optional[pulumi.Input[_builtins.int]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[_builtins.str] url: The browser isolation profile URL
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if profile_seq is not None:
            pulumi.set(__self__, "profile_seq", profile_seq)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="profileSeq")
    def profile_seq(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "profile_seq")

    @profile_seq.setter
    def profile_seq(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "profile_seq", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The browser isolation profile URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class URLFilteringRulesDepartmentsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesDepartmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesDepartmentsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesDeviceGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesDeviceGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesDeviceGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesDevicesArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesDevicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesDevicesArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesLabelsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesLabelsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesLocationGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesLocationGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesLocationGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesLocationsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesLocationsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesOverrideGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesOverrideGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesOverrideGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesOverrideUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesOverrideUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesOverrideUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesSourceIpGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesSourceIpGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesSourceIpGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesTimeWindowsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesTimeWindowsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesUsersArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
elif False:
    URLFilteringRulesUsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesUsersArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class URLFilteringRulesWorkloadGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.int]
        """
        The unique identifier for the resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Firewall Filtering policy rule
        """
elif False:
    URLFilteringRulesWorkloadGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class URLFilteringRulesWorkloadGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The unique identifier for the resource.
        :param pulumi.Input[_builtins.str] name: Name of the Firewall Filtering policy rule
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.int]:
        """
        The unique identifier for the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserManagementDepartmentArgsDict(TypedDict):
        comments: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional information about this department
        """
        deleted: NotRequired[pulumi.Input[_builtins.bool]]
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Department ID

        !> **WARNING:** The password parameter is considered sensitive information and is omitted in case terraform output is configured.
        """
        idp_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Identity provider (IdP) ID
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name. This appears when choosing users for policies.
        """
elif False:
    UserManagementDepartmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserManagementDepartmentArgs:
    def __init__(__self__, *,
                 comments: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 idp_id: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comments: Additional information about this department
        :param pulumi.Input[_builtins.int] id: Department ID
               
               !> **WARNING:** The password parameter is considered sensitive information and is omitted in case terraform output is configured.
        :param pulumi.Input[_builtins.int] idp_id: Identity provider (IdP) ID
        :param pulumi.Input[_builtins.str] name: User name. This appears when choosing users for policies.
        """
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if deleted is not None:
            pulumi.set(__self__, "deleted", deleted)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information about this department
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comments", value)

    @_builtins.property
    @pulumi.getter
    def deleted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "deleted")

    @deleted.setter
    def deleted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deleted", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Department ID

        !> **WARNING:** The password parameter is considered sensitive information and is omitted in case terraform output is configured.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Identity provider (IdP) ID
        """
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idp_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name. This appears when choosing users for policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserManagementGroupsArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Unique identfier for the group
        """
elif False:
    UserManagementGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserManagementGroupsArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ids: Unique identfier for the group
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Unique identfier for the group
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class VirtualServiceEdgeClusterVirtualZenNodesArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    VirtualServiceEdgeClusterVirtualZenNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualServiceEdgeClusterVirtualZenNodesArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class WorkloadGroupsExpressionJsonArgsDict(TypedDict):
        expression_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerArgsDict']]]]
        """
        (List) Contains one or more tag types (and associated tags) combined using logical operators within a workload group.
        """
elif False:
    WorkloadGroupsExpressionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadGroupsExpressionJsonArgs:
    def __init__(__self__, *,
                 expression_containers: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerArgs']]] expression_containers: (List) Contains one or more tag types (and associated tags) combined using logical operators within a workload group.
        """
        if expression_containers is not None:
            pulumi.set(__self__, "expression_containers", expression_containers)

    @_builtins.property
    @pulumi.getter(name="expressionContainers")
    def expression_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerArgs']]]]:
        """
        (List) Contains one or more tag types (and associated tags) combined using logical operators within a workload group.
        """
        return pulumi.get(self, "expression_containers")

    @expression_containers.setter
    def expression_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerArgs']]]]):
        pulumi.set(self, "expression_containers", value)


if not MYPY:
    class WorkloadGroupsExpressionJsonExpressionContainerArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) The logical operator (either AND or OR) used to combine the tags within a tag type. Returned values are: `AND`, `OR`.
        """
        tag_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgsDict']]]]
        """
        (List) Contains one or more tags and the logical operator used to combine the tags within a tag type.
        """
        tag_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) The tag type selected from a predefined list. Returned values are: `ANY`, `VPC`, `SUBNET`, `VM`, `ENI`, `ATTR`.
        """
elif False:
    WorkloadGroupsExpressionJsonExpressionContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadGroupsExpressionJsonExpressionContainerArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_containers: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgs']]]] = None,
                 tag_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: (String) The logical operator (either AND or OR) used to combine the tags within a tag type. Returned values are: `AND`, `OR`.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgs']]] tag_containers: (List) Contains one or more tags and the logical operator used to combine the tags within a tag type.
        :param pulumi.Input[_builtins.str] tag_type: (String) The tag type selected from a predefined list. Returned values are: `ANY`, `VPC`, `SUBNET`, `VM`, `ENI`, `ATTR`.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if tag_containers is not None:
            pulumi.set(__self__, "tag_containers", tag_containers)
        if tag_type is not None:
            pulumi.set(__self__, "tag_type", tag_type)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) The logical operator (either AND or OR) used to combine the tags within a tag type. Returned values are: `AND`, `OR`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="tagContainers")
    def tag_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgs']]]]:
        """
        (List) Contains one or more tags and the logical operator used to combine the tags within a tag type.
        """
        return pulumi.get(self, "tag_containers")

    @tag_containers.setter
    def tag_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgs']]]]):
        pulumi.set(self, "tag_containers", value)

    @_builtins.property
    @pulumi.getter(name="tagType")
    def tag_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) The tag type selected from a predefined list. Returned values are: `ANY`, `VPC`, `SUBNET`, `VM`, `ENI`, `ATTR`.
        """
        return pulumi.get(self, "tag_type")

    @tag_type.setter
    def tag_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_type", value)


if not MYPY:
    class WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) The logical operator (either AND or OR) used to combine the tags within a tag type. Returned values are: `AND`, `OR`.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgsDict']]]]
        """
        (List) One or more tags, each consisting of a key-value pair, selected within a tag type. If multiple tags are present within a tag type, they are combined using a logical operator. Note: A maximum of 8 tags can be added to a workload group, irrespective of the number of tag types present.
        """
elif False:
    WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadGroupsExpressionJsonExpressionContainerTagContainerArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: (String) The logical operator (either AND or OR) used to combine the tags within a tag type. Returned values are: `AND`, `OR`.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgs']]] tags: (List) One or more tags, each consisting of a key-value pair, selected within a tag type. If multiple tags are present within a tag type, they are combined using a logical operator. Note: A maximum of 8 tags can be added to a workload group, irrespective of the number of tag types present.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) The logical operator (either AND or OR) used to combine the tags within a tag type. Returned values are: `AND`, `OR`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgs']]]]:
        """
        (List) One or more tags, each consisting of a key-value pair, selected within a tag type. If multiple tags are present within a tag type, they are combined using a logical operator. Note: A maximum of 8 tags can be added to a workload group, irrespective of the number of tag types present.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) The key component present in the key-value pair contained in a tag.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (String) The value component present in the key-value pair contained in a tag.
        """
elif False:
    WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadGroupsExpressionJsonExpressionContainerTagContainerTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: (String) The key component present in the key-value pair contained in a tag.
        :param pulumi.Input[_builtins.str] value: (String) The value component present in the key-value pair contained in a tag.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) The key component present in the key-value pair contained in a tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (String) The value component present in the key-value pair contained in a tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaArgsDict(TypedDict):
        enable_bandwidth_control: _builtins.bool
        """
        (Boolean) Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        """
        enable_caution: _builtins.bool
        """
        (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        """
        enable_xff_forwarding: _builtins.bool
        """
        (Boolean) Enable `XFF` Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        """
        enforce_aup: _builtins.bool
        """
        (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        """
        enforce_authentication: _builtins.bool
        """
        (Boolean) Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        """
        enforce_firewall_control: _builtins.bool
        """
        (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        """
        managed_bies: Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict']
        """
        (Block List)
        """
        cities: NotRequired[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict']]
        """
        (Block List)
        """
        countries: NotRequired[Sequence[_builtins.str]]
        """
        (List of String) One or more countries from a predefined set
        """
        names: NotRequired[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict']]
        """
        Location group name
        """
        profiles: NotRequired[Sequence[_builtins.str]]
        """
        (List of String) One or more location profiles from a predefined set
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaArgs:
    def __init__(__self__, *,
                 enable_bandwidth_control: _builtins.bool,
                 enable_caution: _builtins.bool,
                 enable_xff_forwarding: _builtins.bool,
                 enforce_aup: _builtins.bool,
                 enforce_authentication: _builtins.bool,
                 enforce_firewall_control: _builtins.bool,
                 managed_bies: Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs'],
                 cities: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs']] = None,
                 countries: Optional[Sequence[_builtins.str]] = None,
                 names: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs']] = None,
                 profiles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enable_bandwidth_control: (Boolean) Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        :param _builtins.bool enable_caution: (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        :param _builtins.bool enable_xff_forwarding: (Boolean) Enable `XFF` Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        :param _builtins.bool enforce_aup: (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        :param _builtins.bool enforce_authentication: (Boolean) Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        :param _builtins.bool enforce_firewall_control: (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        :param Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs'] managed_bies: (Block List)
        :param Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs'] cities: (Block List)
        :param Sequence[_builtins.str] countries: (List of String) One or more countries from a predefined set
        :param Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs'] names: Location group name
        :param Sequence[_builtins.str] profiles: (List of String) One or more location profiles from a predefined set
        """
        pulumi.set(__self__, "enable_bandwidth_control", enable_bandwidth_control)
        pulumi.set(__self__, "enable_caution", enable_caution)
        pulumi.set(__self__, "enable_xff_forwarding", enable_xff_forwarding)
        pulumi.set(__self__, "enforce_aup", enforce_aup)
        pulumi.set(__self__, "enforce_authentication", enforce_authentication)
        pulumi.set(__self__, "enforce_firewall_control", enforce_firewall_control)
        pulumi.set(__self__, "managed_bies", managed_bies)
        if cities is not None:
            pulumi.set(__self__, "cities", cities)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)

    @_builtins.property
    @pulumi.getter(name="enableBandwidthControl")
    def enable_bandwidth_control(self) -> _builtins.bool:
        """
        (Boolean) Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        """
        return pulumi.get(self, "enable_bandwidth_control")

    @enable_bandwidth_control.setter
    def enable_bandwidth_control(self, value: _builtins.bool):
        pulumi.set(self, "enable_bandwidth_control", value)

    @_builtins.property
    @pulumi.getter(name="enableCaution")
    def enable_caution(self) -> _builtins.bool:
        """
        (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        """
        return pulumi.get(self, "enable_caution")

    @enable_caution.setter
    def enable_caution(self, value: _builtins.bool):
        pulumi.set(self, "enable_caution", value)

    @_builtins.property
    @pulumi.getter(name="enableXffForwarding")
    def enable_xff_forwarding(self) -> _builtins.bool:
        """
        (Boolean) Enable `XFF` Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        """
        return pulumi.get(self, "enable_xff_forwarding")

    @enable_xff_forwarding.setter
    def enable_xff_forwarding(self, value: _builtins.bool):
        pulumi.set(self, "enable_xff_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="enforceAup")
    def enforce_aup(self) -> _builtins.bool:
        """
        (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        """
        return pulumi.get(self, "enforce_aup")

    @enforce_aup.setter
    def enforce_aup(self, value: _builtins.bool):
        pulumi.set(self, "enforce_aup", value)

    @_builtins.property
    @pulumi.getter(name="enforceAuthentication")
    def enforce_authentication(self) -> _builtins.bool:
        """
        (Boolean) Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        """
        return pulumi.get(self, "enforce_authentication")

    @enforce_authentication.setter
    def enforce_authentication(self, value: _builtins.bool):
        pulumi.set(self, "enforce_authentication", value)

    @_builtins.property
    @pulumi.getter(name="enforceFirewallControl")
    def enforce_firewall_control(self) -> _builtins.bool:
        """
        (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        """
        return pulumi.get(self, "enforce_firewall_control")

    @enforce_firewall_control.setter
    def enforce_firewall_control(self, value: _builtins.bool):
        pulumi.set(self, "enforce_firewall_control", value)

    @_builtins.property
    @pulumi.getter(name="managedBies")
    def managed_bies(self) -> Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs']:
        """
        (Block List)
        """
        return pulumi.get(self, "managed_bies")

    @managed_bies.setter
    def managed_bies(self, value: Sequence['GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs']):
        pulumi.set(self, "managed_bies", value)

    @_builtins.property
    @pulumi.getter
    def cities(self) -> Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs']]:
        """
        (Block List)
        """
        return pulumi.get(self, "cities")

    @cities.setter
    def cities(self, value: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaCityArgs']]):
        pulumi.set(self, "cities", value)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List of String) One or more countries from a predefined set
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "countries", value)

    @_builtins.property
    @pulumi.getter
    def names(self) -> Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs']]:
        """
        Location group name
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[Sequence['GetLocationGroupsDynamicLocationGroupCriteriaNameArgs']]):
        pulumi.set(self, "names", value)

    @_builtins.property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List of String) One or more location profiles from a predefined set
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "profiles", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict(TypedDict):
        match_string: NotRequired[_builtins.str]
        """
        (String) String value to be matched or partially matched
        """
        match_type: NotRequired[_builtins.str]
        """
        (String) Operator that performs match action
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaCityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaCityArgs:
    def __init__(__self__, *,
                 match_string: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_string: (String) String value to be matched or partially matched
        :param _builtins.str match_type: (String) Operator that performs match action
        """
        if match_string is not None:
            pulumi.set(__self__, "match_string", match_string)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter(name="matchString")
    def match_string(self) -> Optional[_builtins.str]:
        """
        (String) String value to be matched or partially matched
        """
        return pulumi.get(self, "match_string")

    @match_string.setter
    def match_string(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_string", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        (String) Operator that performs match action
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict(TypedDict):
        extensions: Mapping[str, _builtins.str]
        """
        (Map of String)
        """
        id: _builtins.int
        """
        Unique identifier for the location group
        """
        name: _builtins.str
        """
        Location group name
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaManagedByArgs:
    def __init__(__self__, *,
                 extensions: Mapping[str, _builtins.str],
                 id: _builtins.int,
                 name: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extensions: (Map of String)
        :param _builtins.int id: Unique identifier for the location group
        :param _builtins.str name: Location group name
        """
        pulumi.set(__self__, "extensions", extensions)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Mapping[str, _builtins.str]:
        """
        (Map of String)
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "extensions", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        Unique identifier for the location group
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.int):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Location group name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict(TypedDict):
        match_string: NotRequired[_builtins.str]
        """
        (String) String value to be matched or partially matched
        """
        match_type: NotRequired[_builtins.str]
        """
        (String) Operator that performs match action
        """
elif False:
    GetLocationGroupsDynamicLocationGroupCriteriaNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLocationGroupsDynamicLocationGroupCriteriaNameArgs:
    def __init__(__self__, *,
                 match_string: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_string: (String) String value to be matched or partially matched
        :param _builtins.str match_type: (String) Operator that performs match action
        """
        if match_string is not None:
            pulumi.set(__self__, "match_string", match_string)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter(name="matchString")
    def match_string(self) -> Optional[_builtins.str]:
        """
        (String) String value to be matched or partially matched
        """
        return pulumi.get(self, "match_string")

    @match_string.setter
    def match_string(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_string", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        (String) Operator that performs match action
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class GetSandboxReportExploitArgsDict(TypedDict):
        risk: _builtins.str
        signature: _builtins.str
        signature_sources: Sequence[_builtins.str]
elif False:
    GetSandboxReportExploitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportExploitArgs:
    def __init__(__self__, *,
                 risk: _builtins.str,
                 signature: _builtins.str,
                 signature_sources: Sequence[_builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: _builtins.str):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: _builtins.str):
        pulumi.set(self, "signature", value)

    @_builtins.property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportNetworkingArgsDict(TypedDict):
        risk: _builtins.str
        signature: _builtins.str
        signature_sources: Sequence[_builtins.str]
elif False:
    GetSandboxReportNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportNetworkingArgs:
    def __init__(__self__, *,
                 risk: _builtins.str,
                 signature: _builtins.str,
                 signature_sources: Sequence[_builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: _builtins.str):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: _builtins.str):
        pulumi.set(self, "signature", value)

    @_builtins.property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportPersistenceArgsDict(TypedDict):
        risk: _builtins.str
        signature: _builtins.str
        signature_sources: Sequence[_builtins.str]
elif False:
    GetSandboxReportPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportPersistenceArgs:
    def __init__(__self__, *,
                 risk: _builtins.str,
                 signature: _builtins.str,
                 signature_sources: Sequence[_builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: _builtins.str):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: _builtins.str):
        pulumi.set(self, "signature", value)

    @_builtins.property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportSecurityBypassArgsDict(TypedDict):
        risk: _builtins.str
        signature: _builtins.str
        signature_sources: Sequence[_builtins.str]
elif False:
    GetSandboxReportSecurityBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportSecurityBypassArgs:
    def __init__(__self__, *,
                 risk: _builtins.str,
                 signature: _builtins.str,
                 signature_sources: Sequence[_builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: _builtins.str):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: _builtins.str):
        pulumi.set(self, "signature", value)

    @_builtins.property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportSpywareArgsDict(TypedDict):
        risk: _builtins.str
        signature: _builtins.str
        signature_sources: Sequence[_builtins.str]
elif False:
    GetSandboxReportSpywareArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportSpywareArgs:
    def __init__(__self__, *,
                 risk: _builtins.str,
                 signature: _builtins.str,
                 signature_sources: Sequence[_builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: _builtins.str):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: _builtins.str):
        pulumi.set(self, "signature", value)

    @_builtins.property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "signature_sources", value)


if not MYPY:
    class GetSandboxReportStealthArgsDict(TypedDict):
        risk: _builtins.str
        signature: _builtins.str
        signature_sources: Sequence[_builtins.str]
elif False:
    GetSandboxReportStealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSandboxReportStealthArgs:
    def __init__(__self__, *,
                 risk: _builtins.str,
                 signature: _builtins.str,
                 signature_sources: Sequence[_builtins.str]):
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "signature_sources", signature_sources)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: _builtins.str):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def signature(self) -> _builtins.str:
        return pulumi.get(self, "signature")

    @signature.setter
    def signature(self, value: _builtins.str):
        pulumi.set(self, "signature", value)

    @_builtins.property
    @pulumi.getter(name="signatureSources")
    def signature_sources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signature_sources")

    @signature_sources.setter
    def signature_sources(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "signature_sources", value)



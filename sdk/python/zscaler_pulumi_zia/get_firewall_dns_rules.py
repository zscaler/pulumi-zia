# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetFirewallDNSRulesResult',
    'AwaitableGetFirewallDNSRulesResult',
    'get_firewall_dns_rules',
    'get_firewall_dns_rules_output',
]

@pulumi.output_type
class GetFirewallDNSRulesResult:
    """
    A collection of values returned by getFirewallDNSRules.
    """
    def __init__(__self__, action=None, application_groups=None, applications=None, block_response_code=None, capture_pcap=None, default_rule=None, departments=None, description=None, dest_addresses=None, dest_countries=None, dest_ip_categories=None, dest_ip_groups=None, dest_ipv6_groups=None, device_groups=None, devices=None, dns_rule_request_types=None, groups=None, id=None, labels=None, last_modified_bies=None, last_modified_time=None, location_groups=None, locations=None, name=None, order=None, predefined=None, protocols=None, rank=None, redirect_ip=None, res_categories=None, source_countries=None, src_ip_groups=None, src_ips=None, src_ipv6_groups=None, state=None, time_windows=None, users=None):
        if action and not isinstance(action, str):
            raise TypeError("Expected argument 'action' to be a str")
        pulumi.set(__self__, "action", action)
        if application_groups and not isinstance(application_groups, list):
            raise TypeError("Expected argument 'application_groups' to be a list")
        pulumi.set(__self__, "application_groups", application_groups)
        if applications and not isinstance(applications, list):
            raise TypeError("Expected argument 'applications' to be a list")
        pulumi.set(__self__, "applications", applications)
        if block_response_code and not isinstance(block_response_code, str):
            raise TypeError("Expected argument 'block_response_code' to be a str")
        pulumi.set(__self__, "block_response_code", block_response_code)
        if capture_pcap and not isinstance(capture_pcap, bool):
            raise TypeError("Expected argument 'capture_pcap' to be a bool")
        pulumi.set(__self__, "capture_pcap", capture_pcap)
        if default_rule and not isinstance(default_rule, bool):
            raise TypeError("Expected argument 'default_rule' to be a bool")
        pulumi.set(__self__, "default_rule", default_rule)
        if departments and not isinstance(departments, list):
            raise TypeError("Expected argument 'departments' to be a list")
        pulumi.set(__self__, "departments", departments)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if dest_addresses and not isinstance(dest_addresses, list):
            raise TypeError("Expected argument 'dest_addresses' to be a list")
        pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries and not isinstance(dest_countries, list):
            raise TypeError("Expected argument 'dest_countries' to be a list")
        pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories and not isinstance(dest_ip_categories, list):
            raise TypeError("Expected argument 'dest_ip_categories' to be a list")
        pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups and not isinstance(dest_ip_groups, list):
            raise TypeError("Expected argument 'dest_ip_groups' to be a list")
        pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if dest_ipv6_groups and not isinstance(dest_ipv6_groups, list):
            raise TypeError("Expected argument 'dest_ipv6_groups' to be a list")
        pulumi.set(__self__, "dest_ipv6_groups", dest_ipv6_groups)
        if device_groups and not isinstance(device_groups, list):
            raise TypeError("Expected argument 'device_groups' to be a list")
        pulumi.set(__self__, "device_groups", device_groups)
        if devices and not isinstance(devices, list):
            raise TypeError("Expected argument 'devices' to be a list")
        pulumi.set(__self__, "devices", devices)
        if dns_rule_request_types and not isinstance(dns_rule_request_types, list):
            raise TypeError("Expected argument 'dns_rule_request_types' to be a list")
        pulumi.set(__self__, "dns_rule_request_types", dns_rule_request_types)
        if groups and not isinstance(groups, list):
            raise TypeError("Expected argument 'groups' to be a list")
        pulumi.set(__self__, "groups", groups)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if labels and not isinstance(labels, list):
            raise TypeError("Expected argument 'labels' to be a list")
        pulumi.set(__self__, "labels", labels)
        if last_modified_bies and not isinstance(last_modified_bies, list):
            raise TypeError("Expected argument 'last_modified_bies' to be a list")
        pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if last_modified_time and not isinstance(last_modified_time, int):
            raise TypeError("Expected argument 'last_modified_time' to be a int")
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        if location_groups and not isinstance(location_groups, list):
            raise TypeError("Expected argument 'location_groups' to be a list")
        pulumi.set(__self__, "location_groups", location_groups)
        if locations and not isinstance(locations, list):
            raise TypeError("Expected argument 'locations' to be a list")
        pulumi.set(__self__, "locations", locations)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if order and not isinstance(order, int):
            raise TypeError("Expected argument 'order' to be a int")
        pulumi.set(__self__, "order", order)
        if predefined and not isinstance(predefined, bool):
            raise TypeError("Expected argument 'predefined' to be a bool")
        pulumi.set(__self__, "predefined", predefined)
        if protocols and not isinstance(protocols, list):
            raise TypeError("Expected argument 'protocols' to be a list")
        pulumi.set(__self__, "protocols", protocols)
        if rank and not isinstance(rank, int):
            raise TypeError("Expected argument 'rank' to be a int")
        pulumi.set(__self__, "rank", rank)
        if redirect_ip and not isinstance(redirect_ip, str):
            raise TypeError("Expected argument 'redirect_ip' to be a str")
        pulumi.set(__self__, "redirect_ip", redirect_ip)
        if res_categories and not isinstance(res_categories, list):
            raise TypeError("Expected argument 'res_categories' to be a list")
        pulumi.set(__self__, "res_categories", res_categories)
        if source_countries and not isinstance(source_countries, list):
            raise TypeError("Expected argument 'source_countries' to be a list")
        pulumi.set(__self__, "source_countries", source_countries)
        if src_ip_groups and not isinstance(src_ip_groups, list):
            raise TypeError("Expected argument 'src_ip_groups' to be a list")
        pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips and not isinstance(src_ips, list):
            raise TypeError("Expected argument 'src_ips' to be a list")
        pulumi.set(__self__, "src_ips", src_ips)
        if src_ipv6_groups and not isinstance(src_ipv6_groups, list):
            raise TypeError("Expected argument 'src_ipv6_groups' to be a list")
        pulumi.set(__self__, "src_ipv6_groups", src_ipv6_groups)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if time_windows and not isinstance(time_windows, list):
            raise TypeError("Expected argument 'time_windows' to be a list")
        pulumi.set(__self__, "time_windows", time_windows)
        if users and not isinstance(users, list):
            raise TypeError("Expected argument 'users' to be a list")
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria, such as allowing or blocking the traffic or bypassing the rule. The following actions are accepted: `ALLOW`, `BLOCK`, `REDIR_REQ`, `REDIR_RES`, `REDIR_ZPA`, `REDIR_REQ_DOH`, `REDIR_REQ_KEEP_SENDER`, `REDIR_REQ_TCP`, `REDIR_REQ_UDP`, `BLOCK_WITH_RESPONSE`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="applicationGroups")
    def application_groups(self) -> Sequence['outputs.GetFirewallDNSRulesApplicationGroupResult']:
        """
        (List of Objects) DNS application groups to which the rule applies
        """
        return pulumi.get(self, "application_groups")

    @property
    @pulumi.getter
    def applications(self) -> Sequence[builtins.str]:
        """
        (Set of Strings) DNS tunnels and network applications to which the rule applies. To retrieve the available list of DNS tunnels applications use the data source: `get_cloud_applications` with the `app_class` value `DNS_OVER_HTTPS`. See example:
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> builtins.str:
        """
        (String) Specifies the DNS response code to be sent to the client when the action is configured to block and send response code. Supported values are: `ANY`, `NONE`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`, `YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADVERS`, `BADKEY`, `BADTIME`, `BADMODE`, `BADNAME`, `BADALG`, `BADTRUNC`, `UNSUPPORTED`, `BYPASS`, `INT_ERROR`, `SRV_TIMEOUT`, `EMPTY_RESP`,
        `REQ_BLOCKED`, `ADMIN_DROP`, `WCDN_TIMEOUT`, `IPS_BLOCK`, `FQDN_RESOLV_FAIL`
        """
        return pulumi.get(self, "block_response_code")

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> builtins.bool:
        """
        (Boolean) Value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> builtins.bool:
        """
        (Boolean) Value that indicates whether the rule is the Default Cloud DNS Rule or not
        """
        return pulumi.get(self, "default_rule")

    @property
    @pulumi.getter
    def departments(self) -> Sequence['outputs.GetFirewallDNSRulesDepartmentResult']:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Sequence[builtins.str]:
        """
        (Set of String) Destination IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific destination IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "dest_addresses")

    @property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Sequence[builtins.str]:
        """
        (Set of String) Identify destinations based on the location of a server, select Any to apply the rule to all countries or select the countries to which you want to control traffic.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "dest_countries")

    @property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Sequence[builtins.str]:
        """
        (Set of String)  identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        """
        return pulumi.get(self, "dest_ip_categories")

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Sequence['outputs.GetFirewallDNSRulesDestIpGroupResult']:
        """
        ** - (List of Objects) Any number of destination IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ip_groups")

    @property
    @pulumi.getter(name="destIpv6Groups")
    def dest_ipv6_groups(self) -> Sequence['outputs.GetFirewallDNSRulesDestIpv6GroupResult']:
        return pulumi.get(self, "dest_ipv6_groups")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Sequence['outputs.GetFirewallDNSRulesDeviceGroupResult']:
        """
        (List of Objects) Device groups to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetFirewallDNSRulesDeviceResult']:
        """
        (List of Objects) Devices to which the rule applies. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="dnsRuleRequestTypes")
    def dns_rule_request_types(self) -> Sequence[builtins.str]:
        """
        (Set of Strings) DNS request types to which the rule applies. Supportedn values are:
        `A`, `NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`, `HINFO`, `MINFO`, `MX`, `TXT`, `RP`, `AFSDB`,
        `X25`, `ISDN`, `RT`, `NSAP`, `NSAP_PTR`, `SIG`, `KEY`, `PX`, `GPOS`, `AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`,
        `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `APL`, `DS`, `SSHFP`, `PSECKEF`, `RRSIG`, `NSEC`, `DNSKEY`,
        `DHCID`, `NSEC3`, `NSEC3PARAM`, `TLSA`, `HIP`, `NINFO`, `RKEY`, `TALINK`, `CDS`, `CDNSKEY`, `OPENPGPKEY`, `CSYNC`,
        `ZONEMD`, `SVCB`, `HTTPS`,
        """
        return pulumi.get(self, "dns_rule_request_types")

    @property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetFirewallDNSRulesGroupResult']:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        (Integer) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetFirewallDNSRulesLabelResult']:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Sequence['outputs.GetFirewallDNSRulesLastModifiedByResult']:
        return pulumi.get(self, "last_modified_bies")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> builtins.int:
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Sequence['outputs.GetFirewallDNSRulesLocationGroupResult']:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetFirewallDNSRulesLocationResult']:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> builtins.int:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def predefined(self) -> builtins.bool:
        """
        (Boolean) A Boolean field that indicates that the rule is predefined by using a true value
        """
        return pulumi.get(self, "predefined")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[builtins.str]:
        """
        (Set of Strings) The protocols to which the rules applies. Supported Values: `ANY_RULE`, `SMRULEF_CASCADING_ALLOWED`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> builtins.int:
        """
        (Integer) By default, the admin ranking is disabled. To use this feature, you must enable admin rank. The default value is `7`.
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="redirectIp")
    def redirect_ip(self) -> builtins.str:
        """
        (String) The IP address to which the traffic will be redirected to when the DNAT rule is triggered. If not set, no redirection is done to specific IP addresses. Only supported when the `action` is `REDIR_REQ`
        """
        return pulumi.get(self, "redirect_ip")

    @property
    @pulumi.getter(name="resCategories")
    def res_categories(self) -> Sequence[builtins.str]:
        """
        (Set of String) URL categories associated with resolved IP addresses to which the rule applies. If not set, the rule is not restricted to a specific URL category.
        """
        return pulumi.get(self, "res_categories")

    @property
    @pulumi.getter(name="sourceCountries")
    def source_countries(self) -> Sequence[builtins.str]:
        """
        (Set of String) The countries of origin of traffic for which the rule is applicable. If not set, the rule is not restricted to specific source countries.
        **NOTE**: Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes). i.e ``"US"``, ``"CA"``
        """
        return pulumi.get(self, "source_countries")

    @property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Sequence['outputs.GetFirewallDNSRulesSrcIpGroupResult']:
        """
        (List of Objects)Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        """
        return pulumi.get(self, "src_ip_groups")

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Sequence[builtins.str]:
        """
        (Set of String) Source IP addresses or FQDNs to which the rule applies. If not set, the rule is not restricted to a specific source IP address. Each IP entry can be a single IP address, CIDR (e.g., 10.10.33.0/24), or an IP range (e.g., 10.10.33.1-10.10.33.10).
        """
        return pulumi.get(self, "src_ips")

    @property
    @pulumi.getter(name="srcIpv6Groups")
    def src_ipv6_groups(self) -> Sequence['outputs.GetFirewallDNSRulesSrcIpv6GroupResult']:
        """
        (List of Objects) Source IPv6 address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IPv6 address group.
        """
        return pulumi.get(self, "src_ipv6_groups")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        (String) An enabled rule is actively enforced. A disabled rule is not actively enforced but does not lose its place in the Rule Order. The service skips it and moves to the next rule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence['outputs.GetFirewallDNSRulesTimeWindowResult']:
        """
        (List of Objects) You can manually select up to `1` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetFirewallDNSRulesUserResult']:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")


class AwaitableGetFirewallDNSRulesResult(GetFirewallDNSRulesResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetFirewallDNSRulesResult(
            action=self.action,
            application_groups=self.application_groups,
            applications=self.applications,
            block_response_code=self.block_response_code,
            capture_pcap=self.capture_pcap,
            default_rule=self.default_rule,
            departments=self.departments,
            description=self.description,
            dest_addresses=self.dest_addresses,
            dest_countries=self.dest_countries,
            dest_ip_categories=self.dest_ip_categories,
            dest_ip_groups=self.dest_ip_groups,
            dest_ipv6_groups=self.dest_ipv6_groups,
            device_groups=self.device_groups,
            devices=self.devices,
            dns_rule_request_types=self.dns_rule_request_types,
            groups=self.groups,
            id=self.id,
            labels=self.labels,
            last_modified_bies=self.last_modified_bies,
            last_modified_time=self.last_modified_time,
            location_groups=self.location_groups,
            locations=self.locations,
            name=self.name,
            order=self.order,
            predefined=self.predefined,
            protocols=self.protocols,
            rank=self.rank,
            redirect_ip=self.redirect_ip,
            res_categories=self.res_categories,
            source_countries=self.source_countries,
            src_ip_groups=self.src_ip_groups,
            src_ips=self.src_ips,
            src_ipv6_groups=self.src_ipv6_groups,
            state=self.state,
            time_windows=self.time_windows,
            users=self.users)


def get_firewall_dns_rules(id: Optional[builtins.int] = None,
                           name: Optional[builtins.str] = None,
                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetFirewallDNSRulesResult:
    """
    * [Official documentation](https://help.zscaler.com/zia/configuring-dns-control-policy)
    * [API documentation](https://help.zscaler.com/zia/dns-control-policy#/firewallDnsRules-post)

    Use the **zia_firewall_dns_rule** data source to get information about a cloud firewall DNS rule available in the Zscaler Internet Access.

    ## Example Usage


    :param builtins.int id: Unique identifier for the Firewall Filtering policy rule
    :param builtins.str name: Name of the Firewall Filtering policy rule
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getFirewallDNSRules:getFirewallDNSRules', __args__, opts=opts, typ=GetFirewallDNSRulesResult).value

    return AwaitableGetFirewallDNSRulesResult(
        action=pulumi.get(__ret__, 'action'),
        application_groups=pulumi.get(__ret__, 'application_groups'),
        applications=pulumi.get(__ret__, 'applications'),
        block_response_code=pulumi.get(__ret__, 'block_response_code'),
        capture_pcap=pulumi.get(__ret__, 'capture_pcap'),
        default_rule=pulumi.get(__ret__, 'default_rule'),
        departments=pulumi.get(__ret__, 'departments'),
        description=pulumi.get(__ret__, 'description'),
        dest_addresses=pulumi.get(__ret__, 'dest_addresses'),
        dest_countries=pulumi.get(__ret__, 'dest_countries'),
        dest_ip_categories=pulumi.get(__ret__, 'dest_ip_categories'),
        dest_ip_groups=pulumi.get(__ret__, 'dest_ip_groups'),
        dest_ipv6_groups=pulumi.get(__ret__, 'dest_ipv6_groups'),
        device_groups=pulumi.get(__ret__, 'device_groups'),
        devices=pulumi.get(__ret__, 'devices'),
        dns_rule_request_types=pulumi.get(__ret__, 'dns_rule_request_types'),
        groups=pulumi.get(__ret__, 'groups'),
        id=pulumi.get(__ret__, 'id'),
        labels=pulumi.get(__ret__, 'labels'),
        last_modified_bies=pulumi.get(__ret__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__ret__, 'last_modified_time'),
        location_groups=pulumi.get(__ret__, 'location_groups'),
        locations=pulumi.get(__ret__, 'locations'),
        name=pulumi.get(__ret__, 'name'),
        order=pulumi.get(__ret__, 'order'),
        predefined=pulumi.get(__ret__, 'predefined'),
        protocols=pulumi.get(__ret__, 'protocols'),
        rank=pulumi.get(__ret__, 'rank'),
        redirect_ip=pulumi.get(__ret__, 'redirect_ip'),
        res_categories=pulumi.get(__ret__, 'res_categories'),
        source_countries=pulumi.get(__ret__, 'source_countries'),
        src_ip_groups=pulumi.get(__ret__, 'src_ip_groups'),
        src_ips=pulumi.get(__ret__, 'src_ips'),
        src_ipv6_groups=pulumi.get(__ret__, 'src_ipv6_groups'),
        state=pulumi.get(__ret__, 'state'),
        time_windows=pulumi.get(__ret__, 'time_windows'),
        users=pulumi.get(__ret__, 'users'))
def get_firewall_dns_rules_output(id: Optional[pulumi.Input[Optional[builtins.int]]] = None,
                                  name: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                                  opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetFirewallDNSRulesResult]:
    """
    * [Official documentation](https://help.zscaler.com/zia/configuring-dns-control-policy)
    * [API documentation](https://help.zscaler.com/zia/dns-control-policy#/firewallDnsRules-post)

    Use the **zia_firewall_dns_rule** data source to get information about a cloud firewall DNS rule available in the Zscaler Internet Access.

    ## Example Usage


    :param builtins.int id: Unique identifier for the Firewall Filtering policy rule
    :param builtins.str name: Name of the Firewall Filtering policy rule
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zia:index/getFirewallDNSRules:getFirewallDNSRules', __args__, opts=opts, typ=GetFirewallDNSRulesResult)
    return __ret__.apply(lambda __response__: GetFirewallDNSRulesResult(
        action=pulumi.get(__response__, 'action'),
        application_groups=pulumi.get(__response__, 'application_groups'),
        applications=pulumi.get(__response__, 'applications'),
        block_response_code=pulumi.get(__response__, 'block_response_code'),
        capture_pcap=pulumi.get(__response__, 'capture_pcap'),
        default_rule=pulumi.get(__response__, 'default_rule'),
        departments=pulumi.get(__response__, 'departments'),
        description=pulumi.get(__response__, 'description'),
        dest_addresses=pulumi.get(__response__, 'dest_addresses'),
        dest_countries=pulumi.get(__response__, 'dest_countries'),
        dest_ip_categories=pulumi.get(__response__, 'dest_ip_categories'),
        dest_ip_groups=pulumi.get(__response__, 'dest_ip_groups'),
        dest_ipv6_groups=pulumi.get(__response__, 'dest_ipv6_groups'),
        device_groups=pulumi.get(__response__, 'device_groups'),
        devices=pulumi.get(__response__, 'devices'),
        dns_rule_request_types=pulumi.get(__response__, 'dns_rule_request_types'),
        groups=pulumi.get(__response__, 'groups'),
        id=pulumi.get(__response__, 'id'),
        labels=pulumi.get(__response__, 'labels'),
        last_modified_bies=pulumi.get(__response__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__response__, 'last_modified_time'),
        location_groups=pulumi.get(__response__, 'location_groups'),
        locations=pulumi.get(__response__, 'locations'),
        name=pulumi.get(__response__, 'name'),
        order=pulumi.get(__response__, 'order'),
        predefined=pulumi.get(__response__, 'predefined'),
        protocols=pulumi.get(__response__, 'protocols'),
        rank=pulumi.get(__response__, 'rank'),
        redirect_ip=pulumi.get(__response__, 'redirect_ip'),
        res_categories=pulumi.get(__response__, 'res_categories'),
        source_countries=pulumi.get(__response__, 'source_countries'),
        src_ip_groups=pulumi.get(__response__, 'src_ip_groups'),
        src_ips=pulumi.get(__response__, 'src_ips'),
        src_ipv6_groups=pulumi.get(__response__, 'src_ipv6_groups'),
        state=pulumi.get(__response__, 'state'),
        time_windows=pulumi.get(__response__, 'time_windows'),
        users=pulumi.get(__response__, 'users')))

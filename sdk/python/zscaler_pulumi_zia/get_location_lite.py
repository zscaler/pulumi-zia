# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'GetLocationLiteResult',
    'AwaitableGetLocationLiteResult',
    'get_location_lite',
    'get_location_lite_output',
]

@pulumi.output_type
class GetLocationLiteResult:
    """
    A collection of values returned by getLocationLite.
    """
    def __init__(__self__, aup_block_internet_until_accepted=None, aup_enabled=None, aup_force_ssl_inspection=None, caution_enabled=None, digest_auth_enabled=None, ec_location=None, id=None, ips_control=None, ipv6_enabled=None, kerberos_auth=None, name=None, ofw_enabled=None, other6_sub_location=None, other_sub_location=None, parent_id=None, surrogate_ip=None, surrogate_ip_enforced_for_known_browsers=None, tz=None, xff_forward_enabled=None, zapp_ssl_scan_enabled=None):
        if aup_block_internet_until_accepted and not isinstance(aup_block_internet_until_accepted, bool):
            raise TypeError("Expected argument 'aup_block_internet_until_accepted' to be a bool")
        pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled and not isinstance(aup_enabled, bool):
            raise TypeError("Expected argument 'aup_enabled' to be a bool")
        pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection and not isinstance(aup_force_ssl_inspection, bool):
            raise TypeError("Expected argument 'aup_force_ssl_inspection' to be a bool")
        pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if caution_enabled and not isinstance(caution_enabled, bool):
            raise TypeError("Expected argument 'caution_enabled' to be a bool")
        pulumi.set(__self__, "caution_enabled", caution_enabled)
        if digest_auth_enabled and not isinstance(digest_auth_enabled, bool):
            raise TypeError("Expected argument 'digest_auth_enabled' to be a bool")
        pulumi.set(__self__, "digest_auth_enabled", digest_auth_enabled)
        if ec_location and not isinstance(ec_location, bool):
            raise TypeError("Expected argument 'ec_location' to be a bool")
        pulumi.set(__self__, "ec_location", ec_location)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if ips_control and not isinstance(ips_control, bool):
            raise TypeError("Expected argument 'ips_control' to be a bool")
        pulumi.set(__self__, "ips_control", ips_control)
        if ipv6_enabled and not isinstance(ipv6_enabled, bool):
            raise TypeError("Expected argument 'ipv6_enabled' to be a bool")
        pulumi.set(__self__, "ipv6_enabled", ipv6_enabled)
        if kerberos_auth and not isinstance(kerberos_auth, bool):
            raise TypeError("Expected argument 'kerberos_auth' to be a bool")
        pulumi.set(__self__, "kerberos_auth", kerberos_auth)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if ofw_enabled and not isinstance(ofw_enabled, bool):
            raise TypeError("Expected argument 'ofw_enabled' to be a bool")
        pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if other6_sub_location and not isinstance(other6_sub_location, bool):
            raise TypeError("Expected argument 'other6_sub_location' to be a bool")
        pulumi.set(__self__, "other6_sub_location", other6_sub_location)
        if other_sub_location and not isinstance(other_sub_location, bool):
            raise TypeError("Expected argument 'other_sub_location' to be a bool")
        pulumi.set(__self__, "other_sub_location", other_sub_location)
        if parent_id and not isinstance(parent_id, int):
            raise TypeError("Expected argument 'parent_id' to be a int")
        pulumi.set(__self__, "parent_id", parent_id)
        if surrogate_ip and not isinstance(surrogate_ip, bool):
            raise TypeError("Expected argument 'surrogate_ip' to be a bool")
        pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers and not isinstance(surrogate_ip_enforced_for_known_browsers, bool):
            raise TypeError("Expected argument 'surrogate_ip_enforced_for_known_browsers' to be a bool")
        pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if tz and not isinstance(tz, str):
            raise TypeError("Expected argument 'tz' to be a str")
        pulumi.set(__self__, "tz", tz)
        if xff_forward_enabled and not isinstance(xff_forward_enabled, bool):
            raise TypeError("Expected argument 'xff_forward_enabled' to be a bool")
        pulumi.set(__self__, "xff_forward_enabled", xff_forward_enabled)
        if zapp_ssl_scan_enabled and not isinstance(zapp_ssl_scan_enabled, bool):
            raise TypeError("Expected argument 'zapp_ssl_scan_enabled' to be a bool")
        pulumi.set(__self__, "zapp_ssl_scan_enabled", zapp_ssl_scan_enabled)

    @property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> bool:
        """
        (Boolean) For First Time AUP Behavior, Block Internet Access. When set, all internet access (including non-HTTP traffic) is disabled until the user accepts the AUP.
        """
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> bool:
        """
        (Boolean) Enable AUP. When set to true, AUP is enabled for the location.
        """
        return pulumi.get(self, "aup_enabled")

    @property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> bool:
        """
        (Boolean) For First Time AUP Behavior, Force SSL Inspection. When set, Zscaler will force SSL Inspection in order to enforce AUP for HTTPS traffic.
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> bool:
        """
        (Boolean) Enable Caution. When set to true, a caution notifcation is enabled for the location.
        """
        return pulumi.get(self, "caution_enabled")

    @property
    @pulumi.getter(name="digestAuthEnabled")
    def digest_auth_enabled(self) -> Optional[bool]:
        """
        (Boolean)
        """
        return pulumi.get(self, "digest_auth_enabled")

    @property
    @pulumi.getter(name="ecLocation")
    def ec_location(self) -> bool:
        """
        (Boolean)
        """
        return pulumi.get(self, "ec_location")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipsControl")
    def ips_control(self) -> bool:
        """
        (Boolean) Enable IPS Control. When set to true, IPS Control is enabled for the location if Firewall is enabled.
        """
        return pulumi.get(self, "ips_control")

    @property
    @pulumi.getter(name="ipv6Enabled")
    def ipv6_enabled(self) -> bool:
        """
        (Number) If set to true, IPv6 is enabled for the location and IPv6 traffic from the location can be forwarded to the Zscaler service to enforce security policies.
        """
        return pulumi.get(self, "ipv6_enabled")

    @property
    @pulumi.getter(name="kerberosAuth")
    def kerberos_auth(self) -> Optional[bool]:
        """
        (Boolean)
        """
        return pulumi.get(self, "kerberos_auth")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> bool:
        """
        (Boolean) Enable Firewall. When set to true, Firewall is enabled for the location.
        """
        return pulumi.get(self, "ofw_enabled")

    @property
    @pulumi.getter(name="other6SubLocation")
    def other6_sub_location(self) -> bool:
        """
        (Boolean) If set to true, indicates that this is a default sub-location created by the Zscaler service to accommodate IPv6 addresses that are not part of any user-defined sub-locations. The default sub-location is created with the name Other6 and it can be renamed, if required. This field is applicable only if ipv6Enabled is set is true
        """
        return pulumi.get(self, "other6_sub_location")

    @property
    @pulumi.getter(name="otherSubLocation")
    def other_sub_location(self) -> bool:
        """
        (Boolean) If set to true, indicates that this is a default sub-location created by the Zscaler service to accommodate IPv4 addresses that are not part of any user-defined sub-locations. The default sub-location is created with the name Other and it can be renamed, if required.
        """
        return pulumi.get(self, "other_sub_location")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> int:
        """
        (Number) - Parent Location ID. If this ID does not exist or is `0`, it is implied that it is a parent location. Otherwise, it is a sub-location whose parent has this ID. x-applicableTo: `SUB`
        """
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> bool:
        """
        (Boolean) Enable Surrogate IP. When set to true, users are mapped to internal device IP addresses.
        """
        return pulumi.get(self, "surrogate_ip")

    @property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> bool:
        """
        (Boolean) Enforce Surrogate IP for Known Browsers. When set to true, IP Surrogate is enforced for all known browsers.
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @property
    @pulumi.getter
    def tz(self) -> str:
        """
        (String) Timezone of the location. If not specified, it defaults to GMT.
        """
        return pulumi.get(self, "tz")

    @property
    @pulumi.getter(name="xffForwardEnabled")
    def xff_forward_enabled(self) -> bool:
        """
        (Boolean) Enable XFF Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        """
        return pulumi.get(self, "xff_forward_enabled")

    @property
    @pulumi.getter(name="zappSslScanEnabled")
    def zapp_ssl_scan_enabled(self) -> bool:
        """
        (Boolean) This parameter was deprecated and no longer has an effect on SSL policy. It remains supported in the API payload in order to maintain backwards compatibility with existing scripts, but it will be removed in future.
        """
        return pulumi.get(self, "zapp_ssl_scan_enabled")


class AwaitableGetLocationLiteResult(GetLocationLiteResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetLocationLiteResult(
            aup_block_internet_until_accepted=self.aup_block_internet_until_accepted,
            aup_enabled=self.aup_enabled,
            aup_force_ssl_inspection=self.aup_force_ssl_inspection,
            caution_enabled=self.caution_enabled,
            digest_auth_enabled=self.digest_auth_enabled,
            ec_location=self.ec_location,
            id=self.id,
            ips_control=self.ips_control,
            ipv6_enabled=self.ipv6_enabled,
            kerberos_auth=self.kerberos_auth,
            name=self.name,
            ofw_enabled=self.ofw_enabled,
            other6_sub_location=self.other6_sub_location,
            other_sub_location=self.other_sub_location,
            parent_id=self.parent_id,
            surrogate_ip=self.surrogate_ip,
            surrogate_ip_enforced_for_known_browsers=self.surrogate_ip_enforced_for_known_browsers,
            tz=self.tz,
            xff_forward_enabled=self.xff_forward_enabled,
            zapp_ssl_scan_enabled=self.zapp_ssl_scan_enabled)


def get_location_lite(digest_auth_enabled: Optional[bool] = None,
                      kerberos_auth: Optional[bool] = None,
                      name: Optional[str] = None,
                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetLocationLiteResult:
    """
    Use the **zia_location_lite** data source to get information about a location in lite mode option available in the Zscaler Internet Access. This data source can be used to retrieve the Road Warrior location to then associated with one of the following resources: ``URLFilteringRules``, ``FirewallFilteringRule`` and ``DLPWebRules`

    <!--Start PulumiCodeChooser -->
    ```python
    import pulumi
    import pulumi_zia as zia

    this = zia.get_location_lite(name="Road Warrior")
    ```
    <!--End PulumiCodeChooser -->


    :param bool digest_auth_enabled: (Boolean)
    :param bool kerberos_auth: (Boolean)
    :param str name: Location group name
    """
    __args__ = dict()
    __args__['digestAuthEnabled'] = digest_auth_enabled
    __args__['kerberosAuth'] = kerberos_auth
    __args__['name'] = name
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getLocationLite:getLocationLite', __args__, opts=opts, typ=GetLocationLiteResult).value

    return AwaitableGetLocationLiteResult(
        aup_block_internet_until_accepted=pulumi.get(__ret__, 'aup_block_internet_until_accepted'),
        aup_enabled=pulumi.get(__ret__, 'aup_enabled'),
        aup_force_ssl_inspection=pulumi.get(__ret__, 'aup_force_ssl_inspection'),
        caution_enabled=pulumi.get(__ret__, 'caution_enabled'),
        digest_auth_enabled=pulumi.get(__ret__, 'digest_auth_enabled'),
        ec_location=pulumi.get(__ret__, 'ec_location'),
        id=pulumi.get(__ret__, 'id'),
        ips_control=pulumi.get(__ret__, 'ips_control'),
        ipv6_enabled=pulumi.get(__ret__, 'ipv6_enabled'),
        kerberos_auth=pulumi.get(__ret__, 'kerberos_auth'),
        name=pulumi.get(__ret__, 'name'),
        ofw_enabled=pulumi.get(__ret__, 'ofw_enabled'),
        other6_sub_location=pulumi.get(__ret__, 'other6_sub_location'),
        other_sub_location=pulumi.get(__ret__, 'other_sub_location'),
        parent_id=pulumi.get(__ret__, 'parent_id'),
        surrogate_ip=pulumi.get(__ret__, 'surrogate_ip'),
        surrogate_ip_enforced_for_known_browsers=pulumi.get(__ret__, 'surrogate_ip_enforced_for_known_browsers'),
        tz=pulumi.get(__ret__, 'tz'),
        xff_forward_enabled=pulumi.get(__ret__, 'xff_forward_enabled'),
        zapp_ssl_scan_enabled=pulumi.get(__ret__, 'zapp_ssl_scan_enabled'))


@_utilities.lift_output_func(get_location_lite)
def get_location_lite_output(digest_auth_enabled: Optional[pulumi.Input[Optional[bool]]] = None,
                             kerberos_auth: Optional[pulumi.Input[Optional[bool]]] = None,
                             name: Optional[pulumi.Input[Optional[str]]] = None,
                             opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetLocationLiteResult]:
    """
    Use the **zia_location_lite** data source to get information about a location in lite mode option available in the Zscaler Internet Access. This data source can be used to retrieve the Road Warrior location to then associated with one of the following resources: ``URLFilteringRules``, ``FirewallFilteringRule`` and ``DLPWebRules`

    <!--Start PulumiCodeChooser -->
    ```python
    import pulumi
    import pulumi_zia as zia

    this = zia.get_location_lite(name="Road Warrior")
    ```
    <!--End PulumiCodeChooser -->


    :param bool digest_auth_enabled: (Boolean)
    :param bool kerberos_auth: (Boolean)
    :param str name: Location group name
    """
    ...

# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['FileTypeControlRulesArgs', 'FileTypeControlRules']

@pulumi.input_type
class FileTypeControlRulesArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[builtins.int],
                 protocols: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 active_content: Optional[pulumi.Input[builtins.bool]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input['FileTypeControlRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input['FileTypeControlRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['FileTypeControlRulesDevicesArgs']] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filtering_action: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input['FileTypeControlRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['FileTypeControlRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['FileTypeControlRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['FileTypeControlRulesLocationsArgs']] = None,
                 max_size: Optional[pulumi.Input[builtins.int]] = None,
                 min_size: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['FileTypeControlRulesTimeWindowsArgs']] = None,
                 unscannable: Optional[pulumi.Input[builtins.bool]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['FileTypeControlRulesUsersArgs']] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]]] = None):
        """
        The set of arguments for constructing a FileTypeControlRules resource.
        :param pulumi.Input[builtins.int] order: The rule order of execution for the File Type Control rule with respect to other rules.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.bool] active_content: Flag to check whether a file has active content or not
        :param pulumi.Input[builtins.bool] capture_pcap: A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: The list of cloud applications to which the File Type Control rule must be applied.
        :param pulumi.Input['FileTypeControlRulesDepartmentsArgs'] departments: The Name-ID pairs of departments to which the File Type Control rule must be applied.
        :param pulumi.Input[builtins.str] description: The description of the File Type Control rule.
        :param pulumi.Input['FileTypeControlRulesDeviceGroupsArgs'] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['FileTypeControlRulesDevicesArgs'] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.str] filtering_action: Action taken when traffic matches policy. This field is not applicable to the Lite API.
        :param pulumi.Input['FileTypeControlRulesGroupsArgs'] groups: The Name-ID pairs of groups to which the File Type Control rule must be applied.
        :param pulumi.Input['FileTypeControlRulesLabelsArgs'] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input['FileTypeControlRulesLocationGroupsArgs'] location_groups: Name-ID pairs of locations groups for which rule must be applied.
        :param pulumi.Input['FileTypeControlRulesLocationsArgs'] locations: Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        :param pulumi.Input[builtins.int] max_size: Maximum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.int] min_size: Minimum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.str] operation: File operation performed. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[builtins.str] state: Enables or disables the File Type Control rule.
        :param pulumi.Input['FileTypeControlRulesTimeWindowsArgs'] time_windows: list of time interval during which rule must be enforced.
        :param pulumi.Input[builtins.bool] unscannable: Flag to check whether a file has active content or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input['FileTypeControlRulesUsersArgs'] users: The Name-ID pairs of users to which the File Type Control rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]] zpa_app_segments: List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "protocols", protocols)
        if active_content is not None:
            pulumi.set(__self__, "active_content", active_content)
        if capture_pcap is not None:
            pulumi.set(__self__, "capture_pcap", capture_pcap)
        if cloud_applications is not None:
            pulumi.set(__self__, "cloud_applications", cloud_applications)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if filtering_action is not None:
            pulumi.set(__self__, "filtering_action", filtering_action)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if unscannable is not None:
            pulumi.set(__self__, "unscannable", unscannable)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if zpa_app_segments is not None:
            pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[builtins.int]:
        """
        The rule order of execution for the File Type Control rule with respect to other rules.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Protocol for the given rule. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="activeContent")
    def active_content(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to check whether a file has active content or not
        """
        return pulumi.get(self, "active_content")

    @active_content.setter
    def active_content(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active_content", value)

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @capture_pcap.setter
    def capture_pcap(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "capture_pcap", value)

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of cloud applications to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "cloud_applications")

    @cloud_applications.setter
    def cloud_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "cloud_applications", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['FileTypeControlRulesDepartmentsArgs']]:
        """
        The Name-ID pairs of departments to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['FileTypeControlRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the File Type Control rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['FileTypeControlRulesDeviceGroupsArgs']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['FileTypeControlRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['FileTypeControlRulesDevicesArgs']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['FileTypeControlRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "file_types", value)

    @property
    @pulumi.getter(name="filteringAction")
    def filtering_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Action taken when traffic matches policy. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "filtering_action")

    @filtering_action.setter
    def filtering_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filtering_action", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['FileTypeControlRulesGroupsArgs']]:
        """
        The Name-ID pairs of groups to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['FileTypeControlRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['FileTypeControlRulesLabelsArgs']]:
        """
        list of Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['FileTypeControlRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['FileTypeControlRulesLocationGroupsArgs']]:
        """
        Name-ID pairs of locations groups for which rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['FileTypeControlRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['FileTypeControlRulesLocationsArgs']]:
        """
        Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['FileTypeControlRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum file size (in KB) used for evaluation of the FTP rule
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum file size (in KB) used for evaluation of the FTP rule
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_size", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The File Type Control policy rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File operation performed. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Admin rank of the admin who creates this rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enables or disables the File Type Control rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['FileTypeControlRulesTimeWindowsArgs']]:
        """
        list of time interval during which rule must be enforced.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['FileTypeControlRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter
    def unscannable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to check whether a file has active content or not
        """
        return pulumi.get(self, "unscannable")

    @unscannable.setter
    def unscannable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unscannable", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['FileTypeControlRulesUsersArgs']]:
        """
        The Name-ID pairs of users to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['FileTypeControlRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]]]:
        """
        List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        return pulumi.get(self, "zpa_app_segments")

    @zpa_app_segments.setter
    def zpa_app_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]]]):
        pulumi.set(self, "zpa_app_segments", value)


@pulumi.input_type
class _FileTypeControlRulesState:
    def __init__(__self__, *,
                 active_content: Optional[pulumi.Input[builtins.bool]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input['FileTypeControlRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input['FileTypeControlRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['FileTypeControlRulesDevicesArgs']] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filtering_action: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input['FileTypeControlRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['FileTypeControlRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['FileTypeControlRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['FileTypeControlRulesLocationsArgs']] = None,
                 max_size: Optional[pulumi.Input[builtins.int]] = None,
                 min_size: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 rule_id: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['FileTypeControlRulesTimeWindowsArgs']] = None,
                 unscannable: Optional[pulumi.Input[builtins.bool]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['FileTypeControlRulesUsersArgs']] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]]] = None):
        """
        Input properties used for looking up and filtering FileTypeControlRules resources.
        :param pulumi.Input[builtins.bool] active_content: Flag to check whether a file has active content or not
        :param pulumi.Input[builtins.bool] capture_pcap: A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: The list of cloud applications to which the File Type Control rule must be applied.
        :param pulumi.Input['FileTypeControlRulesDepartmentsArgs'] departments: The Name-ID pairs of departments to which the File Type Control rule must be applied.
        :param pulumi.Input[builtins.str] description: The description of the File Type Control rule.
        :param pulumi.Input['FileTypeControlRulesDeviceGroupsArgs'] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['FileTypeControlRulesDevicesArgs'] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.str] filtering_action: Action taken when traffic matches policy. This field is not applicable to the Lite API.
        :param pulumi.Input['FileTypeControlRulesGroupsArgs'] groups: The Name-ID pairs of groups to which the File Type Control rule must be applied.
        :param pulumi.Input['FileTypeControlRulesLabelsArgs'] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input['FileTypeControlRulesLocationGroupsArgs'] location_groups: Name-ID pairs of locations groups for which rule must be applied.
        :param pulumi.Input['FileTypeControlRulesLocationsArgs'] locations: Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        :param pulumi.Input[builtins.int] max_size: Maximum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.int] min_size: Minimum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.str] operation: File operation performed. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] order: The rule order of execution for the File Type Control rule with respect to other rules.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[builtins.str] state: Enables or disables the File Type Control rule.
        :param pulumi.Input['FileTypeControlRulesTimeWindowsArgs'] time_windows: list of time interval during which rule must be enforced.
        :param pulumi.Input[builtins.bool] unscannable: Flag to check whether a file has active content or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input['FileTypeControlRulesUsersArgs'] users: The Name-ID pairs of users to which the File Type Control rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]] zpa_app_segments: List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        if active_content is not None:
            pulumi.set(__self__, "active_content", active_content)
        if capture_pcap is not None:
            pulumi.set(__self__, "capture_pcap", capture_pcap)
        if cloud_applications is not None:
            pulumi.set(__self__, "cloud_applications", cloud_applications)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if filtering_action is not None:
            pulumi.set(__self__, "filtering_action", filtering_action)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if unscannable is not None:
            pulumi.set(__self__, "unscannable", unscannable)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if zpa_app_segments is not None:
            pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter(name="activeContent")
    def active_content(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to check whether a file has active content or not
        """
        return pulumi.get(self, "active_content")

    @active_content.setter
    def active_content(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active_content", value)

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @capture_pcap.setter
    def capture_pcap(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "capture_pcap", value)

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of cloud applications to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "cloud_applications")

    @cloud_applications.setter
    def cloud_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "cloud_applications", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['FileTypeControlRulesDepartmentsArgs']]:
        """
        The Name-ID pairs of departments to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['FileTypeControlRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the File Type Control rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['FileTypeControlRulesDeviceGroupsArgs']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['FileTypeControlRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['FileTypeControlRulesDevicesArgs']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['FileTypeControlRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "file_types", value)

    @property
    @pulumi.getter(name="filteringAction")
    def filtering_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Action taken when traffic matches policy. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "filtering_action")

    @filtering_action.setter
    def filtering_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filtering_action", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['FileTypeControlRulesGroupsArgs']]:
        """
        The Name-ID pairs of groups to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['FileTypeControlRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['FileTypeControlRulesLabelsArgs']]:
        """
        list of Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['FileTypeControlRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['FileTypeControlRulesLocationGroupsArgs']]:
        """
        Name-ID pairs of locations groups for which rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['FileTypeControlRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['FileTypeControlRulesLocationsArgs']]:
        """
        Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['FileTypeControlRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum file size (in KB) used for evaluation of the FTP rule
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum file size (in KB) used for evaluation of the FTP rule
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_size", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The File Type Control policy rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File operation performed. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The rule order of execution for the File Type Control rule with respect to other rules.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Protocol for the given rule. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Admin rank of the admin who creates this rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enables or disables the File Type Control rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['FileTypeControlRulesTimeWindowsArgs']]:
        """
        list of time interval during which rule must be enforced.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['FileTypeControlRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter
    def unscannable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to check whether a file has active content or not
        """
        return pulumi.get(self, "unscannable")

    @unscannable.setter
    def unscannable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unscannable", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['FileTypeControlRulesUsersArgs']]:
        """
        The Name-ID pairs of users to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['FileTypeControlRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]]]:
        """
        List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        return pulumi.get(self, "zpa_app_segments")

    @zpa_app_segments.setter
    def zpa_app_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FileTypeControlRulesZpaAppSegmentArgs']]]]):
        pulumi.set(self, "zpa_app_segments", value)


@pulumi.type_token("zia:index/fileTypeControlRules:FileTypeControlRules")
class FileTypeControlRules(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active_content: Optional[pulumi.Input[builtins.bool]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input[Union['FileTypeControlRulesDepartmentsArgs', 'FileTypeControlRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input[Union['FileTypeControlRulesDeviceGroupsArgs', 'FileTypeControlRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['FileTypeControlRulesDevicesArgs', 'FileTypeControlRulesDevicesArgsDict']]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filtering_action: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input[Union['FileTypeControlRulesGroupsArgs', 'FileTypeControlRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['FileTypeControlRulesLabelsArgs', 'FileTypeControlRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['FileTypeControlRulesLocationGroupsArgs', 'FileTypeControlRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['FileTypeControlRulesLocationsArgs', 'FileTypeControlRulesLocationsArgsDict']]] = None,
                 max_size: Optional[pulumi.Input[builtins.int]] = None,
                 min_size: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['FileTypeControlRulesTimeWindowsArgs', 'FileTypeControlRulesTimeWindowsArgsDict']]] = None,
                 unscannable: Optional[pulumi.Input[builtins.bool]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['FileTypeControlRulesUsersArgs', 'FileTypeControlRulesUsersArgsDict']]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FileTypeControlRulesZpaAppSegmentArgs', 'FileTypeControlRulesZpaAppSegmentArgsDict']]]]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-file-type-control)
        * [API documentation](https://help.zscaler.com/zia/file-type-control-policy#/fileTypeRules-post)

        The **zia_file_type_control_rules** resource allows the creation and management of ZIA file type control rules in the Zscaler Internet Access.

        ## Example Usage

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        **zia_file_type_control_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/fileTypeControlRules:FileTypeControlRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/fileTypeControlRules:FileTypeControlRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] active_content: Flag to check whether a file has active content or not
        :param pulumi.Input[builtins.bool] capture_pcap: A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: The list of cloud applications to which the File Type Control rule must be applied.
        :param pulumi.Input[Union['FileTypeControlRulesDepartmentsArgs', 'FileTypeControlRulesDepartmentsArgsDict']] departments: The Name-ID pairs of departments to which the File Type Control rule must be applied.
        :param pulumi.Input[builtins.str] description: The description of the File Type Control rule.
        :param pulumi.Input[Union['FileTypeControlRulesDeviceGroupsArgs', 'FileTypeControlRulesDeviceGroupsArgsDict']] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['FileTypeControlRulesDevicesArgs', 'FileTypeControlRulesDevicesArgsDict']] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.str] filtering_action: Action taken when traffic matches policy. This field is not applicable to the Lite API.
        :param pulumi.Input[Union['FileTypeControlRulesGroupsArgs', 'FileTypeControlRulesGroupsArgsDict']] groups: The Name-ID pairs of groups to which the File Type Control rule must be applied.
        :param pulumi.Input[Union['FileTypeControlRulesLabelsArgs', 'FileTypeControlRulesLabelsArgsDict']] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input[Union['FileTypeControlRulesLocationGroupsArgs', 'FileTypeControlRulesLocationGroupsArgsDict']] location_groups: Name-ID pairs of locations groups for which rule must be applied.
        :param pulumi.Input[Union['FileTypeControlRulesLocationsArgs', 'FileTypeControlRulesLocationsArgsDict']] locations: Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        :param pulumi.Input[builtins.int] max_size: Maximum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.int] min_size: Minimum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.str] operation: File operation performed. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] order: The rule order of execution for the File Type Control rule with respect to other rules.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[builtins.str] state: Enables or disables the File Type Control rule.
        :param pulumi.Input[Union['FileTypeControlRulesTimeWindowsArgs', 'FileTypeControlRulesTimeWindowsArgsDict']] time_windows: list of time interval during which rule must be enforced.
        :param pulumi.Input[builtins.bool] unscannable: Flag to check whether a file has active content or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[Union['FileTypeControlRulesUsersArgs', 'FileTypeControlRulesUsersArgsDict']] users: The Name-ID pairs of users to which the File Type Control rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FileTypeControlRulesZpaAppSegmentArgs', 'FileTypeControlRulesZpaAppSegmentArgsDict']]]] zpa_app_segments: List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: FileTypeControlRulesArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-file-type-control)
        * [API documentation](https://help.zscaler.com/zia/file-type-control-policy#/fileTypeRules-post)

        The **zia_file_type_control_rules** resource allows the creation and management of ZIA file type control rules in the Zscaler Internet Access.

        ## Example Usage

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        **zia_file_type_control_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/fileTypeControlRules:FileTypeControlRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/fileTypeControlRules:FileTypeControlRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param FileTypeControlRulesArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(FileTypeControlRulesArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active_content: Optional[pulumi.Input[builtins.bool]] = None,
                 capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input[Union['FileTypeControlRulesDepartmentsArgs', 'FileTypeControlRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input[Union['FileTypeControlRulesDeviceGroupsArgs', 'FileTypeControlRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['FileTypeControlRulesDevicesArgs', 'FileTypeControlRulesDevicesArgsDict']]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filtering_action: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input[Union['FileTypeControlRulesGroupsArgs', 'FileTypeControlRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['FileTypeControlRulesLabelsArgs', 'FileTypeControlRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['FileTypeControlRulesLocationGroupsArgs', 'FileTypeControlRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['FileTypeControlRulesLocationsArgs', 'FileTypeControlRulesLocationsArgsDict']]] = None,
                 max_size: Optional[pulumi.Input[builtins.int]] = None,
                 min_size: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['FileTypeControlRulesTimeWindowsArgs', 'FileTypeControlRulesTimeWindowsArgsDict']]] = None,
                 unscannable: Optional[pulumi.Input[builtins.bool]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['FileTypeControlRulesUsersArgs', 'FileTypeControlRulesUsersArgsDict']]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FileTypeControlRulesZpaAppSegmentArgs', 'FileTypeControlRulesZpaAppSegmentArgsDict']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = FileTypeControlRulesArgs.__new__(FileTypeControlRulesArgs)

            __props__.__dict__["active_content"] = active_content
            __props__.__dict__["capture_pcap"] = capture_pcap
            __props__.__dict__["cloud_applications"] = cloud_applications
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            __props__.__dict__["device_groups"] = device_groups
            __props__.__dict__["device_trust_levels"] = device_trust_levels
            __props__.__dict__["devices"] = devices
            __props__.__dict__["file_types"] = file_types
            __props__.__dict__["filtering_action"] = filtering_action
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["max_size"] = max_size
            __props__.__dict__["min_size"] = min_size
            __props__.__dict__["name"] = name
            __props__.__dict__["operation"] = operation
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            if protocols is None and not opts.urn:
                raise TypeError("Missing required property 'protocols'")
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["rank"] = rank
            __props__.__dict__["state"] = state
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["unscannable"] = unscannable
            __props__.__dict__["url_categories"] = url_categories
            __props__.__dict__["users"] = users
            __props__.__dict__["zpa_app_segments"] = zpa_app_segments
            __props__.__dict__["rule_id"] = None
        super(FileTypeControlRules, __self__).__init__(
            'zia:index/fileTypeControlRules:FileTypeControlRules',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            active_content: Optional[pulumi.Input[builtins.bool]] = None,
            capture_pcap: Optional[pulumi.Input[builtins.bool]] = None,
            cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            departments: Optional[pulumi.Input[Union['FileTypeControlRulesDepartmentsArgs', 'FileTypeControlRulesDepartmentsArgsDict']]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            device_groups: Optional[pulumi.Input[Union['FileTypeControlRulesDeviceGroupsArgs', 'FileTypeControlRulesDeviceGroupsArgsDict']]] = None,
            device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            devices: Optional[pulumi.Input[Union['FileTypeControlRulesDevicesArgs', 'FileTypeControlRulesDevicesArgsDict']]] = None,
            file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            filtering_action: Optional[pulumi.Input[builtins.str]] = None,
            groups: Optional[pulumi.Input[Union['FileTypeControlRulesGroupsArgs', 'FileTypeControlRulesGroupsArgsDict']]] = None,
            labels: Optional[pulumi.Input[Union['FileTypeControlRulesLabelsArgs', 'FileTypeControlRulesLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['FileTypeControlRulesLocationGroupsArgs', 'FileTypeControlRulesLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['FileTypeControlRulesLocationsArgs', 'FileTypeControlRulesLocationsArgsDict']]] = None,
            max_size: Optional[pulumi.Input[builtins.int]] = None,
            min_size: Optional[pulumi.Input[builtins.int]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            operation: Optional[pulumi.Input[builtins.str]] = None,
            order: Optional[pulumi.Input[builtins.int]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            rank: Optional[pulumi.Input[builtins.int]] = None,
            rule_id: Optional[pulumi.Input[builtins.int]] = None,
            state: Optional[pulumi.Input[builtins.str]] = None,
            time_windows: Optional[pulumi.Input[Union['FileTypeControlRulesTimeWindowsArgs', 'FileTypeControlRulesTimeWindowsArgsDict']]] = None,
            unscannable: Optional[pulumi.Input[builtins.bool]] = None,
            url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            users: Optional[pulumi.Input[Union['FileTypeControlRulesUsersArgs', 'FileTypeControlRulesUsersArgsDict']]] = None,
            zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FileTypeControlRulesZpaAppSegmentArgs', 'FileTypeControlRulesZpaAppSegmentArgsDict']]]]] = None) -> 'FileTypeControlRules':
        """
        Get an existing FileTypeControlRules resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] active_content: Flag to check whether a file has active content or not
        :param pulumi.Input[builtins.bool] capture_pcap: A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: The list of cloud applications to which the File Type Control rule must be applied.
        :param pulumi.Input[Union['FileTypeControlRulesDepartmentsArgs', 'FileTypeControlRulesDepartmentsArgsDict']] departments: The Name-ID pairs of departments to which the File Type Control rule must be applied.
        :param pulumi.Input[builtins.str] description: The description of the File Type Control rule.
        :param pulumi.Input[Union['FileTypeControlRulesDeviceGroupsArgs', 'FileTypeControlRulesDeviceGroupsArgsDict']] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['FileTypeControlRulesDevicesArgs', 'FileTypeControlRulesDevicesArgsDict']] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.str] filtering_action: Action taken when traffic matches policy. This field is not applicable to the Lite API.
        :param pulumi.Input[Union['FileTypeControlRulesGroupsArgs', 'FileTypeControlRulesGroupsArgsDict']] groups: The Name-ID pairs of groups to which the File Type Control rule must be applied.
        :param pulumi.Input[Union['FileTypeControlRulesLabelsArgs', 'FileTypeControlRulesLabelsArgsDict']] labels: list of Labels that are applicable to the rule.
        :param pulumi.Input[Union['FileTypeControlRulesLocationGroupsArgs', 'FileTypeControlRulesLocationGroupsArgsDict']] location_groups: Name-ID pairs of locations groups for which rule must be applied.
        :param pulumi.Input[Union['FileTypeControlRulesLocationsArgs', 'FileTypeControlRulesLocationsArgsDict']] locations: Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        :param pulumi.Input[builtins.int] max_size: Maximum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.int] min_size: Minimum file size (in KB) used for evaluation of the FTP rule
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.str] operation: File operation performed. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] order: The rule order of execution for the File Type Control rule with respect to other rules.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[builtins.str] state: Enables or disables the File Type Control rule.
        :param pulumi.Input[Union['FileTypeControlRulesTimeWindowsArgs', 'FileTypeControlRulesTimeWindowsArgsDict']] time_windows: list of time interval during which rule must be enforced.
        :param pulumi.Input[builtins.bool] unscannable: Flag to check whether a file has active content or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[Union['FileTypeControlRulesUsersArgs', 'FileTypeControlRulesUsersArgsDict']] users: The Name-ID pairs of users to which the File Type Control rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FileTypeControlRulesZpaAppSegmentArgs', 'FileTypeControlRulesZpaAppSegmentArgsDict']]]] zpa_app_segments: List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _FileTypeControlRulesState.__new__(_FileTypeControlRulesState)

        __props__.__dict__["active_content"] = active_content
        __props__.__dict__["capture_pcap"] = capture_pcap
        __props__.__dict__["cloud_applications"] = cloud_applications
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["device_groups"] = device_groups
        __props__.__dict__["device_trust_levels"] = device_trust_levels
        __props__.__dict__["devices"] = devices
        __props__.__dict__["file_types"] = file_types
        __props__.__dict__["filtering_action"] = filtering_action
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["max_size"] = max_size
        __props__.__dict__["min_size"] = min_size
        __props__.__dict__["name"] = name
        __props__.__dict__["operation"] = operation
        __props__.__dict__["order"] = order
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["rank"] = rank
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["state"] = state
        __props__.__dict__["time_windows"] = time_windows
        __props__.__dict__["unscannable"] = unscannable
        __props__.__dict__["url_categories"] = url_categories
        __props__.__dict__["users"] = users
        __props__.__dict__["zpa_app_segments"] = zpa_app_segments
        return FileTypeControlRules(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="activeContent")
    def active_content(self) -> pulumi.Output[builtins.bool]:
        """
        Flag to check whether a file has active content or not
        """
        return pulumi.get(self, "active_content")

    @property
    @pulumi.getter(name="capturePcap")
    def capture_pcap(self) -> pulumi.Output[builtins.bool]:
        """
        A Boolean value that indicates whether packet capture (PCAP) is enabled or not
        """
        return pulumi.get(self, "capture_pcap")

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        The list of cloud applications to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "cloud_applications")

    @property
    @pulumi.getter
    def departments(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesDepartments']]:
        """
        The Name-ID pairs of departments to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        The description of the File Type Control rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesDeviceGroups']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @property
    @pulumi.getter
    def devices(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesDevices']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        """
        return pulumi.get(self, "file_types")

    @property
    @pulumi.getter(name="filteringAction")
    def filtering_action(self) -> pulumi.Output[builtins.str]:
        """
        Action taken when traffic matches policy. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "filtering_action")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesGroups']]:
        """
        The Name-ID pairs of groups to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesLabels']]:
        """
        list of Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesLocationGroups']]:
        """
        Name-ID pairs of locations groups for which rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesLocations']]:
        """
        Name-ID pairs of locations for the which policy must be applied. If not set, policy is applied for all locations.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Output[builtins.int]:
        """
        Maximum file size (in KB) used for evaluation of the FTP rule
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> pulumi.Output[builtins.int]:
        """
        Minimum file size (in KB) used for evaluation of the FTP rule
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        The File Type Control policy rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Output[builtins.str]:
        """
        File operation performed. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def order(self) -> pulumi.Output[builtins.int]:
        """
        The rule order of execution for the File Type Control rule with respect to other rules.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Protocol for the given rule. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> pulumi.Output[builtins.int]:
        """
        Admin rank of the admin who creates this rule
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[builtins.int]:
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[builtins.str]:
        """
        Enables or disables the File Type Control rule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesTimeWindows']]:
        """
        list of time interval during which rule must be enforced.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter
    def unscannable(self) -> pulumi.Output[builtins.bool]:
        """
        Flag to check whether a file has active content or not
        """
        return pulumi.get(self, "unscannable")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter
    def users(self) -> pulumi.Output[Optional['outputs.FileTypeControlRulesUsers']]:
        """
        The Name-ID pairs of users to which the File Type Control rule must be applied.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> pulumi.Output[Sequence['outputs.FileTypeControlRulesZpaAppSegment']]:
        """
        List of Source IP Anchoring-enabled ZPA Application Segments for which this rule is applicable
        """
        return pulumi.get(self, "zpa_app_segments")


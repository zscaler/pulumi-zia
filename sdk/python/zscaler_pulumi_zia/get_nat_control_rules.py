# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetNatControlRulesResult',
    'AwaitableGetNatControlRulesResult',
    'get_nat_control_rules',
    'get_nat_control_rules_output',
]

@pulumi.output_type
class GetNatControlRulesResult:
    """
    A collection of values returned by getNatControlRules.
    """
    def __init__(__self__, default_rule=None, departments=None, description=None, dest_addresses=None, dest_countries=None, dest_ip_categories=None, dest_ip_groups=None, dest_ipv6_groups=None, device_groups=None, devices=None, enable_full_logging=None, groups=None, id=None, labels=None, last_modified_bies=None, last_modified_time=None, location_groups=None, locations=None, name=None, nw_service_groups=None, nw_services=None, order=None, predefined=None, rank=None, redirect_fqdn=None, redirect_ip=None, redirect_port=None, res_categories=None, src_ip_groups=None, src_ips=None, src_ipv6_groups=None, state=None, time_windows=None, users=None):
        if default_rule and not isinstance(default_rule, bool):
            raise TypeError("Expected argument 'default_rule' to be a bool")
        pulumi.set(__self__, "default_rule", default_rule)
        if departments and not isinstance(departments, list):
            raise TypeError("Expected argument 'departments' to be a list")
        pulumi.set(__self__, "departments", departments)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if dest_addresses and not isinstance(dest_addresses, list):
            raise TypeError("Expected argument 'dest_addresses' to be a list")
        pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries and not isinstance(dest_countries, list):
            raise TypeError("Expected argument 'dest_countries' to be a list")
        pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories and not isinstance(dest_ip_categories, list):
            raise TypeError("Expected argument 'dest_ip_categories' to be a list")
        pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups and not isinstance(dest_ip_groups, list):
            raise TypeError("Expected argument 'dest_ip_groups' to be a list")
        pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if dest_ipv6_groups and not isinstance(dest_ipv6_groups, list):
            raise TypeError("Expected argument 'dest_ipv6_groups' to be a list")
        pulumi.set(__self__, "dest_ipv6_groups", dest_ipv6_groups)
        if device_groups and not isinstance(device_groups, list):
            raise TypeError("Expected argument 'device_groups' to be a list")
        pulumi.set(__self__, "device_groups", device_groups)
        if devices and not isinstance(devices, list):
            raise TypeError("Expected argument 'devices' to be a list")
        pulumi.set(__self__, "devices", devices)
        if enable_full_logging and not isinstance(enable_full_logging, bool):
            raise TypeError("Expected argument 'enable_full_logging' to be a bool")
        pulumi.set(__self__, "enable_full_logging", enable_full_logging)
        if groups and not isinstance(groups, list):
            raise TypeError("Expected argument 'groups' to be a list")
        pulumi.set(__self__, "groups", groups)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if labels and not isinstance(labels, list):
            raise TypeError("Expected argument 'labels' to be a list")
        pulumi.set(__self__, "labels", labels)
        if last_modified_bies and not isinstance(last_modified_bies, list):
            raise TypeError("Expected argument 'last_modified_bies' to be a list")
        pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if last_modified_time and not isinstance(last_modified_time, int):
            raise TypeError("Expected argument 'last_modified_time' to be a int")
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        if location_groups and not isinstance(location_groups, list):
            raise TypeError("Expected argument 'location_groups' to be a list")
        pulumi.set(__self__, "location_groups", location_groups)
        if locations and not isinstance(locations, list):
            raise TypeError("Expected argument 'locations' to be a list")
        pulumi.set(__self__, "locations", locations)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if nw_service_groups and not isinstance(nw_service_groups, list):
            raise TypeError("Expected argument 'nw_service_groups' to be a list")
        pulumi.set(__self__, "nw_service_groups", nw_service_groups)
        if nw_services and not isinstance(nw_services, list):
            raise TypeError("Expected argument 'nw_services' to be a list")
        pulumi.set(__self__, "nw_services", nw_services)
        if order and not isinstance(order, int):
            raise TypeError("Expected argument 'order' to be a int")
        pulumi.set(__self__, "order", order)
        if predefined and not isinstance(predefined, bool):
            raise TypeError("Expected argument 'predefined' to be a bool")
        pulumi.set(__self__, "predefined", predefined)
        if rank and not isinstance(rank, int):
            raise TypeError("Expected argument 'rank' to be a int")
        pulumi.set(__self__, "rank", rank)
        if redirect_fqdn and not isinstance(redirect_fqdn, str):
            raise TypeError("Expected argument 'redirect_fqdn' to be a str")
        pulumi.set(__self__, "redirect_fqdn", redirect_fqdn)
        if redirect_ip and not isinstance(redirect_ip, str):
            raise TypeError("Expected argument 'redirect_ip' to be a str")
        pulumi.set(__self__, "redirect_ip", redirect_ip)
        if redirect_port and not isinstance(redirect_port, int):
            raise TypeError("Expected argument 'redirect_port' to be a int")
        pulumi.set(__self__, "redirect_port", redirect_port)
        if res_categories and not isinstance(res_categories, list):
            raise TypeError("Expected argument 'res_categories' to be a list")
        pulumi.set(__self__, "res_categories", res_categories)
        if src_ip_groups and not isinstance(src_ip_groups, list):
            raise TypeError("Expected argument 'src_ip_groups' to be a list")
        pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips and not isinstance(src_ips, list):
            raise TypeError("Expected argument 'src_ips' to be a list")
        pulumi.set(__self__, "src_ips", src_ips)
        if src_ipv6_groups and not isinstance(src_ipv6_groups, list):
            raise TypeError("Expected argument 'src_ipv6_groups' to be a list")
        pulumi.set(__self__, "src_ipv6_groups", src_ipv6_groups)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if time_windows and not isinstance(time_windows, list):
            raise TypeError("Expected argument 'time_windows' to be a list")
        pulumi.set(__self__, "time_windows", time_windows)
        if users and not isinstance(users, list):
            raise TypeError("Expected argument 'users' to be a list")
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> builtins.bool:
        """
        (Boolean) If set to true, the default rule is applied
        """
        return pulumi.get(self, "default_rule")

    @property
    @pulumi.getter
    def departments(self) -> Sequence['outputs.GetNatControlRulesDepartmentResult']:
        """
        (Block List, Max: 1) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        (string) - Additional information about the forwarding rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Sequence[builtins.str]:
        """
        ** - (List of String) -  IP addresses and fully qualified domain names (FQDNs), if the domain has multiple destination IP addresses or if its IP addresses may change. For IP addresses, you can enter individual IP addresses, subnets, or address ranges. If adding multiple items, hit Enter after each entry.
        """
        return pulumi.get(self, "dest_addresses")

    @property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Sequence[builtins.str]:
        """
        ** - (List of String) Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        """
        return pulumi.get(self, "dest_countries")

    @property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Sequence[builtins.str]:
        """
        ** - (List of String) IP address categories of destination for which the DNAT rule is applicable. If not set, the rule is not restricted to specific destination IP categories.
        """
        return pulumi.get(self, "dest_ip_categories")

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Sequence['outputs.GetNatControlRulesDestIpGroupResult']:
        """
        ** - (Block List, Max: 1) Any number of destination IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ip_groups")

    @property
    @pulumi.getter(name="destIpv6Groups")
    def dest_ipv6_groups(self) -> Sequence['outputs.GetNatControlRulesDestIpv6GroupResult']:
        """
        ** - (Block List, Max: 1) Any number of destination IPv6 address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ipv6_groups")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Sequence['outputs.GetNatControlRulesDeviceGroupResult']:
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetNatControlRulesDeviceResult']:
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="enableFullLogging")
    def enable_full_logging(self) -> builtins.bool:
        """
        (Boolean)
        """
        return pulumi.get(self, "enable_full_logging")

    @property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetNatControlRulesGroupResult']:
        """
        (Block List, Max: 1) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        (int) The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetNatControlRulesLabelResult']:
        """
        (Block List, Max: 1) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Sequence['outputs.GetNatControlRulesLastModifiedByResult']:
        return pulumi.get(self, "last_modified_bies")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> builtins.int:
        """
        (Number)
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Sequence['outputs.GetNatControlRulesLocationGroupResult']:
        """
        (Block List, Max: 1) You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetNatControlRulesLocationResult']:
        """
        (Block List, Max: 1) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        (String) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nwServiceGroups")
    def nw_service_groups(self) -> Sequence['outputs.GetNatControlRulesNwServiceGroupResult']:
        """
        (Block List, Max: 1) Any number of predefined or custom network service groups to which the rule applies.
        """
        return pulumi.get(self, "nw_service_groups")

    @property
    @pulumi.getter(name="nwServices")
    def nw_services(self) -> Sequence['outputs.GetNatControlRulesNwServiceResult']:
        """
        (Block List, Max: 1) When not used it applies the rule to all network services or you can select specific network services. The Zscaler firewall has predefined services and you can configure up to `1,024` additional custom services.
        """
        return pulumi.get(self, "nw_services")

    @property
    @pulumi.getter
    def order(self) -> builtins.int:
        """
        (string) - The order of execution for the forwarding rule order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def predefined(self) -> builtins.bool:
        """
        (Boolean) If set to true, a predefined rule is applied
        """
        return pulumi.get(self, "predefined")

    @property
    @pulumi.getter
    def rank(self) -> builtins.int:
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="redirectFqdn")
    def redirect_fqdn(self) -> Optional[builtins.str]:
        """
        (string) - FQDN to which the traffic is redirected to when the DNAT rule is triggered. This is mutually exclusive to redirect IP.
        """
        return pulumi.get(self, "redirect_fqdn")

    @property
    @pulumi.getter(name="redirectIp")
    def redirect_ip(self) -> Optional[builtins.str]:
        """
        (string) - IP address to which the traffic is redirected to when the DNAT rule is triggered. If not set, no redirection is done to the specific IP address.
        """
        return pulumi.get(self, "redirect_ip")

    @property
    @pulumi.getter(name="redirectPort")
    def redirect_port(self) -> Optional[builtins.int]:
        """
        (string) -  Port to which the traffic is redirected to when the DNAT rule is triggered. If not set, no redirection is done to the specific port.
        """
        return pulumi.get(self, "redirect_port")

    @property
    @pulumi.getter(name="resCategories")
    def res_categories(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "res_categories")

    @property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Sequence['outputs.GetNatControlRulesSrcIpGroupResult']:
        """
        (Block List, Max: 1) Any number of source IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "src_ip_groups")

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Sequence[builtins.str]:
        """
        (List of String) You can enter individual IP addresses, subnets, or address ranges.
        """
        return pulumi.get(self, "src_ips")

    @property
    @pulumi.getter(name="srcIpv6Groups")
    def src_ipv6_groups(self) -> Sequence['outputs.GetNatControlRulesSrcIpv6GroupResult']:
        """
        (Block List, Max: 1) Any number of source IPv6 address groups that you want to control with this rule.
        """
        return pulumi.get(self, "src_ipv6_groups")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence['outputs.GetNatControlRulesTimeWindowResult']:
        """
        (Block List, Max: 1) You can manually select up to `2` time intervals. When not used it implies `always` to apply the rule to all time intervals.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetNatControlRulesUserResult']:
        """
        (Block List, Max: 1) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")


class AwaitableGetNatControlRulesResult(GetNatControlRulesResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetNatControlRulesResult(
            default_rule=self.default_rule,
            departments=self.departments,
            description=self.description,
            dest_addresses=self.dest_addresses,
            dest_countries=self.dest_countries,
            dest_ip_categories=self.dest_ip_categories,
            dest_ip_groups=self.dest_ip_groups,
            dest_ipv6_groups=self.dest_ipv6_groups,
            device_groups=self.device_groups,
            devices=self.devices,
            enable_full_logging=self.enable_full_logging,
            groups=self.groups,
            id=self.id,
            labels=self.labels,
            last_modified_bies=self.last_modified_bies,
            last_modified_time=self.last_modified_time,
            location_groups=self.location_groups,
            locations=self.locations,
            name=self.name,
            nw_service_groups=self.nw_service_groups,
            nw_services=self.nw_services,
            order=self.order,
            predefined=self.predefined,
            rank=self.rank,
            redirect_fqdn=self.redirect_fqdn,
            redirect_ip=self.redirect_ip,
            redirect_port=self.redirect_port,
            res_categories=self.res_categories,
            src_ip_groups=self.src_ip_groups,
            src_ips=self.src_ips,
            src_ipv6_groups=self.src_ipv6_groups,
            state=self.state,
            time_windows=self.time_windows,
            users=self.users)


def get_nat_control_rules(id: Optional[builtins.int] = None,
                          name: Optional[builtins.str] = None,
                          redirect_fqdn: Optional[builtins.str] = None,
                          redirect_ip: Optional[builtins.str] = None,
                          redirect_port: Optional[builtins.int] = None,
                          opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetNatControlRulesResult:
    """
    * [Official documentation](https://help.zscaler.com/zia/about-nat-control)
    * [API documentation](https://help.zscaler.com/zia/nat-control-policy#/dnatRules-get)

    Use the **zia_nat_control_rules** data source to get information about a NAT Control rule available in the Zscaler Internet Access.

    ## Example Usage

    ### By Name

    ### By ID


    :param builtins.int id: A unique identifier assigned to the forwarding rule.
    :param builtins.str name: The name of the forwarding rule.
    :param builtins.str redirect_fqdn: (string) - FQDN to which the traffic is redirected to when the DNAT rule is triggered. This is mutually exclusive to redirect IP.
    :param builtins.str redirect_ip: (string) - IP address to which the traffic is redirected to when the DNAT rule is triggered. If not set, no redirection is done to the specific IP address.
    :param builtins.int redirect_port: (string) -  Port to which the traffic is redirected to when the DNAT rule is triggered. If not set, no redirection is done to the specific port.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['redirectFqdn'] = redirect_fqdn
    __args__['redirectIp'] = redirect_ip
    __args__['redirectPort'] = redirect_port
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getNatControlRules:getNatControlRules', __args__, opts=opts, typ=GetNatControlRulesResult).value

    return AwaitableGetNatControlRulesResult(
        default_rule=pulumi.get(__ret__, 'default_rule'),
        departments=pulumi.get(__ret__, 'departments'),
        description=pulumi.get(__ret__, 'description'),
        dest_addresses=pulumi.get(__ret__, 'dest_addresses'),
        dest_countries=pulumi.get(__ret__, 'dest_countries'),
        dest_ip_categories=pulumi.get(__ret__, 'dest_ip_categories'),
        dest_ip_groups=pulumi.get(__ret__, 'dest_ip_groups'),
        dest_ipv6_groups=pulumi.get(__ret__, 'dest_ipv6_groups'),
        device_groups=pulumi.get(__ret__, 'device_groups'),
        devices=pulumi.get(__ret__, 'devices'),
        enable_full_logging=pulumi.get(__ret__, 'enable_full_logging'),
        groups=pulumi.get(__ret__, 'groups'),
        id=pulumi.get(__ret__, 'id'),
        labels=pulumi.get(__ret__, 'labels'),
        last_modified_bies=pulumi.get(__ret__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__ret__, 'last_modified_time'),
        location_groups=pulumi.get(__ret__, 'location_groups'),
        locations=pulumi.get(__ret__, 'locations'),
        name=pulumi.get(__ret__, 'name'),
        nw_service_groups=pulumi.get(__ret__, 'nw_service_groups'),
        nw_services=pulumi.get(__ret__, 'nw_services'),
        order=pulumi.get(__ret__, 'order'),
        predefined=pulumi.get(__ret__, 'predefined'),
        rank=pulumi.get(__ret__, 'rank'),
        redirect_fqdn=pulumi.get(__ret__, 'redirect_fqdn'),
        redirect_ip=pulumi.get(__ret__, 'redirect_ip'),
        redirect_port=pulumi.get(__ret__, 'redirect_port'),
        res_categories=pulumi.get(__ret__, 'res_categories'),
        src_ip_groups=pulumi.get(__ret__, 'src_ip_groups'),
        src_ips=pulumi.get(__ret__, 'src_ips'),
        src_ipv6_groups=pulumi.get(__ret__, 'src_ipv6_groups'),
        state=pulumi.get(__ret__, 'state'),
        time_windows=pulumi.get(__ret__, 'time_windows'),
        users=pulumi.get(__ret__, 'users'))
def get_nat_control_rules_output(id: Optional[pulumi.Input[Optional[builtins.int]]] = None,
                                 name: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                                 redirect_fqdn: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                                 redirect_ip: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                                 redirect_port: Optional[pulumi.Input[Optional[builtins.int]]] = None,
                                 opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetNatControlRulesResult]:
    """
    * [Official documentation](https://help.zscaler.com/zia/about-nat-control)
    * [API documentation](https://help.zscaler.com/zia/nat-control-policy#/dnatRules-get)

    Use the **zia_nat_control_rules** data source to get information about a NAT Control rule available in the Zscaler Internet Access.

    ## Example Usage

    ### By Name

    ### By ID


    :param builtins.int id: A unique identifier assigned to the forwarding rule.
    :param builtins.str name: The name of the forwarding rule.
    :param builtins.str redirect_fqdn: (string) - FQDN to which the traffic is redirected to when the DNAT rule is triggered. This is mutually exclusive to redirect IP.
    :param builtins.str redirect_ip: (string) - IP address to which the traffic is redirected to when the DNAT rule is triggered. If not set, no redirection is done to the specific IP address.
    :param builtins.int redirect_port: (string) -  Port to which the traffic is redirected to when the DNAT rule is triggered. If not set, no redirection is done to the specific port.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['redirectFqdn'] = redirect_fqdn
    __args__['redirectIp'] = redirect_ip
    __args__['redirectPort'] = redirect_port
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zia:index/getNatControlRules:getNatControlRules', __args__, opts=opts, typ=GetNatControlRulesResult)
    return __ret__.apply(lambda __response__: GetNatControlRulesResult(
        default_rule=pulumi.get(__response__, 'default_rule'),
        departments=pulumi.get(__response__, 'departments'),
        description=pulumi.get(__response__, 'description'),
        dest_addresses=pulumi.get(__response__, 'dest_addresses'),
        dest_countries=pulumi.get(__response__, 'dest_countries'),
        dest_ip_categories=pulumi.get(__response__, 'dest_ip_categories'),
        dest_ip_groups=pulumi.get(__response__, 'dest_ip_groups'),
        dest_ipv6_groups=pulumi.get(__response__, 'dest_ipv6_groups'),
        device_groups=pulumi.get(__response__, 'device_groups'),
        devices=pulumi.get(__response__, 'devices'),
        enable_full_logging=pulumi.get(__response__, 'enable_full_logging'),
        groups=pulumi.get(__response__, 'groups'),
        id=pulumi.get(__response__, 'id'),
        labels=pulumi.get(__response__, 'labels'),
        last_modified_bies=pulumi.get(__response__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__response__, 'last_modified_time'),
        location_groups=pulumi.get(__response__, 'location_groups'),
        locations=pulumi.get(__response__, 'locations'),
        name=pulumi.get(__response__, 'name'),
        nw_service_groups=pulumi.get(__response__, 'nw_service_groups'),
        nw_services=pulumi.get(__response__, 'nw_services'),
        order=pulumi.get(__response__, 'order'),
        predefined=pulumi.get(__response__, 'predefined'),
        rank=pulumi.get(__response__, 'rank'),
        redirect_fqdn=pulumi.get(__response__, 'redirect_fqdn'),
        redirect_ip=pulumi.get(__response__, 'redirect_ip'),
        redirect_port=pulumi.get(__response__, 'redirect_port'),
        res_categories=pulumi.get(__response__, 'res_categories'),
        src_ip_groups=pulumi.get(__response__, 'src_ip_groups'),
        src_ips=pulumi.get(__response__, 'src_ips'),
        src_ipv6_groups=pulumi.get(__response__, 'src_ipv6_groups'),
        state=pulumi.get(__response__, 'state'),
        time_windows=pulumi.get(__response__, 'time_windows'),
        users=pulumi.get(__response__, 'users')))

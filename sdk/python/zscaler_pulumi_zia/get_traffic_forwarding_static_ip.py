# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetTrafficForwardingStaticIPResult',
    'AwaitableGetTrafficForwardingStaticIPResult',
    'get_traffic_forwarding_static_ip',
    'get_traffic_forwarding_static_ip_output',
]

@pulumi.output_type
class GetTrafficForwardingStaticIPResult:
    """
    A collection of values returned by getTrafficForwardingStaticIP.
    """
    def __init__(__self__, cities=None, comment=None, geo_override=None, id=None, ip_address=None, last_modification_time=None, last_modified_bies=None, latitude=None, longitude=None, managed_bies=None, routable_ip=None):
        if cities and not isinstance(cities, list):
            raise TypeError("Expected argument 'cities' to be a list")
        pulumi.set(__self__, "cities", cities)
        if comment and not isinstance(comment, str):
            raise TypeError("Expected argument 'comment' to be a str")
        pulumi.set(__self__, "comment", comment)
        if geo_override and not isinstance(geo_override, bool):
            raise TypeError("Expected argument 'geo_override' to be a bool")
        pulumi.set(__self__, "geo_override", geo_override)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if ip_address and not isinstance(ip_address, str):
            raise TypeError("Expected argument 'ip_address' to be a str")
        pulumi.set(__self__, "ip_address", ip_address)
        if last_modification_time and not isinstance(last_modification_time, int):
            raise TypeError("Expected argument 'last_modification_time' to be a int")
        pulumi.set(__self__, "last_modification_time", last_modification_time)
        if last_modified_bies and not isinstance(last_modified_bies, list):
            raise TypeError("Expected argument 'last_modified_bies' to be a list")
        pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if latitude and not isinstance(latitude, float):
            raise TypeError("Expected argument 'latitude' to be a float")
        pulumi.set(__self__, "latitude", latitude)
        if longitude and not isinstance(longitude, float):
            raise TypeError("Expected argument 'longitude' to be a float")
        pulumi.set(__self__, "longitude", longitude)
        if managed_bies and not isinstance(managed_bies, list):
            raise TypeError("Expected argument 'managed_bies' to be a list")
        pulumi.set(__self__, "managed_bies", managed_bies)
        if routable_ip and not isinstance(routable_ip, bool):
            raise TypeError("Expected argument 'routable_ip' to be a bool")
        pulumi.set(__self__, "routable_ip", routable_ip)

    @property
    @pulumi.getter
    def cities(self) -> Sequence['outputs.GetTrafficForwardingStaticIPCityResult']:
        return pulumi.get(self, "cities")

    @property
    @pulumi.getter
    def comment(self) -> builtins.str:
        """
        (String) Additional information about this static IP address
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="geoOverride")
    def geo_override(self) -> builtins.bool:
        """
        (Boolean) If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
        """
        return pulumi.get(self, "geo_override")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        """
        (String) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> builtins.str:
        """
        (String) The static IP address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lastModificationTime")
    def last_modification_time(self) -> builtins.int:
        """
        (Number) When the static IP address was last modified
        """
        return pulumi.get(self, "last_modification_time")

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Sequence['outputs.GetTrafficForwardingStaticIPLastModifiedByResult']:
        """
        (Set of Object)
        """
        return pulumi.get(self, "last_modified_bies")

    @property
    @pulumi.getter
    def latitude(self) -> builtins.float:
        """
        (Number) Required only if the geoOverride attribute is set. Latitude with 7 digit precision after decimal point, ranges between `-90` and `90` degrees.
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter
    def longitude(self) -> builtins.float:
        """
        (Number) Required only if the geoOverride attribute is set. Longitude with 7 digit precision after decimal point, ranges between `-180` and `180` degrees.
        """
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="managedBies")
    def managed_bies(self) -> Sequence['outputs.GetTrafficForwardingStaticIPManagedByResult']:
        """
        (Set of Object)
        """
        return pulumi.get(self, "managed_bies")

    @property
    @pulumi.getter(name="routableIp")
    def routable_ip(self) -> builtins.bool:
        """
        (Boolean) Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
        """
        return pulumi.get(self, "routable_ip")


class AwaitableGetTrafficForwardingStaticIPResult(GetTrafficForwardingStaticIPResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetTrafficForwardingStaticIPResult(
            cities=self.cities,
            comment=self.comment,
            geo_override=self.geo_override,
            id=self.id,
            ip_address=self.ip_address,
            last_modification_time=self.last_modification_time,
            last_modified_bies=self.last_modified_bies,
            latitude=self.latitude,
            longitude=self.longitude,
            managed_bies=self.managed_bies,
            routable_ip=self.routable_ip)


def get_traffic_forwarding_static_ip(id: Optional[builtins.int] = None,
                                     ip_address: Optional[builtins.str] = None,
                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetTrafficForwardingStaticIPResult:
    """
    Use the **zia_traffic_forwarding_static_ip** data source to get information about all provisioned static IP addresses. This resource can then be utilized when creating a GRE Tunnel or VPN Credential resource of Type `IP`

    ## Example Usage


    :param builtins.int id: The unique identifier for the static IP address
    :param builtins.str ip_address: The static IP address
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['ipAddress'] = ip_address
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getTrafficForwardingStaticIP:getTrafficForwardingStaticIP', __args__, opts=opts, typ=GetTrafficForwardingStaticIPResult).value

    return AwaitableGetTrafficForwardingStaticIPResult(
        cities=pulumi.get(__ret__, 'cities'),
        comment=pulumi.get(__ret__, 'comment'),
        geo_override=pulumi.get(__ret__, 'geo_override'),
        id=pulumi.get(__ret__, 'id'),
        ip_address=pulumi.get(__ret__, 'ip_address'),
        last_modification_time=pulumi.get(__ret__, 'last_modification_time'),
        last_modified_bies=pulumi.get(__ret__, 'last_modified_bies'),
        latitude=pulumi.get(__ret__, 'latitude'),
        longitude=pulumi.get(__ret__, 'longitude'),
        managed_bies=pulumi.get(__ret__, 'managed_bies'),
        routable_ip=pulumi.get(__ret__, 'routable_ip'))
def get_traffic_forwarding_static_ip_output(id: Optional[pulumi.Input[Optional[builtins.int]]] = None,
                                            ip_address: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                                            opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetTrafficForwardingStaticIPResult]:
    """
    Use the **zia_traffic_forwarding_static_ip** data source to get information about all provisioned static IP addresses. This resource can then be utilized when creating a GRE Tunnel or VPN Credential resource of Type `IP`

    ## Example Usage


    :param builtins.int id: The unique identifier for the static IP address
    :param builtins.str ip_address: The static IP address
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['ipAddress'] = ip_address
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zia:index/getTrafficForwardingStaticIP:getTrafficForwardingStaticIP', __args__, opts=opts, typ=GetTrafficForwardingStaticIPResult)
    return __ret__.apply(lambda __response__: GetTrafficForwardingStaticIPResult(
        cities=pulumi.get(__response__, 'cities'),
        comment=pulumi.get(__response__, 'comment'),
        geo_override=pulumi.get(__response__, 'geo_override'),
        id=pulumi.get(__response__, 'id'),
        ip_address=pulumi.get(__response__, 'ip_address'),
        last_modification_time=pulumi.get(__response__, 'last_modification_time'),
        last_modified_bies=pulumi.get(__response__, 'last_modified_bies'),
        latitude=pulumi.get(__response__, 'latitude'),
        longitude=pulumi.get(__response__, 'longitude'),
        managed_bies=pulumi.get(__response__, 'managed_bies'),
        routable_ip=pulumi.get(__response__, 'routable_ip')))

# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['BandwidthControlRuleArgs', 'BandwidthControlRule']

@pulumi.input_type
class BandwidthControlRuleArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[_builtins.int],
                 protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 bandwidth_classes: Optional[pulumi.Input['BandwidthControlRuleBandwidthClassesArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input['BandwidthControlRuleLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['BandwidthControlRuleLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['BandwidthControlRuleLocationsArgs']] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['BandwidthControlRuleTimeWindowsArgs']] = None):
        """
        The set of arguments for constructing a BandwidthControlRule resource.
        :param pulumi.Input[_builtins.int] order: The order of the bandwidth control rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] protocols: (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        :param pulumi.Input['BandwidthControlRuleBandwidthClassesArgs'] bandwidth_classes: The bandwidth control rulees to which you want to apply this rule
        :param pulumi.Input[_builtins.str] description: (Optional) Additional information about the rule
        :param pulumi.Input['BandwidthControlRuleLabelsArgs'] labels: Labels that are applicable to the rule
        :param pulumi.Input['BandwidthControlRuleLocationGroupsArgs'] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input['BandwidthControlRuleLocationsArgs'] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[_builtins.int] max_bandwidth: (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.int] min_bandwidth: (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.str] name: The bandwidth control rule name
        :param pulumi.Input[_builtins.int] rank: (Optional) Admin rank of the Bandwidth Control policy rule
        :param pulumi.Input[_builtins.str] state: (Optional) Administrative state of the rule.
        :param pulumi.Input['BandwidthControlRuleTimeWindowsArgs'] time_windows: The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "protocols", protocols)
        if bandwidth_classes is not None:
            pulumi.set(__self__, "bandwidth_classes", bandwidth_classes)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @_builtins.property
    @pulumi.getter
    def order(self) -> pulumi.Input[_builtins.int]:
        """
        The order of the bandwidth control rule
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthClasses")
    def bandwidth_classes(self) -> Optional[pulumi.Input['BandwidthControlRuleBandwidthClassesArgs']]:
        """
        The bandwidth control rulees to which you want to apply this rule
        """
        return pulumi.get(self, "bandwidth_classes")

    @bandwidth_classes.setter
    def bandwidth_classes(self, value: Optional[pulumi.Input['BandwidthControlRuleBandwidthClassesArgs']]):
        pulumi.set(self, "bandwidth_classes", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) Additional information about the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['BandwidthControlRuleLabelsArgs']]:
        """
        Labels that are applicable to the rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['BandwidthControlRuleLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['BandwidthControlRuleLocationGroupsArgs']]:
        """
        Name-ID pairs of the location groups to which the rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['BandwidthControlRuleLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['BandwidthControlRuleLocationsArgs']]:
        """
        Name-ID pairs of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['BandwidthControlRuleLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        """
        return pulumi.get(self, "max_bandwidth")

    @max_bandwidth.setter
    def max_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        """
        return pulumi.get(self, "min_bandwidth")

    @min_bandwidth.setter
    def min_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bandwidth", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth control rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) Admin rank of the Bandwidth Control policy rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) Administrative state of the rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['BandwidthControlRuleTimeWindowsArgs']]:
        """
        The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['BandwidthControlRuleTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)


@pulumi.input_type
class _BandwidthControlRuleState:
    def __init__(__self__, *,
                 bandwidth_classes: Optional[pulumi.Input['BandwidthControlRuleBandwidthClassesArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input['BandwidthControlRuleLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['BandwidthControlRuleLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['BandwidthControlRuleLocationsArgs']] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 order: Optional[pulumi.Input[_builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['BandwidthControlRuleTimeWindowsArgs']] = None):
        """
        Input properties used for looking up and filtering BandwidthControlRule resources.
        :param pulumi.Input['BandwidthControlRuleBandwidthClassesArgs'] bandwidth_classes: The bandwidth control rulees to which you want to apply this rule
        :param pulumi.Input[_builtins.str] description: (Optional) Additional information about the rule
        :param pulumi.Input['BandwidthControlRuleLabelsArgs'] labels: Labels that are applicable to the rule
        :param pulumi.Input['BandwidthControlRuleLocationGroupsArgs'] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input['BandwidthControlRuleLocationsArgs'] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[_builtins.int] max_bandwidth: (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.int] min_bandwidth: (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.str] name: The bandwidth control rule name
        :param pulumi.Input[_builtins.int] order: The order of the bandwidth control rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] protocols: (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        :param pulumi.Input[_builtins.int] rank: (Optional) Admin rank of the Bandwidth Control policy rule
        :param pulumi.Input[_builtins.str] state: (Optional) Administrative state of the rule.
        :param pulumi.Input['BandwidthControlRuleTimeWindowsArgs'] time_windows: The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        if bandwidth_classes is not None:
            pulumi.set(__self__, "bandwidth_classes", bandwidth_classes)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @_builtins.property
    @pulumi.getter(name="bandwidthClasses")
    def bandwidth_classes(self) -> Optional[pulumi.Input['BandwidthControlRuleBandwidthClassesArgs']]:
        """
        The bandwidth control rulees to which you want to apply this rule
        """
        return pulumi.get(self, "bandwidth_classes")

    @bandwidth_classes.setter
    def bandwidth_classes(self, value: Optional[pulumi.Input['BandwidthControlRuleBandwidthClassesArgs']]):
        pulumi.set(self, "bandwidth_classes", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) Additional information about the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['BandwidthControlRuleLabelsArgs']]:
        """
        Labels that are applicable to the rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['BandwidthControlRuleLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['BandwidthControlRuleLocationGroupsArgs']]:
        """
        Name-ID pairs of the location groups to which the rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['BandwidthControlRuleLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['BandwidthControlRuleLocationsArgs']]:
        """
        Name-ID pairs of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['BandwidthControlRuleLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        """
        return pulumi.get(self, "max_bandwidth")

    @max_bandwidth.setter
    def max_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        """
        return pulumi.get(self, "min_bandwidth")

    @min_bandwidth.setter
    def min_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bandwidth", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth control rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The order of the bandwidth control rule
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Optional) Admin rank of the Bandwidth Control policy rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) Administrative state of the rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['BandwidthControlRuleTimeWindowsArgs']]:
        """
        The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['BandwidthControlRuleTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)


@pulumi.type_token("zia:index/bandwidthControlRule:BandwidthControlRule")
class BandwidthControlRule(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 bandwidth_classes: Optional[pulumi.Input[Union['BandwidthControlRuleBandwidthClassesArgs', 'BandwidthControlRuleBandwidthClassesArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Union['BandwidthControlRuleLabelsArgs', 'BandwidthControlRuleLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['BandwidthControlRuleLocationGroupsArgs', 'BandwidthControlRuleLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['BandwidthControlRuleLocationsArgs', 'BandwidthControlRuleLocationsArgsDict']]] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 order: Optional[pulumi.Input[_builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['BandwidthControlRuleTimeWindowsArgs', 'BandwidthControlRuleTimeWindowsArgsDict']]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zia/adding-rules-bandwidth-control-policy)
        * [API documentation](https://help.zscaler.com/zia/bandwidth-control-classes#/)

        Use the **zia_bandwidth_control_rule** resource allows the creation and management of ZIA Bandwidth Control Rules in the Zscaler Internet Access cloud or via the API.

        **NOTE**: Bandwidth control rule resource is only supported via Zscaler OneAPI.

        ## Example Usage

        ### By Name

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
        Visit

        **zia_bandwidth_control_rule** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/bandwidthControlRule:BandwidthControlRule this <rule_id>
        ```

        ```sh
        $ pulumi import zia:index/bandwidthControlRule:BandwidthControlRule this <"rule_name">
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Union['BandwidthControlRuleBandwidthClassesArgs', 'BandwidthControlRuleBandwidthClassesArgsDict']] bandwidth_classes: The bandwidth control rulees to which you want to apply this rule
        :param pulumi.Input[_builtins.str] description: (Optional) Additional information about the rule
        :param pulumi.Input[Union['BandwidthControlRuleLabelsArgs', 'BandwidthControlRuleLabelsArgsDict']] labels: Labels that are applicable to the rule
        :param pulumi.Input[Union['BandwidthControlRuleLocationGroupsArgs', 'BandwidthControlRuleLocationGroupsArgsDict']] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input[Union['BandwidthControlRuleLocationsArgs', 'BandwidthControlRuleLocationsArgsDict']] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[_builtins.int] max_bandwidth: (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.int] min_bandwidth: (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.str] name: The bandwidth control rule name
        :param pulumi.Input[_builtins.int] order: The order of the bandwidth control rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] protocols: (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        :param pulumi.Input[_builtins.int] rank: (Optional) Admin rank of the Bandwidth Control policy rule
        :param pulumi.Input[_builtins.str] state: (Optional) Administrative state of the rule.
        :param pulumi.Input[Union['BandwidthControlRuleTimeWindowsArgs', 'BandwidthControlRuleTimeWindowsArgsDict']] time_windows: The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: BandwidthControlRuleArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zia/adding-rules-bandwidth-control-policy)
        * [API documentation](https://help.zscaler.com/zia/bandwidth-control-classes#/)

        Use the **zia_bandwidth_control_rule** resource allows the creation and management of ZIA Bandwidth Control Rules in the Zscaler Internet Access cloud or via the API.

        **NOTE**: Bandwidth control rule resource is only supported via Zscaler OneAPI.

        ## Example Usage

        ### By Name

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.
        Visit

        **zia_bandwidth_control_rule** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/bandwidthControlRule:BandwidthControlRule this <rule_id>
        ```

        ```sh
        $ pulumi import zia:index/bandwidthControlRule:BandwidthControlRule this <"rule_name">
        ```

        :param str resource_name: The name of the resource.
        :param BandwidthControlRuleArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(BandwidthControlRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 bandwidth_classes: Optional[pulumi.Input[Union['BandwidthControlRuleBandwidthClassesArgs', 'BandwidthControlRuleBandwidthClassesArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Union['BandwidthControlRuleLabelsArgs', 'BandwidthControlRuleLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['BandwidthControlRuleLocationGroupsArgs', 'BandwidthControlRuleLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['BandwidthControlRuleLocationsArgs', 'BandwidthControlRuleLocationsArgsDict']]] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 order: Optional[pulumi.Input[_builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['BandwidthControlRuleTimeWindowsArgs', 'BandwidthControlRuleTimeWindowsArgsDict']]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = BandwidthControlRuleArgs.__new__(BandwidthControlRuleArgs)

            __props__.__dict__["bandwidth_classes"] = bandwidth_classes
            __props__.__dict__["description"] = description
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["max_bandwidth"] = max_bandwidth
            __props__.__dict__["min_bandwidth"] = min_bandwidth
            __props__.__dict__["name"] = name
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            if protocols is None and not opts.urn:
                raise TypeError("Missing required property 'protocols'")
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["rank"] = rank
            __props__.__dict__["state"] = state
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["rule_id"] = None
        super(BandwidthControlRule, __self__).__init__(
            'zia:index/bandwidthControlRule:BandwidthControlRule',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            bandwidth_classes: Optional[pulumi.Input[Union['BandwidthControlRuleBandwidthClassesArgs', 'BandwidthControlRuleBandwidthClassesArgsDict']]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            labels: Optional[pulumi.Input[Union['BandwidthControlRuleLabelsArgs', 'BandwidthControlRuleLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['BandwidthControlRuleLocationGroupsArgs', 'BandwidthControlRuleLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['BandwidthControlRuleLocationsArgs', 'BandwidthControlRuleLocationsArgsDict']]] = None,
            max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
            min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            order: Optional[pulumi.Input[_builtins.int]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            rank: Optional[pulumi.Input[_builtins.int]] = None,
            rule_id: Optional[pulumi.Input[_builtins.int]] = None,
            state: Optional[pulumi.Input[_builtins.str]] = None,
            time_windows: Optional[pulumi.Input[Union['BandwidthControlRuleTimeWindowsArgs', 'BandwidthControlRuleTimeWindowsArgsDict']]] = None) -> 'BandwidthControlRule':
        """
        Get an existing BandwidthControlRule resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Union['BandwidthControlRuleBandwidthClassesArgs', 'BandwidthControlRuleBandwidthClassesArgsDict']] bandwidth_classes: The bandwidth control rulees to which you want to apply this rule
        :param pulumi.Input[_builtins.str] description: (Optional) Additional information about the rule
        :param pulumi.Input[Union['BandwidthControlRuleLabelsArgs', 'BandwidthControlRuleLabelsArgsDict']] labels: Labels that are applicable to the rule
        :param pulumi.Input[Union['BandwidthControlRuleLocationGroupsArgs', 'BandwidthControlRuleLocationGroupsArgsDict']] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input[Union['BandwidthControlRuleLocationsArgs', 'BandwidthControlRuleLocationsArgsDict']] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[_builtins.int] max_bandwidth: (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.int] min_bandwidth: (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        :param pulumi.Input[_builtins.str] name: The bandwidth control rule name
        :param pulumi.Input[_builtins.int] order: The order of the bandwidth control rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] protocols: (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        :param pulumi.Input[_builtins.int] rank: (Optional) Admin rank of the Bandwidth Control policy rule
        :param pulumi.Input[_builtins.str] state: (Optional) Administrative state of the rule.
        :param pulumi.Input[Union['BandwidthControlRuleTimeWindowsArgs', 'BandwidthControlRuleTimeWindowsArgsDict']] time_windows: The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _BandwidthControlRuleState.__new__(_BandwidthControlRuleState)

        __props__.__dict__["bandwidth_classes"] = bandwidth_classes
        __props__.__dict__["description"] = description
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["max_bandwidth"] = max_bandwidth
        __props__.__dict__["min_bandwidth"] = min_bandwidth
        __props__.__dict__["name"] = name
        __props__.__dict__["order"] = order
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["rank"] = rank
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["state"] = state
        __props__.__dict__["time_windows"] = time_windows
        return BandwidthControlRule(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="bandwidthClasses")
    def bandwidth_classes(self) -> pulumi.Output[Optional['outputs.BandwidthControlRuleBandwidthClasses']]:
        """
        The bandwidth control rulees to which you want to apply this rule
        """
        return pulumi.get(self, "bandwidth_classes")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        (Optional) Additional information about the rule
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.BandwidthControlRuleLabels']]:
        """
        Labels that are applicable to the rule
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.BandwidthControlRuleLocationGroups']]:
        """
        Name-ID pairs of the location groups to which the rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.BandwidthControlRuleLocations']]:
        """
        Name-ID pairs of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        (Optional) The maximum percentage of a location's bandwidth to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        (Optional) The minimum percentage of a location's bandwidth you want to be guaranteed for each selected bandwidth class. This percentage includes bandwidth for uploads and downloads.
        """
        return pulumi.get(self, "min_bandwidth")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        The bandwidth control rule name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def order(self) -> pulumi.Output[_builtins.int]:
        """
        The order of the bandwidth control rule
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Sequence[_builtins.str]]:
        """
        (List of Object) Protocol criteria. Supported values: `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `SSL_RULE`, `TUNNEL_RULE`
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter
    def rank(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        (Optional) Admin rank of the Bandwidth Control policy rule
        """
        return pulumi.get(self, "rank")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[_builtins.int]:
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        (Optional) Administrative state of the rule.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output[Optional['outputs.BandwidthControlRuleTimeWindows']]:
        """
        The Name-ID pairs of time windows to which the bandwidth control rule must be applied
        """
        return pulumi.get(self, "time_windows")


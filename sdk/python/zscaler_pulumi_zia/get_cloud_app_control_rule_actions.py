# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'GetCloudAppControlRuleActionsResult',
    'AwaitableGetCloudAppControlRuleActionsResult',
    'get_cloud_app_control_rule_actions',
    'get_cloud_app_control_rule_actions_output',
]

@pulumi.output_type
class GetCloudAppControlRuleActionsResult:
    """
    A collection of values returned by getCloudAppControlRuleActions.
    """
    def __init__(__self__, action_prefixes=None, available_actions=None, available_actions_without_isolates=None, cloud_apps=None, filtered_actions=None, id=None, isolate_actions=None, type=None):
        if action_prefixes and not isinstance(action_prefixes, list):
            raise TypeError("Expected argument 'action_prefixes' to be a list")
        pulumi.set(__self__, "action_prefixes", action_prefixes)
        if available_actions and not isinstance(available_actions, list):
            raise TypeError("Expected argument 'available_actions' to be a list")
        pulumi.set(__self__, "available_actions", available_actions)
        if available_actions_without_isolates and not isinstance(available_actions_without_isolates, list):
            raise TypeError("Expected argument 'available_actions_without_isolates' to be a list")
        pulumi.set(__self__, "available_actions_without_isolates", available_actions_without_isolates)
        if cloud_apps and not isinstance(cloud_apps, list):
            raise TypeError("Expected argument 'cloud_apps' to be a list")
        pulumi.set(__self__, "cloud_apps", cloud_apps)
        if filtered_actions and not isinstance(filtered_actions, list):
            raise TypeError("Expected argument 'filtered_actions' to be a list")
        pulumi.set(__self__, "filtered_actions", filtered_actions)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if isolate_actions and not isinstance(isolate_actions, list):
            raise TypeError("Expected argument 'isolate_actions' to be a list")
        pulumi.set(__self__, "isolate_actions", isolate_actions)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="actionPrefixes")
    def action_prefixes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "action_prefixes")

    @_builtins.property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[_builtins.str]:
        """
        (List of Strings) Complete list of all available actions for the specified cloud applications and rule type, including ISOLATE actions. Use when you need the full list or want to apply custom Terraform filtering logic.
        """
        return pulumi.get(self, "available_actions")

    @_builtins.property
    @pulumi.getter(name="availableActionsWithoutIsolates")
    def available_actions_without_isolates(self) -> Sequence[_builtins.str]:
        """
        (List of Strings) **Recommended for most use cases**. List of available actions excluding ISOLATE actions. Use this for standard Cloud App Control rules. ISOLATE actions cannot be mixed with other action types and require separate rules.
        """
        return pulumi.get(self, "available_actions_without_isolates")

    @_builtins.property
    @pulumi.getter(name="cloudApps")
    def cloud_apps(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cloud_apps")

    @_builtins.property
    @pulumi.getter(name="filteredActions")
    def filtered_actions(self) -> Sequence[_builtins.str]:
        """
        (List of Strings) List of actions filtered by the `action_prefixes` parameter. Only populated when `action_prefixes` is specified. Use this for custom filtering by specific action types (ALLOW only, DENY only, ALLOW+DENY, etc.).
        """
        return pulumi.get(self, "filtered_actions")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isolateActions")
    def isolate_actions(self) -> Sequence[_builtins.str]:
        """
        (List of Strings) List of only ISOLATE actions (Cloud Browser Isolation). Use this for CBI rules. When using ISOLATE actions:
        * They **cannot** be mixed with other action types (ALLOW, DENY, etc.)
        * They **require** `cbi_profile` block in the resource
        * They **cannot** have `browser_eun_template_id` set
        * Create separate rules for ISOLATE vs non-ISOLATE actions
        """
        return pulumi.get(self, "isolate_actions")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


class AwaitableGetCloudAppControlRuleActionsResult(GetCloudAppControlRuleActionsResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetCloudAppControlRuleActionsResult(
            action_prefixes=self.action_prefixes,
            available_actions=self.available_actions,
            available_actions_without_isolates=self.available_actions_without_isolates,
            cloud_apps=self.cloud_apps,
            filtered_actions=self.filtered_actions,
            id=self.id,
            isolate_actions=self.isolate_actions,
            type=self.type)


def get_cloud_app_control_rule_actions(action_prefixes: Optional[Sequence[_builtins.str]] = None,
                                       cloud_apps: Optional[Sequence[_builtins.str]] = None,
                                       type: Optional[_builtins.str] = None,
                                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCloudAppControlRuleActionsResult:
    """
    * [Official documentation](https://help.zscaler.com/zia/adding-rules-cloud-app-control-policy)
    * [API documentation](https://help.zscaler.com/zia/cloud-app-control-policy#/webApplicationRules/)

    Use the **zia_cloud_app_control_rule_actions** data source to retrieve the available actions for specific cloud applications and rule types. This data source automatically handles action intersections when multiple applications are specified, returning only actions supported by ALL applications.

    **NOTE**: Note that some new actions may not be returned in the API response. This is a known issue, and is being investigated via the following issue `ONEAPI-2421`. Please contact Zscaler support for an update if the action you're attempting ton configure isn't supported or returned in the response.

    The data source provides multiple output attributes for different use cases:

    * **`available_actions_without_isolate`** - Most common use case for standard rules
    * **`isolate_actions`** - For Cloud Browser Isolation (CBI) rules
    * **`filtered_actions`** - Custom filtering by action type (ALLOW, DENY, etc.)
    * **`available_actions`** - Complete list of all actions

    ## Example Usage

    ### Standard Rule (Most Common)

    Use `available_actions_without_isolate` for standard rules that don't require Cloud Browser Isolation:

    ### Isolation Rule (CBI)

    Use `isolate_actions` for Cloud Browser Isolation rules:

    ### Multiple Applications (Intersection)

    When multiple applications are specified, the API automatically returns only actions supported by ALL applications:

    ### Filter By Action Type (ALLOW Only)

    Use `action_prefixes` to filter actions by type:

    ### Filter Multiple Action Types

    Filter for multiple action types simultaneously:

    ### File Sharing Applications

    ### Only DENY Actions

    ## Understanding Action Types

    ### Action Prefixes

    Cloud App Control rules support different action types based on the application and rule type:

    | Prefix | Description | Example | Can Mix With |
    |--------|-------------|---------|--------------|
    | `ALLOW` | Permit specific operations | ALLOW_AI_ML_CHAT | DENY, CAUTION, ESC |
    | `DENY` | Block specific operations | DENY_AI_ML_UPLOAD | ALLOW, CAUTION, ESC |
    | `BLOCK` | Block operations (some apps) | BLOCK_FILE_SHARE_DOWNLOAD | ALLOW, CAUTION |
    | `CAUTION` | Warn before allowing | CAUTION_AI_ML_WEB_USE | ALLOW, DENY, BLOCK |
    | `ISOLATE` | Cloud Browser Isolation | ISOLATE_AI_ML_WEB_USE | **Cannot mix** |
    | `ESC` | Conditional access | AI_ML_CONDITIONAL_ACCESS | ALLOW, DENY |

    ### Important Rules

    1. **ISOLATE Actions**:
       * Cannot be mixed with any other action type
       * Require `cbi_profile` configuration in the resource
       * Use `isolate_actions` attribute or filter with `action_prefixes = ["ISOLATE"]`

    2. **Multiple Applications**:
       * The API automatically returns the intersection of actions
       * Only actions supported by ALL specified applications are returned
       * Always query the data source with the same applications you'll use in the resource

    3. **Action Compatibility**:
       * Most actions can be mixed (ALLOW + DENY, ALLOW + CAUTION, etc.)
       * ISOLATE actions are the exception - they must be used alone

    ## Best Practices

    ### 1. Use Data Source Instead of Hardcoding

    **❌ Avoid hardcoding actions**:

    **✅ Use data source**:

    ### 2. Match Applications Between Data Source and Resource

    **❌ Mismatch (will cause validation errors)**:

    **✅ Correct match**:

    ### 3. Choose the Right Output Attribute

    | Use Case | Attribute to Use | Example |
    |----------|------------------|---------|
    | Standard rule (no CBI) | `available_actions_without_isolate` | Most common |
    | CBI/Isolation rule | `isolate_actions` | Requires cbi_profile |
    | Only permissive actions | `filtered_actions` with `action_prefixes = ["ALLOW"]` | Allow-only policy |
    | Only restrictive actions | `filtered_actions` with `action_prefixes = ["DENY"]` | Deny-only policy |
    | Mixed ALLOW/DENY | `filtered_actions` with `action_prefixes = ["ALLOW", "DENY"]` | Fine-grained control |
    | Full list for custom logic | `available_actions` | Manual filtering |

    ## Complete Examples

    ### Example 1: Standard Rule with Multiple Action Types

    ### Example 2: Permissive Rule (ALLOW Only)

    ### Example 3: Restrictive Rule (DENY Only)

    ### Example 4: Multiple Applications with Intersection

    ### Example 5: CAUTION Actions Only

    ### Example 6: Viewing All Available Attributes

    ## Notes

    ### Application Intersection Behavior

    When querying multiple applications, the API returns only the intersection of actions:

    **Example**:

    * `CHATGPT_AI` alone supports 12 actions (including ALLOW_AI_ML_RENAME)
    * `GOOGLE_GEMINI` alone supports 11 actions (does NOT support RENAME)
    * Query with both: `["CHATGPT_AI", "GOOGLE_GEMINI"]` returns 9 actions (RENAME excluded)

    This ensures that rules with multiple applications only use actions that work for all of them.

    ### ISOLATE Actions Special Requirements

    ISOLATE actions have unique requirements:

    1. **Cannot be mixed**: ISOLATE actions must be used alone in a rule
    2. **Require CBI profile**: Must configure `cbi_profile` block with a valid profile
    3. **No EUN template**: Cannot set `browser_eun_template_id` when using ISOLATE
    4. **Separate rules**: Create one rule for ISOLATE actions, separate rules for other actions

    ### Validation

    The `CloudAppControlRule` resource automatically validates actions during `pulumi preview`:

    * Ensures actions are valid for the specified applications
    * Validates ISOLATE action requirements
    * Provides helpful error messages with valid action lists
    * Suggests using the data source if manual actions are invalid
    """
    __args__ = dict()
    __args__['actionPrefixes'] = action_prefixes
    __args__['cloudApps'] = cloud_apps
    __args__['type'] = type
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getCloudAppControlRuleActions:getCloudAppControlRuleActions', __args__, opts=opts, typ=GetCloudAppControlRuleActionsResult).value

    return AwaitableGetCloudAppControlRuleActionsResult(
        action_prefixes=pulumi.get(__ret__, 'action_prefixes'),
        available_actions=pulumi.get(__ret__, 'available_actions'),
        available_actions_without_isolates=pulumi.get(__ret__, 'available_actions_without_isolates'),
        cloud_apps=pulumi.get(__ret__, 'cloud_apps'),
        filtered_actions=pulumi.get(__ret__, 'filtered_actions'),
        id=pulumi.get(__ret__, 'id'),
        isolate_actions=pulumi.get(__ret__, 'isolate_actions'),
        type=pulumi.get(__ret__, 'type'))
def get_cloud_app_control_rule_actions_output(action_prefixes: Optional[pulumi.Input[Optional[Sequence[_builtins.str]]]] = None,
                                              cloud_apps: Optional[pulumi.Input[Sequence[_builtins.str]]] = None,
                                              type: Optional[pulumi.Input[_builtins.str]] = None,
                                              opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetCloudAppControlRuleActionsResult]:
    """
    * [Official documentation](https://help.zscaler.com/zia/adding-rules-cloud-app-control-policy)
    * [API documentation](https://help.zscaler.com/zia/cloud-app-control-policy#/webApplicationRules/)

    Use the **zia_cloud_app_control_rule_actions** data source to retrieve the available actions for specific cloud applications and rule types. This data source automatically handles action intersections when multiple applications are specified, returning only actions supported by ALL applications.

    **NOTE**: Note that some new actions may not be returned in the API response. This is a known issue, and is being investigated via the following issue `ONEAPI-2421`. Please contact Zscaler support for an update if the action you're attempting ton configure isn't supported or returned in the response.

    The data source provides multiple output attributes for different use cases:

    * **`available_actions_without_isolate`** - Most common use case for standard rules
    * **`isolate_actions`** - For Cloud Browser Isolation (CBI) rules
    * **`filtered_actions`** - Custom filtering by action type (ALLOW, DENY, etc.)
    * **`available_actions`** - Complete list of all actions

    ## Example Usage

    ### Standard Rule (Most Common)

    Use `available_actions_without_isolate` for standard rules that don't require Cloud Browser Isolation:

    ### Isolation Rule (CBI)

    Use `isolate_actions` for Cloud Browser Isolation rules:

    ### Multiple Applications (Intersection)

    When multiple applications are specified, the API automatically returns only actions supported by ALL applications:

    ### Filter By Action Type (ALLOW Only)

    Use `action_prefixes` to filter actions by type:

    ### Filter Multiple Action Types

    Filter for multiple action types simultaneously:

    ### File Sharing Applications

    ### Only DENY Actions

    ## Understanding Action Types

    ### Action Prefixes

    Cloud App Control rules support different action types based on the application and rule type:

    | Prefix | Description | Example | Can Mix With |
    |--------|-------------|---------|--------------|
    | `ALLOW` | Permit specific operations | ALLOW_AI_ML_CHAT | DENY, CAUTION, ESC |
    | `DENY` | Block specific operations | DENY_AI_ML_UPLOAD | ALLOW, CAUTION, ESC |
    | `BLOCK` | Block operations (some apps) | BLOCK_FILE_SHARE_DOWNLOAD | ALLOW, CAUTION |
    | `CAUTION` | Warn before allowing | CAUTION_AI_ML_WEB_USE | ALLOW, DENY, BLOCK |
    | `ISOLATE` | Cloud Browser Isolation | ISOLATE_AI_ML_WEB_USE | **Cannot mix** |
    | `ESC` | Conditional access | AI_ML_CONDITIONAL_ACCESS | ALLOW, DENY |

    ### Important Rules

    1. **ISOLATE Actions**:
       * Cannot be mixed with any other action type
       * Require `cbi_profile` configuration in the resource
       * Use `isolate_actions` attribute or filter with `action_prefixes = ["ISOLATE"]`

    2. **Multiple Applications**:
       * The API automatically returns the intersection of actions
       * Only actions supported by ALL specified applications are returned
       * Always query the data source with the same applications you'll use in the resource

    3. **Action Compatibility**:
       * Most actions can be mixed (ALLOW + DENY, ALLOW + CAUTION, etc.)
       * ISOLATE actions are the exception - they must be used alone

    ## Best Practices

    ### 1. Use Data Source Instead of Hardcoding

    **❌ Avoid hardcoding actions**:

    **✅ Use data source**:

    ### 2. Match Applications Between Data Source and Resource

    **❌ Mismatch (will cause validation errors)**:

    **✅ Correct match**:

    ### 3. Choose the Right Output Attribute

    | Use Case | Attribute to Use | Example |
    |----------|------------------|---------|
    | Standard rule (no CBI) | `available_actions_without_isolate` | Most common |
    | CBI/Isolation rule | `isolate_actions` | Requires cbi_profile |
    | Only permissive actions | `filtered_actions` with `action_prefixes = ["ALLOW"]` | Allow-only policy |
    | Only restrictive actions | `filtered_actions` with `action_prefixes = ["DENY"]` | Deny-only policy |
    | Mixed ALLOW/DENY | `filtered_actions` with `action_prefixes = ["ALLOW", "DENY"]` | Fine-grained control |
    | Full list for custom logic | `available_actions` | Manual filtering |

    ## Complete Examples

    ### Example 1: Standard Rule with Multiple Action Types

    ### Example 2: Permissive Rule (ALLOW Only)

    ### Example 3: Restrictive Rule (DENY Only)

    ### Example 4: Multiple Applications with Intersection

    ### Example 5: CAUTION Actions Only

    ### Example 6: Viewing All Available Attributes

    ## Notes

    ### Application Intersection Behavior

    When querying multiple applications, the API returns only the intersection of actions:

    **Example**:

    * `CHATGPT_AI` alone supports 12 actions (including ALLOW_AI_ML_RENAME)
    * `GOOGLE_GEMINI` alone supports 11 actions (does NOT support RENAME)
    * Query with both: `["CHATGPT_AI", "GOOGLE_GEMINI"]` returns 9 actions (RENAME excluded)

    This ensures that rules with multiple applications only use actions that work for all of them.

    ### ISOLATE Actions Special Requirements

    ISOLATE actions have unique requirements:

    1. **Cannot be mixed**: ISOLATE actions must be used alone in a rule
    2. **Require CBI profile**: Must configure `cbi_profile` block with a valid profile
    3. **No EUN template**: Cannot set `browser_eun_template_id` when using ISOLATE
    4. **Separate rules**: Create one rule for ISOLATE actions, separate rules for other actions

    ### Validation

    The `CloudAppControlRule` resource automatically validates actions during `pulumi preview`:

    * Ensures actions are valid for the specified applications
    * Validates ISOLATE action requirements
    * Provides helpful error messages with valid action lists
    * Suggests using the data source if manual actions are invalid
    """
    __args__ = dict()
    __args__['actionPrefixes'] = action_prefixes
    __args__['cloudApps'] = cloud_apps
    __args__['type'] = type
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zia:index/getCloudAppControlRuleActions:getCloudAppControlRuleActions', __args__, opts=opts, typ=GetCloudAppControlRuleActionsResult)
    return __ret__.apply(lambda __response__: GetCloudAppControlRuleActionsResult(
        action_prefixes=pulumi.get(__response__, 'action_prefixes'),
        available_actions=pulumi.get(__response__, 'available_actions'),
        available_actions_without_isolates=pulumi.get(__response__, 'available_actions_without_isolates'),
        cloud_apps=pulumi.get(__response__, 'cloud_apps'),
        filtered_actions=pulumi.get(__response__, 'filtered_actions'),
        id=pulumi.get(__response__, 'id'),
        isolate_actions=pulumi.get(__response__, 'isolate_actions'),
        type=pulumi.get(__response__, 'type')))

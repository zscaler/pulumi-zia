# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['URLFilteringRulesArgs', 'URLFilteringRules']

@pulumi.input_type
class URLFilteringRulesArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[builtins.int],
                 protocols: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 block_override: Optional[pulumi.Input[builtins.bool]] = None,
                 cbi_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesCbiProfileArgs']]]] = None,
                 ciparule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']] = None,
                 end_user_notification_url: Optional[pulumi.Input[builtins.str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 override_groups: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']] = None,
                 override_users: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 size_quota: Optional[pulumi.Input[builtins.int]] = None,
                 source_ip_groups: Optional[pulumi.Input['URLFilteringRulesSourceIpGroupsArgs']] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_quota: Optional[pulumi.Input[builtins.int]] = None,
                 time_windows: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_risk_score_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['URLFilteringRulesUsersArgs']] = None,
                 validity_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_start_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[builtins.str]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]]] = None):
        """
        The set of arguments for constructing a URLFilteringRules resource.
        :param pulumi.Input[builtins.int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        :param pulumi.Input[builtins.str] action: Action taken when traffic matches rule criteria
        :param pulumi.Input[builtins.bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input['URLFilteringRulesDepartmentsArgs'] departments: Name-ID pairs of departments for which rule must be applied
        :param pulumi.Input[builtins.str] description: Additional information about the URL Filtering rule
        :param pulumi.Input['URLFilteringRulesDeviceGroupsArgs'] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['URLFilteringRulesDevicesArgs'] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[builtins.str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
               'overrideGroups' is specified.
        :param pulumi.Input[builtins.bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input['URLFilteringRulesGroupsArgs'] groups: Name-ID pairs of groups for which rule must be applied
        :param pulumi.Input['URLFilteringRulesLabelsArgs'] labels: The URL Filtering rule's label.
        :param pulumi.Input['URLFilteringRulesLocationGroupsArgs'] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input['URLFilteringRulesLocationsArgs'] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input['URLFilteringRulesOverrideGroupsArgs'] override_groups: Name-ID pairs of groups for which this rule can be overridden.
        :param pulumi.Input['URLFilteringRulesOverrideUsersArgs'] override_users: Name-ID pairs of users for which this rule can be overridden.
        :param pulumi.Input[builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[builtins.int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input['URLFilteringRulesSourceIpGroupsArgs'] source_ip_groups: list of source ip groups
        :param pulumi.Input[builtins.int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input['URLFilteringRulesTimeWindowsArgs'] time_windows: Name-ID pairs of time interval during which rule must be enforced.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: Supported User Agent Types
        :param pulumi.Input['URLFilteringRulesUsersArgs'] users: Name-ID pairs of users for which rule must be applied
        :param pulumi.Input[builtins.str] validity_end_time: If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        :param pulumi.Input[builtins.str] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        :param pulumi.Input[builtins.str] validity_time_zone_id: If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
               IANA Format TimeZone.
        :param pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "protocols", protocols)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if block_override is not None:
            pulumi.set(__self__, "block_override", block_override)
        if cbi_profiles is not None:
            pulumi.set(__self__, "cbi_profiles", cbi_profiles)
        if ciparule is not None:
            pulumi.set(__self__, "ciparule", ciparule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if end_user_notification_url is not None:
            pulumi.set(__self__, "end_user_notification_url", end_user_notification_url)
        if enforce_time_validity is not None:
            pulumi.set(__self__, "enforce_time_validity", enforce_time_validity)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_groups is not None:
            pulumi.set(__self__, "override_groups", override_groups)
        if override_users is not None:
            pulumi.set(__self__, "override_users", override_users)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if request_methods is not None:
            pulumi.set(__self__, "request_methods", request_methods)
        if size_quota is not None:
            pulumi.set(__self__, "size_quota", size_quota)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_quota is not None:
            pulumi.set(__self__, "time_quota", time_quota)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types is not None:
            pulumi.set(__self__, "user_agent_types", user_agent_types)
        if user_risk_score_levels is not None:
            pulumi.set(__self__, "user_risk_score_levels", user_risk_score_levels)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if validity_end_time is not None:
            pulumi.set(__self__, "validity_end_time", validity_end_time)
        if validity_start_time is not None:
            pulumi.set(__self__, "validity_start_time", validity_start_time)
        if validity_time_zone_id is not None:
            pulumi.set(__self__, "validity_time_zone_id", validity_time_zone_id)
        if workload_groups is not None:
            pulumi.set(__self__, "workload_groups", workload_groups)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[builtins.int]:
        """
        Order of execution of rule with respect to other URL Filtering rules
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Action taken when traffic matches rule criteria
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="blockOverride")
    def block_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "block_override")

    @block_override.setter
    def block_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_override", value)

    @property
    @pulumi.getter(name="cbiProfiles")
    def cbi_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesCbiProfileArgs']]]]:
        return pulumi.get(self, "cbi_profiles")

    @cbi_profiles.setter
    def cbi_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesCbiProfileArgs']]]]):
        pulumi.set(self, "cbi_profiles", value)

    @property
    @pulumi.getter
    def ciparule(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, the CIPA Compliance rule is enabled
        """
        return pulumi.get(self, "ciparule")

    @ciparule.setter
    def ciparule(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ciparule", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]:
        """
        Name-ID pairs of departments for which rule must be applied
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Additional information about the URL Filtering rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="endUserNotificationUrl")
    def end_user_notification_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
        'overrideGroups' is specified.
        """
        return pulumi.get(self, "end_user_notification_url")

    @end_user_notification_url.setter
    def end_user_notification_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_user_notification_url", value)

    @property
    @pulumi.getter(name="enforceTimeValidity")
    def enforce_time_validity(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enforce a set a validity time period for the URL Filtering rule.
        """
        return pulumi.get(self, "enforce_time_validity")

    @enforce_time_validity.setter
    def enforce_time_validity(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforce_time_validity", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]:
        """
        Name-ID pairs of groups for which rule must be applied
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]:
        """
        The URL Filtering rule's label.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]:
        """
        Name-ID pairs of the location groups to which the rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]:
        """
        Name-ID pairs of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideGroups")
    def override_groups(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]:
        """
        Name-ID pairs of groups for which this rule can be overridden.
        """
        return pulumi.get(self, "override_groups")

    @override_groups.setter
    def override_groups(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]):
        pulumi.set(self, "override_groups", value)

    @property
    @pulumi.getter(name="overrideUsers")
    def override_users(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]:
        """
        Name-ID pairs of users for which this rule can be overridden.
        """
        return pulumi.get(self, "override_users")

    @override_users.setter
    def override_users(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]):
        pulumi.set(self, "override_users", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Admin rank of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Request method for which the rule must be applied. If not set, rule will be applied to all methods
        """
        return pulumi.get(self, "request_methods")

    @request_methods.setter
    def request_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "request_methods", value)

    @property
    @pulumi.getter(name="sizeQuota")
    def size_quota(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
        action is set to 'BLOCK', this field is not applicable.
        """
        return pulumi.get(self, "size_quota")

    @size_quota.setter
    def size_quota(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size_quota", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input['URLFilteringRulesSourceIpGroupsArgs']]:
        """
        list of source ip groups
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input['URLFilteringRulesSourceIpGroupsArgs']]):
        pulumi.set(self, "source_ip_groups", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeQuota")
    def time_quota(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
        action is set to 'BLOCK', this field is not applicable.
        """
        return pulumi.get(self, "time_quota")

    @time_quota.setter
    def time_quota(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "time_quota", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]:
        """
        Name-ID pairs of time interval during which rule must be enforced.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Supported User Agent Types
        """
        return pulumi.get(self, "user_agent_types")

    @user_agent_types.setter
    def user_agent_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_agent_types", value)

    @property
    @pulumi.getter(name="userRiskScoreLevels")
    def user_risk_score_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "user_risk_score_levels")

    @user_risk_score_levels.setter
    def user_risk_score_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_risk_score_levels", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['URLFilteringRulesUsersArgs']]:
        """
        Name-ID pairs of users for which rule must be applied
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['URLFilteringRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="validityEndTime")
    def validity_end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        """
        return pulumi.get(self, "validity_end_time")

    @validity_end_time.setter
    def validity_end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validity_end_time", value)

    @property
    @pulumi.getter(name="validityStartTime")
    def validity_start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        """
        return pulumi.get(self, "validity_start_time")

    @validity_start_time.setter
    def validity_start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validity_start_time", value)

    @property
    @pulumi.getter(name="validityTimeZoneId")
    def validity_time_zone_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
        IANA Format TimeZone.
        """
        return pulumi.get(self, "validity_time_zone_id")

    @validity_time_zone_id.setter
    def validity_time_zone_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validity_time_zone_id", value)

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]]]:
        """
        The list of preconfigured workload groups to which the policy must be applied
        """
        return pulumi.get(self, "workload_groups")

    @workload_groups.setter
    def workload_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]]]):
        pulumi.set(self, "workload_groups", value)


@pulumi.input_type
class _URLFilteringRulesState:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 block_override: Optional[pulumi.Input[builtins.bool]] = None,
                 cbi_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesCbiProfileArgs']]]] = None,
                 ciparule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']] = None,
                 end_user_notification_url: Optional[pulumi.Input[builtins.str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 override_groups: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']] = None,
                 override_users: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rule_id: Optional[pulumi.Input[builtins.int]] = None,
                 size_quota: Optional[pulumi.Input[builtins.int]] = None,
                 source_ip_groups: Optional[pulumi.Input['URLFilteringRulesSourceIpGroupsArgs']] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_quota: Optional[pulumi.Input[builtins.int]] = None,
                 time_windows: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_risk_score_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['URLFilteringRulesUsersArgs']] = None,
                 validity_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_start_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[builtins.str]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]]] = None):
        """
        Input properties used for looking up and filtering URLFilteringRules resources.
        :param pulumi.Input[builtins.str] action: Action taken when traffic matches rule criteria
        :param pulumi.Input[builtins.bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input['URLFilteringRulesDepartmentsArgs'] departments: Name-ID pairs of departments for which rule must be applied
        :param pulumi.Input[builtins.str] description: Additional information about the URL Filtering rule
        :param pulumi.Input['URLFilteringRulesDeviceGroupsArgs'] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input['URLFilteringRulesDevicesArgs'] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[builtins.str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
               'overrideGroups' is specified.
        :param pulumi.Input[builtins.bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input['URLFilteringRulesGroupsArgs'] groups: Name-ID pairs of groups for which rule must be applied
        :param pulumi.Input['URLFilteringRulesLabelsArgs'] labels: The URL Filtering rule's label.
        :param pulumi.Input['URLFilteringRulesLocationGroupsArgs'] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input['URLFilteringRulesLocationsArgs'] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input['URLFilteringRulesOverrideGroupsArgs'] override_groups: Name-ID pairs of groups for which this rule can be overridden.
        :param pulumi.Input['URLFilteringRulesOverrideUsersArgs'] override_users: Name-ID pairs of users for which this rule can be overridden.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        :param pulumi.Input[builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[builtins.int] rule_id: URL Filtering Rule ID
        :param pulumi.Input[builtins.int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input['URLFilteringRulesSourceIpGroupsArgs'] source_ip_groups: list of source ip groups
        :param pulumi.Input[builtins.int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input['URLFilteringRulesTimeWindowsArgs'] time_windows: Name-ID pairs of time interval during which rule must be enforced.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: Supported User Agent Types
        :param pulumi.Input['URLFilteringRulesUsersArgs'] users: Name-ID pairs of users for which rule must be applied
        :param pulumi.Input[builtins.str] validity_end_time: If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        :param pulumi.Input[builtins.str] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        :param pulumi.Input[builtins.str] validity_time_zone_id: If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
               IANA Format TimeZone.
        :param pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if block_override is not None:
            pulumi.set(__self__, "block_override", block_override)
        if cbi_profiles is not None:
            pulumi.set(__self__, "cbi_profiles", cbi_profiles)
        if ciparule is not None:
            pulumi.set(__self__, "ciparule", ciparule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if end_user_notification_url is not None:
            pulumi.set(__self__, "end_user_notification_url", end_user_notification_url)
        if enforce_time_validity is not None:
            pulumi.set(__self__, "enforce_time_validity", enforce_time_validity)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if override_groups is not None:
            pulumi.set(__self__, "override_groups", override_groups)
        if override_users is not None:
            pulumi.set(__self__, "override_users", override_users)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if request_methods is not None:
            pulumi.set(__self__, "request_methods", request_methods)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if size_quota is not None:
            pulumi.set(__self__, "size_quota", size_quota)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_quota is not None:
            pulumi.set(__self__, "time_quota", time_quota)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types is not None:
            pulumi.set(__self__, "user_agent_types", user_agent_types)
        if user_risk_score_levels is not None:
            pulumi.set(__self__, "user_risk_score_levels", user_risk_score_levels)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if validity_end_time is not None:
            pulumi.set(__self__, "validity_end_time", validity_end_time)
        if validity_start_time is not None:
            pulumi.set(__self__, "validity_start_time", validity_start_time)
        if validity_time_zone_id is not None:
            pulumi.set(__self__, "validity_time_zone_id", validity_time_zone_id)
        if workload_groups is not None:
            pulumi.set(__self__, "workload_groups", workload_groups)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Action taken when traffic matches rule criteria
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="blockOverride")
    def block_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "block_override")

    @block_override.setter
    def block_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_override", value)

    @property
    @pulumi.getter(name="cbiProfiles")
    def cbi_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesCbiProfileArgs']]]]:
        return pulumi.get(self, "cbi_profiles")

    @cbi_profiles.setter
    def cbi_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesCbiProfileArgs']]]]):
        pulumi.set(self, "cbi_profiles", value)

    @property
    @pulumi.getter
    def ciparule(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, the CIPA Compliance rule is enabled
        """
        return pulumi.get(self, "ciparule")

    @ciparule.setter
    def ciparule(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ciparule", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]:
        """
        Name-ID pairs of departments for which rule must be applied
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Additional information about the URL Filtering rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="endUserNotificationUrl")
    def end_user_notification_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
        'overrideGroups' is specified.
        """
        return pulumi.get(self, "end_user_notification_url")

    @end_user_notification_url.setter
    def end_user_notification_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_user_notification_url", value)

    @property
    @pulumi.getter(name="enforceTimeValidity")
    def enforce_time_validity(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enforce a set a validity time period for the URL Filtering rule.
        """
        return pulumi.get(self, "enforce_time_validity")

    @enforce_time_validity.setter
    def enforce_time_validity(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforce_time_validity", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]:
        """
        Name-ID pairs of groups for which rule must be applied
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]:
        """
        The URL Filtering rule's label.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]:
        """
        Name-ID pairs of the location groups to which the rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]:
        """
        Name-ID pairs of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Order of execution of rule with respect to other URL Filtering rules
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="overrideGroups")
    def override_groups(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]:
        """
        Name-ID pairs of groups for which this rule can be overridden.
        """
        return pulumi.get(self, "override_groups")

    @override_groups.setter
    def override_groups(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]):
        pulumi.set(self, "override_groups", value)

    @property
    @pulumi.getter(name="overrideUsers")
    def override_users(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]:
        """
        Name-ID pairs of users for which this rule can be overridden.
        """
        return pulumi.get(self, "override_users")

    @override_users.setter
    def override_users(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]):
        pulumi.set(self, "override_users", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Admin rank of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Request method for which the rule must be applied. If not set, rule will be applied to all methods
        """
        return pulumi.get(self, "request_methods")

    @request_methods.setter
    def request_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "request_methods", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        URL Filtering Rule ID
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="sizeQuota")
    def size_quota(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
        action is set to 'BLOCK', this field is not applicable.
        """
        return pulumi.get(self, "size_quota")

    @size_quota.setter
    def size_quota(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size_quota", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input['URLFilteringRulesSourceIpGroupsArgs']]:
        """
        list of source ip groups
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input['URLFilteringRulesSourceIpGroupsArgs']]):
        pulumi.set(self, "source_ip_groups", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeQuota")
    def time_quota(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
        action is set to 'BLOCK', this field is not applicable.
        """
        return pulumi.get(self, "time_quota")

    @time_quota.setter
    def time_quota(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "time_quota", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]:
        """
        Name-ID pairs of time interval during which rule must be enforced.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Supported User Agent Types
        """
        return pulumi.get(self, "user_agent_types")

    @user_agent_types.setter
    def user_agent_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_agent_types", value)

    @property
    @pulumi.getter(name="userRiskScoreLevels")
    def user_risk_score_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "user_risk_score_levels")

    @user_risk_score_levels.setter
    def user_risk_score_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_risk_score_levels", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['URLFilteringRulesUsersArgs']]:
        """
        Name-ID pairs of users for which rule must be applied
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['URLFilteringRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="validityEndTime")
    def validity_end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        """
        return pulumi.get(self, "validity_end_time")

    @validity_end_time.setter
    def validity_end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validity_end_time", value)

    @property
    @pulumi.getter(name="validityStartTime")
    def validity_start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        """
        return pulumi.get(self, "validity_start_time")

    @validity_start_time.setter
    def validity_start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validity_start_time", value)

    @property
    @pulumi.getter(name="validityTimeZoneId")
    def validity_time_zone_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
        IANA Format TimeZone.
        """
        return pulumi.get(self, "validity_time_zone_id")

    @validity_time_zone_id.setter
    def validity_time_zone_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validity_time_zone_id", value)

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]]]:
        """
        The list of preconfigured workload groups to which the policy must be applied
        """
        return pulumi.get(self, "workload_groups")

    @workload_groups.setter
    def workload_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesWorkloadGroupArgs']]]]):
        pulumi.set(self, "workload_groups", value)


@pulumi.type_token("zia:index/uRLFilteringRules:URLFilteringRules")
class URLFilteringRules(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 block_override: Optional[pulumi.Input[builtins.bool]] = None,
                 cbi_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesCbiProfileArgs', 'URLFilteringRulesCbiProfileArgsDict']]]]] = None,
                 ciparule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input[Union['URLFilteringRulesDepartmentsArgs', 'URLFilteringRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input[Union['URLFilteringRulesDeviceGroupsArgs', 'URLFilteringRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['URLFilteringRulesDevicesArgs', 'URLFilteringRulesDevicesArgsDict']]] = None,
                 end_user_notification_url: Optional[pulumi.Input[builtins.str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input[Union['URLFilteringRulesGroupsArgs', 'URLFilteringRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['URLFilteringRulesLabelsArgs', 'URLFilteringRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['URLFilteringRulesLocationGroupsArgs', 'URLFilteringRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['URLFilteringRulesLocationsArgs', 'URLFilteringRulesLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 override_groups: Optional[pulumi.Input[Union['URLFilteringRulesOverrideGroupsArgs', 'URLFilteringRulesOverrideGroupsArgsDict']]] = None,
                 override_users: Optional[pulumi.Input[Union['URLFilteringRulesOverrideUsersArgs', 'URLFilteringRulesOverrideUsersArgsDict']]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 size_quota: Optional[pulumi.Input[builtins.int]] = None,
                 source_ip_groups: Optional[pulumi.Input[Union['URLFilteringRulesSourceIpGroupsArgs', 'URLFilteringRulesSourceIpGroupsArgsDict']]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_quota: Optional[pulumi.Input[builtins.int]] = None,
                 time_windows: Optional[pulumi.Input[Union['URLFilteringRulesTimeWindowsArgs', 'URLFilteringRulesTimeWindowsArgsDict']]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_risk_score_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['URLFilteringRulesUsersArgs', 'URLFilteringRulesUsersArgsDict']]] = None,
                 validity_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_start_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[builtins.str]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesWorkloadGroupArgs', 'URLFilteringRulesWorkloadGroupArgsDict']]]]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-url-filtering)
        * [API documentation](https://help.zscaler.com/zia/url-filtering-policy#/urlFilteringRules-post)

        The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.

        ## Example Usage

        ### ALLOW ACTION

        ### BLOCK ACTION

        ### CAUTION ACTION

        ### ISOLATE ACTION

        ⚠️ **WARNING 1:**: Creating a URL Filtering rule with the action of `ISOLATE` requires the Cloud Browser Isolation subscription. To learn more, contact Zscaler Support or your local account team.

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        **zia_url_filtering_rules** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.str] action: Action taken when traffic matches rule criteria
        :param pulumi.Input[builtins.bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input[Union['URLFilteringRulesDepartmentsArgs', 'URLFilteringRulesDepartmentsArgsDict']] departments: Name-ID pairs of departments for which rule must be applied
        :param pulumi.Input[builtins.str] description: Additional information about the URL Filtering rule
        :param pulumi.Input[Union['URLFilteringRulesDeviceGroupsArgs', 'URLFilteringRulesDeviceGroupsArgsDict']] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['URLFilteringRulesDevicesArgs', 'URLFilteringRulesDevicesArgsDict']] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[builtins.str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
               'overrideGroups' is specified.
        :param pulumi.Input[builtins.bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input[Union['URLFilteringRulesGroupsArgs', 'URLFilteringRulesGroupsArgsDict']] groups: Name-ID pairs of groups for which rule must be applied
        :param pulumi.Input[Union['URLFilteringRulesLabelsArgs', 'URLFilteringRulesLabelsArgsDict']] labels: The URL Filtering rule's label.
        :param pulumi.Input[Union['URLFilteringRulesLocationGroupsArgs', 'URLFilteringRulesLocationGroupsArgsDict']] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input[Union['URLFilteringRulesLocationsArgs', 'URLFilteringRulesLocationsArgsDict']] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input[Union['URLFilteringRulesOverrideGroupsArgs', 'URLFilteringRulesOverrideGroupsArgsDict']] override_groups: Name-ID pairs of groups for which this rule can be overridden.
        :param pulumi.Input[Union['URLFilteringRulesOverrideUsersArgs', 'URLFilteringRulesOverrideUsersArgsDict']] override_users: Name-ID pairs of users for which this rule can be overridden.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        :param pulumi.Input[builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[builtins.int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input[Union['URLFilteringRulesSourceIpGroupsArgs', 'URLFilteringRulesSourceIpGroupsArgsDict']] source_ip_groups: list of source ip groups
        :param pulumi.Input[builtins.int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input[Union['URLFilteringRulesTimeWindowsArgs', 'URLFilteringRulesTimeWindowsArgsDict']] time_windows: Name-ID pairs of time interval during which rule must be enforced.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: Supported User Agent Types
        :param pulumi.Input[Union['URLFilteringRulesUsersArgs', 'URLFilteringRulesUsersArgsDict']] users: Name-ID pairs of users for which rule must be applied
        :param pulumi.Input[builtins.str] validity_end_time: If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        :param pulumi.Input[builtins.str] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        :param pulumi.Input[builtins.str] validity_time_zone_id: If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
               IANA Format TimeZone.
        :param pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesWorkloadGroupArgs', 'URLFilteringRulesWorkloadGroupArgsDict']]]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: URLFilteringRulesArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-url-filtering)
        * [API documentation](https://help.zscaler.com/zia/url-filtering-policy#/urlFilteringRules-post)

        The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.

        ## Example Usage

        ### ALLOW ACTION

        ### BLOCK ACTION

        ### CAUTION ACTION

        ### ISOLATE ACTION

        ⚠️ **WARNING 1:**: Creating a URL Filtering rule with the action of `ISOLATE` requires the Cloud Browser Isolation subscription. To learn more, contact Zscaler Support or your local account team.

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        **zia_url_filtering_rules** can be imported by using `<RULE_ID>` or `<RULE_NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/uRLFilteringRules:URLFilteringRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param URLFilteringRulesArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(URLFilteringRulesArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 block_override: Optional[pulumi.Input[builtins.bool]] = None,
                 cbi_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesCbiProfileArgs', 'URLFilteringRulesCbiProfileArgsDict']]]]] = None,
                 ciparule: Optional[pulumi.Input[builtins.bool]] = None,
                 departments: Optional[pulumi.Input[Union['URLFilteringRulesDepartmentsArgs', 'URLFilteringRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 device_groups: Optional[pulumi.Input[Union['URLFilteringRulesDeviceGroupsArgs', 'URLFilteringRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['URLFilteringRulesDevicesArgs', 'URLFilteringRulesDevicesArgsDict']]] = None,
                 end_user_notification_url: Optional[pulumi.Input[builtins.str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input[Union['URLFilteringRulesGroupsArgs', 'URLFilteringRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['URLFilteringRulesLabelsArgs', 'URLFilteringRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['URLFilteringRulesLocationGroupsArgs', 'URLFilteringRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['URLFilteringRulesLocationsArgs', 'URLFilteringRulesLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 override_groups: Optional[pulumi.Input[Union['URLFilteringRulesOverrideGroupsArgs', 'URLFilteringRulesOverrideGroupsArgsDict']]] = None,
                 override_users: Optional[pulumi.Input[Union['URLFilteringRulesOverrideUsersArgs', 'URLFilteringRulesOverrideUsersArgsDict']]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 size_quota: Optional[pulumi.Input[builtins.int]] = None,
                 source_ip_groups: Optional[pulumi.Input[Union['URLFilteringRulesSourceIpGroupsArgs', 'URLFilteringRulesSourceIpGroupsArgsDict']]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_quota: Optional[pulumi.Input[builtins.int]] = None,
                 time_windows: Optional[pulumi.Input[Union['URLFilteringRulesTimeWindowsArgs', 'URLFilteringRulesTimeWindowsArgsDict']]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_risk_score_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['URLFilteringRulesUsersArgs', 'URLFilteringRulesUsersArgsDict']]] = None,
                 validity_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_start_time: Optional[pulumi.Input[builtins.str]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[builtins.str]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesWorkloadGroupArgs', 'URLFilteringRulesWorkloadGroupArgsDict']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = URLFilteringRulesArgs.__new__(URLFilteringRulesArgs)

            __props__.__dict__["action"] = action
            __props__.__dict__["block_override"] = block_override
            __props__.__dict__["cbi_profiles"] = cbi_profiles
            __props__.__dict__["ciparule"] = ciparule
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            __props__.__dict__["device_groups"] = device_groups
            __props__.__dict__["device_trust_levels"] = device_trust_levels
            __props__.__dict__["devices"] = devices
            __props__.__dict__["end_user_notification_url"] = end_user_notification_url
            __props__.__dict__["enforce_time_validity"] = enforce_time_validity
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["name"] = name
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            __props__.__dict__["override_groups"] = override_groups
            __props__.__dict__["override_users"] = override_users
            if protocols is None and not opts.urn:
                raise TypeError("Missing required property 'protocols'")
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["rank"] = rank
            __props__.__dict__["request_methods"] = request_methods
            __props__.__dict__["size_quota"] = size_quota
            __props__.__dict__["source_ip_groups"] = source_ip_groups
            __props__.__dict__["state"] = state
            __props__.__dict__["time_quota"] = time_quota
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["url_categories"] = url_categories
            __props__.__dict__["user_agent_types"] = user_agent_types
            __props__.__dict__["user_risk_score_levels"] = user_risk_score_levels
            __props__.__dict__["users"] = users
            __props__.__dict__["validity_end_time"] = validity_end_time
            __props__.__dict__["validity_start_time"] = validity_start_time
            __props__.__dict__["validity_time_zone_id"] = validity_time_zone_id
            __props__.__dict__["workload_groups"] = workload_groups
            __props__.__dict__["rule_id"] = None
        super(URLFilteringRules, __self__).__init__(
            'zia:index/uRLFilteringRules:URLFilteringRules',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            action: Optional[pulumi.Input[builtins.str]] = None,
            block_override: Optional[pulumi.Input[builtins.bool]] = None,
            cbi_profiles: Optional[pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesCbiProfileArgs', 'URLFilteringRulesCbiProfileArgsDict']]]]] = None,
            ciparule: Optional[pulumi.Input[builtins.bool]] = None,
            departments: Optional[pulumi.Input[Union['URLFilteringRulesDepartmentsArgs', 'URLFilteringRulesDepartmentsArgsDict']]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            device_groups: Optional[pulumi.Input[Union['URLFilteringRulesDeviceGroupsArgs', 'URLFilteringRulesDeviceGroupsArgsDict']]] = None,
            device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            devices: Optional[pulumi.Input[Union['URLFilteringRulesDevicesArgs', 'URLFilteringRulesDevicesArgsDict']]] = None,
            end_user_notification_url: Optional[pulumi.Input[builtins.str]] = None,
            enforce_time_validity: Optional[pulumi.Input[builtins.bool]] = None,
            groups: Optional[pulumi.Input[Union['URLFilteringRulesGroupsArgs', 'URLFilteringRulesGroupsArgsDict']]] = None,
            labels: Optional[pulumi.Input[Union['URLFilteringRulesLabelsArgs', 'URLFilteringRulesLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['URLFilteringRulesLocationGroupsArgs', 'URLFilteringRulesLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['URLFilteringRulesLocationsArgs', 'URLFilteringRulesLocationsArgsDict']]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            order: Optional[pulumi.Input[builtins.int]] = None,
            override_groups: Optional[pulumi.Input[Union['URLFilteringRulesOverrideGroupsArgs', 'URLFilteringRulesOverrideGroupsArgsDict']]] = None,
            override_users: Optional[pulumi.Input[Union['URLFilteringRulesOverrideUsersArgs', 'URLFilteringRulesOverrideUsersArgsDict']]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            rank: Optional[pulumi.Input[builtins.int]] = None,
            request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            rule_id: Optional[pulumi.Input[builtins.int]] = None,
            size_quota: Optional[pulumi.Input[builtins.int]] = None,
            source_ip_groups: Optional[pulumi.Input[Union['URLFilteringRulesSourceIpGroupsArgs', 'URLFilteringRulesSourceIpGroupsArgsDict']]] = None,
            state: Optional[pulumi.Input[builtins.str]] = None,
            time_quota: Optional[pulumi.Input[builtins.int]] = None,
            time_windows: Optional[pulumi.Input[Union['URLFilteringRulesTimeWindowsArgs', 'URLFilteringRulesTimeWindowsArgsDict']]] = None,
            url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            user_risk_score_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            users: Optional[pulumi.Input[Union['URLFilteringRulesUsersArgs', 'URLFilteringRulesUsersArgsDict']]] = None,
            validity_end_time: Optional[pulumi.Input[builtins.str]] = None,
            validity_start_time: Optional[pulumi.Input[builtins.str]] = None,
            validity_time_zone_id: Optional[pulumi.Input[builtins.str]] = None,
            workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesWorkloadGroupArgs', 'URLFilteringRulesWorkloadGroupArgsDict']]]]] = None) -> 'URLFilteringRules':
        """
        Get an existing URLFilteringRules resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.str] action: Action taken when traffic matches rule criteria
        :param pulumi.Input[builtins.bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input[Union['URLFilteringRulesDepartmentsArgs', 'URLFilteringRulesDepartmentsArgsDict']] departments: Name-ID pairs of departments for which rule must be applied
        :param pulumi.Input[builtins.str] description: Additional information about the URL Filtering rule
        :param pulumi.Input[Union['URLFilteringRulesDeviceGroupsArgs', 'URLFilteringRulesDeviceGroupsArgsDict']] device_groups: This field is applicable for devices that are managed using Zscaler Client Connector.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
               using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
               Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        :param pulumi.Input[Union['URLFilteringRulesDevicesArgs', 'URLFilteringRulesDevicesArgsDict']] devices: Name-ID pairs of devices for which rule must be applied.
        :param pulumi.Input[builtins.str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
               'overrideGroups' is specified.
        :param pulumi.Input[builtins.bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input[Union['URLFilteringRulesGroupsArgs', 'URLFilteringRulesGroupsArgsDict']] groups: Name-ID pairs of groups for which rule must be applied
        :param pulumi.Input[Union['URLFilteringRulesLabelsArgs', 'URLFilteringRulesLabelsArgsDict']] labels: The URL Filtering rule's label.
        :param pulumi.Input[Union['URLFilteringRulesLocationGroupsArgs', 'URLFilteringRulesLocationGroupsArgsDict']] location_groups: Name-ID pairs of the location groups to which the rule must be applied.
        :param pulumi.Input[Union['URLFilteringRulesLocationsArgs', 'URLFilteringRulesLocationsArgsDict']] locations: Name-ID pairs of locations for which rule must be applied
        :param pulumi.Input[builtins.str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[builtins.int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input[Union['URLFilteringRulesOverrideGroupsArgs', 'URLFilteringRulesOverrideGroupsArgsDict']] override_groups: Name-ID pairs of groups for which this rule can be overridden.
        :param pulumi.Input[Union['URLFilteringRulesOverrideUsersArgs', 'URLFilteringRulesOverrideUsersArgsDict']] override_users: Name-ID pairs of users for which this rule can be overridden.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        :param pulumi.Input[builtins.int] rank: Admin rank of the Firewall Filtering policy rule
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[builtins.int] rule_id: URL Filtering Rule ID
        :param pulumi.Input[builtins.int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input[Union['URLFilteringRulesSourceIpGroupsArgs', 'URLFilteringRulesSourceIpGroupsArgsDict']] source_ip_groups: list of source ip groups
        :param pulumi.Input[builtins.int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
               action is set to 'BLOCK', this field is not applicable.
        :param pulumi.Input[Union['URLFilteringRulesTimeWindowsArgs', 'URLFilteringRulesTimeWindowsArgsDict']] time_windows: Name-ID pairs of time interval during which rule must be enforced.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: Supported User Agent Types
        :param pulumi.Input[Union['URLFilteringRulesUsersArgs', 'URLFilteringRulesUsersArgsDict']] users: Name-ID pairs of users for which rule must be applied
        :param pulumi.Input[builtins.str] validity_end_time: If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        :param pulumi.Input[builtins.str] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        :param pulumi.Input[builtins.str] validity_time_zone_id: If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
               IANA Format TimeZone.
        :param pulumi.Input[Sequence[pulumi.Input[Union['URLFilteringRulesWorkloadGroupArgs', 'URLFilteringRulesWorkloadGroupArgsDict']]]] workload_groups: The list of preconfigured workload groups to which the policy must be applied
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _URLFilteringRulesState.__new__(_URLFilteringRulesState)

        __props__.__dict__["action"] = action
        __props__.__dict__["block_override"] = block_override
        __props__.__dict__["cbi_profiles"] = cbi_profiles
        __props__.__dict__["ciparule"] = ciparule
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["device_groups"] = device_groups
        __props__.__dict__["device_trust_levels"] = device_trust_levels
        __props__.__dict__["devices"] = devices
        __props__.__dict__["end_user_notification_url"] = end_user_notification_url
        __props__.__dict__["enforce_time_validity"] = enforce_time_validity
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["name"] = name
        __props__.__dict__["order"] = order
        __props__.__dict__["override_groups"] = override_groups
        __props__.__dict__["override_users"] = override_users
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["rank"] = rank
        __props__.__dict__["request_methods"] = request_methods
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["size_quota"] = size_quota
        __props__.__dict__["source_ip_groups"] = source_ip_groups
        __props__.__dict__["state"] = state
        __props__.__dict__["time_quota"] = time_quota
        __props__.__dict__["time_windows"] = time_windows
        __props__.__dict__["url_categories"] = url_categories
        __props__.__dict__["user_agent_types"] = user_agent_types
        __props__.__dict__["user_risk_score_levels"] = user_risk_score_levels
        __props__.__dict__["users"] = users
        __props__.__dict__["validity_end_time"] = validity_end_time
        __props__.__dict__["validity_start_time"] = validity_start_time
        __props__.__dict__["validity_time_zone_id"] = validity_time_zone_id
        __props__.__dict__["workload_groups"] = workload_groups
        return URLFilteringRules(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        Action taken when traffic matches rule criteria
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="blockOverride")
    def block_override(self) -> pulumi.Output[Optional[builtins.bool]]:
        return pulumi.get(self, "block_override")

    @property
    @pulumi.getter(name="cbiProfiles")
    def cbi_profiles(self) -> pulumi.Output[Optional[Sequence['outputs.URLFilteringRulesCbiProfile']]]:
        return pulumi.get(self, "cbi_profiles")

    @property
    @pulumi.getter
    def ciparule(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If set to true, the CIPA Compliance rule is enabled
        """
        return pulumi.get(self, "ciparule")

    @property
    @pulumi.getter
    def departments(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesDepartments']]:
        """
        Name-ID pairs of departments for which rule must be applied
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        Additional information about the URL Filtering rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesDeviceGroups']]:
        """
        This field is applicable for devices that are managed using Zscaler Client Connector.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed
        using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the
        Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_trust_levels")

    @property
    @pulumi.getter
    def devices(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesDevices']]:
        """
        Name-ID pairs of devices for which rule must be applied.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="endUserNotificationUrl")
    def end_user_notification_url(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or
        'overrideGroups' is specified.
        """
        return pulumi.get(self, "end_user_notification_url")

    @property
    @pulumi.getter(name="enforceTimeValidity")
    def enforce_time_validity(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Enforce a set a validity time period for the URL Filtering rule.
        """
        return pulumi.get(self, "enforce_time_validity")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesGroups']]:
        """
        Name-ID pairs of groups for which rule must be applied
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesLabels']]:
        """
        The URL Filtering rule's label.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesLocationGroups']]:
        """
        Name-ID pairs of the location groups to which the rule must be applied.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesLocations']]:
        """
        Name-ID pairs of locations for which rule must be applied
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> pulumi.Output[builtins.int]:
        """
        Order of execution of rule with respect to other URL Filtering rules
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="overrideGroups")
    def override_groups(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesOverrideGroups']]:
        """
        Name-ID pairs of groups for which this rule can be overridden.
        """
        return pulumi.get(self, "override_groups")

    @property
    @pulumi.getter(name="overrideUsers")
    def override_users(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesOverrideUsers']]:
        """
        Name-ID pairs of users for which this rule can be overridden.
        """
        return pulumi.get(self, "override_users")

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`, `WEBSOCKETSSL_RULE`, `WEBSOCKET_RULE`,
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        Admin rank of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        Request method for which the rule must be applied. If not set, rule will be applied to all methods
        """
        return pulumi.get(self, "request_methods")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[builtins.int]:
        """
        URL Filtering Rule ID
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="sizeQuota")
    def size_quota(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
        action is set to 'BLOCK', this field is not applicable.
        """
        return pulumi.get(self, "size_quota")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesSourceIpGroups']]:
        """
        list of source ip groups
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[Optional[builtins.str]]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeQuota")
    def time_quota(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule
        action is set to 'BLOCK', this field is not applicable.
        """
        return pulumi.get(self, "time_quota")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesTimeWindows']]:
        """
        Name-ID pairs of time interval during which rule must be enforced.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        Supported User Agent Types
        """
        return pulumi.get(self, "user_agent_types")

    @property
    @pulumi.getter(name="userRiskScoreLevels")
    def user_risk_score_levels(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        return pulumi.get(self, "user_risk_score_levels")

    @property
    @pulumi.getter
    def users(self) -> pulumi.Output[Optional['outputs.URLFilteringRulesUsers']]:
        """
        Name-ID pairs of users for which rule must be applied
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="validityEndTime")
    def validity_end_time(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        """
        return pulumi.get(self, "validity_end_time")

    @property
    @pulumi.getter(name="validityStartTime")
    def validity_start_time(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        """
        return pulumi.get(self, "validity_start_time")

    @property
    @pulumi.getter(name="validityTimeZoneId")
    def validity_time_zone_id(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID. Use
        IANA Format TimeZone.
        """
        return pulumi.get(self, "validity_time_zone_id")

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> pulumi.Output[Sequence['outputs.URLFilteringRulesWorkloadGroup']]:
        """
        The list of preconfigured workload groups to which the policy must be applied
        """
        return pulumi.get(self, "workload_groups")


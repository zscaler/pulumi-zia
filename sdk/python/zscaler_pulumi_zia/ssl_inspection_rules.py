# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['SSLInspectionRulesArgs', 'SSLInspectionRules']

@pulumi.input_type
class SSLInspectionRulesArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[builtins.int],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input['SSLInspectionRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_ip_groups: Optional[pulumi.Input['SSLInspectionRulesDestIpGroupsArgs']] = None,
                 device_groups: Optional[pulumi.Input['SSLInspectionRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['SSLInspectionRulesDevicesArgs']] = None,
                 groups: Optional[pulumi.Input['SSLInspectionRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['SSLInspectionRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['SSLInspectionRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['SSLInspectionRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 platforms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 proxy_gateways: Optional[pulumi.Input['SSLInspectionRulesProxyGatewaysArgs']] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 road_warrior_for_kerberos: Optional[pulumi.Input[builtins.bool]] = None,
                 source_ip_groups: Optional[pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs']] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['SSLInspectionRulesTimeWindowsArgs']] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['SSLInspectionRulesUsersArgs']] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]]] = None):
        """
        The set of arguments for constructing a SSLInspectionRules resource.
        :param pulumi.Input[builtins.int] order: (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]] actions: (Block List) - Action taken when the traffic matches policy
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        :param pulumi.Input['SSLInspectionRulesDepartmentsArgs'] departments: (Block List) - ID pairs of departments for which the rule is applied.
        :param pulumi.Input[builtins.str] description: (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input['SSLInspectionRulesDestIpGroupsArgs'] dest_ip_groups: (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        :param pulumi.Input['SSLInspectionRulesDeviceGroupsArgs'] device_groups: (Block List) - ID pairs of device groups for which the rule is applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input['SSLInspectionRulesDevicesArgs'] devices: (Block List) - ID pairs of devices for which the rule is applied
        :param pulumi.Input['SSLInspectionRulesGroupsArgs'] groups: (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        :param pulumi.Input['SSLInspectionRulesLabelsArgs'] labels: (Block List) - ID pairs of labels associated with the rule.
        :param pulumi.Input['SSLInspectionRulesLocationGroupsArgs'] location_groups: (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        :param pulumi.Input['SSLInspectionRulesLocationsArgs'] locations: (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        :param pulumi.Input[builtins.str] name: The name of the SSL Inspection rule
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] platforms: (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        :param pulumi.Input['SSLInspectionRulesProxyGatewaysArgs'] proxy_gateways: (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        :param pulumi.Input[builtins.int] rank: (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.bool] road_warrior_for_kerberos: (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        :param pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs'] source_ip_groups: (Block List) - ID pairs of source IP address groups for which the rule is applied.
        :param pulumi.Input[builtins.str] state: (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input['SSLInspectionRulesTimeWindowsArgs'] time_windows: (Block List) - The time intervals during which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: (Set of String) -  A list of user agent types the rule applies to.
        :param pulumi.Input['SSLInspectionRulesUsersArgs'] users: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]] workload_groups: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]] zpa_app_segments: (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        pulumi.set(__self__, "order", order)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if cloud_applications is not None:
            pulumi.set(__self__, "cloud_applications", cloud_applications)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dest_ip_groups is not None:
            pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if platforms is not None:
            pulumi.set(__self__, "platforms", platforms)
        if proxy_gateways is not None:
            pulumi.set(__self__, "proxy_gateways", proxy_gateways)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if road_warrior_for_kerberos is not None:
            pulumi.set(__self__, "road_warrior_for_kerberos", road_warrior_for_kerberos)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types is not None:
            pulumi.set(__self__, "user_agent_types", user_agent_types)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if workload_groups is not None:
            pulumi.set(__self__, "workload_groups", workload_groups)
        if zpa_app_segments is not None:
            pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[builtins.int]:
        """
        (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]]]:
        """
        (Block List) - Action taken when the traffic matches policy
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        """
        return pulumi.get(self, "cloud_applications")

    @cloud_applications.setter
    def cloud_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "cloud_applications", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['SSLInspectionRulesDepartmentsArgs']]:
        """
        (Block List) - ID pairs of departments for which the rule is applied.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['SSLInspectionRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesDestIpGroupsArgs']]:
        """
        (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "dest_ip_groups")

    @dest_ip_groups.setter
    def dest_ip_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesDestIpGroupsArgs']]):
        pulumi.set(self, "dest_ip_groups", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesDeviceGroupsArgs']]:
        """
        (Block List) - ID pairs of device groups for which the rule is applied.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['SSLInspectionRulesDevicesArgs']]:
        """
        (Block List) - ID pairs of devices for which the rule is applied
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['SSLInspectionRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['SSLInspectionRulesGroupsArgs']]:
        """
        (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['SSLInspectionRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['SSLInspectionRulesLabelsArgs']]:
        """
        (Block List) - ID pairs of labels associated with the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['SSLInspectionRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesLocationGroupsArgs']]:
        """
        (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['SSLInspectionRulesLocationsArgs']]:
        """
        (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['SSLInspectionRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the SSL Inspection rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def platforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        """
        return pulumi.get(self, "platforms")

    @platforms.setter
    def platforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "platforms", value)

    @property
    @pulumi.getter(name="proxyGateways")
    def proxy_gateways(self) -> Optional[pulumi.Input['SSLInspectionRulesProxyGatewaysArgs']]:
        """
        (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        """
        return pulumi.get(self, "proxy_gateways")

    @proxy_gateways.setter
    def proxy_gateways(self, value: Optional[pulumi.Input['SSLInspectionRulesProxyGatewaysArgs']]):
        pulumi.set(self, "proxy_gateways", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="roadWarriorForKerberos")
    def road_warrior_for_kerberos(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        """
        return pulumi.get(self, "road_warrior_for_kerberos")

    @road_warrior_for_kerberos.setter
    def road_warrior_for_kerberos(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "road_warrior_for_kerberos", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs']]:
        """
        (Block List) - ID pairs of source IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs']]):
        pulumi.set(self, "source_ip_groups", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['SSLInspectionRulesTimeWindowsArgs']]:
        """
        (Block List) - The time intervals during which the rule applies
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['SSLInspectionRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  A list of user agent types the rule applies to.
        """
        return pulumi.get(self, "user_agent_types")

    @user_agent_types.setter
    def user_agent_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_agent_types", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['SSLInspectionRulesUsersArgs']]:
        """
        (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['SSLInspectionRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]]]:
        """
        (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "workload_groups")

    @workload_groups.setter
    def workload_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]]]):
        pulumi.set(self, "workload_groups", value)

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]]]:
        """
        (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        return pulumi.get(self, "zpa_app_segments")

    @zpa_app_segments.setter
    def zpa_app_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]]]):
        pulumi.set(self, "zpa_app_segments", value)


@pulumi.input_type
class _SSLInspectionRulesState:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input['SSLInspectionRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_ip_groups: Optional[pulumi.Input['SSLInspectionRulesDestIpGroupsArgs']] = None,
                 device_groups: Optional[pulumi.Input['SSLInspectionRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input['SSLInspectionRulesDevicesArgs']] = None,
                 groups: Optional[pulumi.Input['SSLInspectionRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['SSLInspectionRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['SSLInspectionRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['SSLInspectionRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 platforms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 proxy_gateways: Optional[pulumi.Input['SSLInspectionRulesProxyGatewaysArgs']] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 road_warrior_for_kerberos: Optional[pulumi.Input[builtins.bool]] = None,
                 rule_id: Optional[pulumi.Input[builtins.int]] = None,
                 source_ip_groups: Optional[pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs']] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input['SSLInspectionRulesTimeWindowsArgs']] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['SSLInspectionRulesUsersArgs']] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]]] = None):
        """
        Input properties used for looking up and filtering SSLInspectionRules resources.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]] actions: (Block List) - Action taken when the traffic matches policy
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        :param pulumi.Input['SSLInspectionRulesDepartmentsArgs'] departments: (Block List) - ID pairs of departments for which the rule is applied.
        :param pulumi.Input[builtins.str] description: (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input['SSLInspectionRulesDestIpGroupsArgs'] dest_ip_groups: (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        :param pulumi.Input['SSLInspectionRulesDeviceGroupsArgs'] device_groups: (Block List) - ID pairs of device groups for which the rule is applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input['SSLInspectionRulesDevicesArgs'] devices: (Block List) - ID pairs of devices for which the rule is applied
        :param pulumi.Input['SSLInspectionRulesGroupsArgs'] groups: (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        :param pulumi.Input['SSLInspectionRulesLabelsArgs'] labels: (Block List) - ID pairs of labels associated with the rule.
        :param pulumi.Input['SSLInspectionRulesLocationGroupsArgs'] location_groups: (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        :param pulumi.Input['SSLInspectionRulesLocationsArgs'] locations: (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        :param pulumi.Input[builtins.str] name: The name of the SSL Inspection rule
        :param pulumi.Input[builtins.int] order: (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] platforms: (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        :param pulumi.Input['SSLInspectionRulesProxyGatewaysArgs'] proxy_gateways: (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        :param pulumi.Input[builtins.int] rank: (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.bool] road_warrior_for_kerberos: (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        :param pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs'] source_ip_groups: (Block List) - ID pairs of source IP address groups for which the rule is applied.
        :param pulumi.Input[builtins.str] state: (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input['SSLInspectionRulesTimeWindowsArgs'] time_windows: (Block List) - The time intervals during which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: (Set of String) -  A list of user agent types the rule applies to.
        :param pulumi.Input['SSLInspectionRulesUsersArgs'] users: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]] workload_groups: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]] zpa_app_segments: (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if cloud_applications is not None:
            pulumi.set(__self__, "cloud_applications", cloud_applications)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dest_ip_groups is not None:
            pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if platforms is not None:
            pulumi.set(__self__, "platforms", platforms)
        if proxy_gateways is not None:
            pulumi.set(__self__, "proxy_gateways", proxy_gateways)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if road_warrior_for_kerberos is not None:
            pulumi.set(__self__, "road_warrior_for_kerberos", road_warrior_for_kerberos)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types is not None:
            pulumi.set(__self__, "user_agent_types", user_agent_types)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if workload_groups is not None:
            pulumi.set(__self__, "workload_groups", workload_groups)
        if zpa_app_segments is not None:
            pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]]]:
        """
        (Block List) - Action taken when the traffic matches policy
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        """
        return pulumi.get(self, "cloud_applications")

    @cloud_applications.setter
    def cloud_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "cloud_applications", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['SSLInspectionRulesDepartmentsArgs']]:
        """
        (Block List) - ID pairs of departments for which the rule is applied.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['SSLInspectionRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesDestIpGroupsArgs']]:
        """
        (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "dest_ip_groups")

    @dest_ip_groups.setter
    def dest_ip_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesDestIpGroupsArgs']]):
        pulumi.set(self, "dest_ip_groups", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesDeviceGroupsArgs']]:
        """
        (Block List) - ID pairs of device groups for which the rule is applied.
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['SSLInspectionRulesDevicesArgs']]:
        """
        (Block List) - ID pairs of devices for which the rule is applied
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['SSLInspectionRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['SSLInspectionRulesGroupsArgs']]:
        """
        (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['SSLInspectionRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['SSLInspectionRulesLabelsArgs']]:
        """
        (Block List) - ID pairs of labels associated with the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['SSLInspectionRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesLocationGroupsArgs']]:
        """
        (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['SSLInspectionRulesLocationsArgs']]:
        """
        (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['SSLInspectionRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the SSL Inspection rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def platforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        """
        return pulumi.get(self, "platforms")

    @platforms.setter
    def platforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "platforms", value)

    @property
    @pulumi.getter(name="proxyGateways")
    def proxy_gateways(self) -> Optional[pulumi.Input['SSLInspectionRulesProxyGatewaysArgs']]:
        """
        (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        """
        return pulumi.get(self, "proxy_gateways")

    @proxy_gateways.setter
    def proxy_gateways(self, value: Optional[pulumi.Input['SSLInspectionRulesProxyGatewaysArgs']]):
        pulumi.set(self, "proxy_gateways", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="roadWarriorForKerberos")
    def road_warrior_for_kerberos(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        """
        return pulumi.get(self, "road_warrior_for_kerberos")

    @road_warrior_for_kerberos.setter
    def road_warrior_for_kerberos(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "road_warrior_for_kerberos", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs']]:
        """
        (Block List) - ID pairs of source IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input['SSLInspectionRulesSourceIpGroupsArgs']]):
        pulumi.set(self, "source_ip_groups", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['SSLInspectionRulesTimeWindowsArgs']]:
        """
        (Block List) - The time intervals during which the rule applies
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['SSLInspectionRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Set of String) -  A list of user agent types the rule applies to.
        """
        return pulumi.get(self, "user_agent_types")

    @user_agent_types.setter
    def user_agent_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_agent_types", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['SSLInspectionRulesUsersArgs']]:
        """
        (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['SSLInspectionRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]]]:
        """
        (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "workload_groups")

    @workload_groups.setter
    def workload_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesWorkloadGroupArgs']]]]):
        pulumi.set(self, "workload_groups", value)

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]]]:
        """
        (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        return pulumi.get(self, "zpa_app_segments")

    @zpa_app_segments.setter
    def zpa_app_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SSLInspectionRulesZpaAppSegmentArgs']]]]):
        pulumi.set(self, "zpa_app_segments", value)


@pulumi.type_token("zia:index/sSLInspectionRules:SSLInspectionRules")
class SSLInspectionRules(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesActionArgs', 'SSLInspectionRulesActionArgsDict']]]]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input[Union['SSLInspectionRulesDepartmentsArgs', 'SSLInspectionRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_ip_groups: Optional[pulumi.Input[Union['SSLInspectionRulesDestIpGroupsArgs', 'SSLInspectionRulesDestIpGroupsArgsDict']]] = None,
                 device_groups: Optional[pulumi.Input[Union['SSLInspectionRulesDeviceGroupsArgs', 'SSLInspectionRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['SSLInspectionRulesDevicesArgs', 'SSLInspectionRulesDevicesArgsDict']]] = None,
                 groups: Optional[pulumi.Input[Union['SSLInspectionRulesGroupsArgs', 'SSLInspectionRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['SSLInspectionRulesLabelsArgs', 'SSLInspectionRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['SSLInspectionRulesLocationGroupsArgs', 'SSLInspectionRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['SSLInspectionRulesLocationsArgs', 'SSLInspectionRulesLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 platforms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 proxy_gateways: Optional[pulumi.Input[Union['SSLInspectionRulesProxyGatewaysArgs', 'SSLInspectionRulesProxyGatewaysArgsDict']]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 road_warrior_for_kerberos: Optional[pulumi.Input[builtins.bool]] = None,
                 source_ip_groups: Optional[pulumi.Input[Union['SSLInspectionRulesSourceIpGroupsArgs', 'SSLInspectionRulesSourceIpGroupsArgsDict']]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['SSLInspectionRulesTimeWindowsArgs', 'SSLInspectionRulesTimeWindowsArgsDict']]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['SSLInspectionRulesUsersArgs', 'SSLInspectionRulesUsersArgsDict']]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesWorkloadGroupArgs', 'SSLInspectionRulesWorkloadGroupArgsDict']]]]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesZpaAppSegmentArgs', 'SSLInspectionRulesZpaAppSegmentArgsDict']]]]] = None,
                 __props__=None):
        """
        ## Example Usage

        ### Action - DECRYPT

        ### Action - DO_NOT_DECRYPT - Bypass Rule (False)

        ### Action - DO_NOT_DECRYPT - Bypass Rule (True)

        ### Action - BLOCK

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesActionArgs', 'SSLInspectionRulesActionArgsDict']]]] actions: (Block List) - Action taken when the traffic matches policy
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        :param pulumi.Input[Union['SSLInspectionRulesDepartmentsArgs', 'SSLInspectionRulesDepartmentsArgsDict']] departments: (Block List) - ID pairs of departments for which the rule is applied.
        :param pulumi.Input[builtins.str] description: (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Union['SSLInspectionRulesDestIpGroupsArgs', 'SSLInspectionRulesDestIpGroupsArgsDict']] dest_ip_groups: (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        :param pulumi.Input[Union['SSLInspectionRulesDeviceGroupsArgs', 'SSLInspectionRulesDeviceGroupsArgsDict']] device_groups: (Block List) - ID pairs of device groups for which the rule is applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input[Union['SSLInspectionRulesDevicesArgs', 'SSLInspectionRulesDevicesArgsDict']] devices: (Block List) - ID pairs of devices for which the rule is applied
        :param pulumi.Input[Union['SSLInspectionRulesGroupsArgs', 'SSLInspectionRulesGroupsArgsDict']] groups: (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        :param pulumi.Input[Union['SSLInspectionRulesLabelsArgs', 'SSLInspectionRulesLabelsArgsDict']] labels: (Block List) - ID pairs of labels associated with the rule.
        :param pulumi.Input[Union['SSLInspectionRulesLocationGroupsArgs', 'SSLInspectionRulesLocationGroupsArgsDict']] location_groups: (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        :param pulumi.Input[Union['SSLInspectionRulesLocationsArgs', 'SSLInspectionRulesLocationsArgsDict']] locations: (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        :param pulumi.Input[builtins.str] name: The name of the SSL Inspection rule
        :param pulumi.Input[builtins.int] order: (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] platforms: (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        :param pulumi.Input[Union['SSLInspectionRulesProxyGatewaysArgs', 'SSLInspectionRulesProxyGatewaysArgsDict']] proxy_gateways: (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        :param pulumi.Input[builtins.int] rank: (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.bool] road_warrior_for_kerberos: (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        :param pulumi.Input[Union['SSLInspectionRulesSourceIpGroupsArgs', 'SSLInspectionRulesSourceIpGroupsArgsDict']] source_ip_groups: (Block List) - ID pairs of source IP address groups for which the rule is applied.
        :param pulumi.Input[builtins.str] state: (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input[Union['SSLInspectionRulesTimeWindowsArgs', 'SSLInspectionRulesTimeWindowsArgsDict']] time_windows: (Block List) - The time intervals during which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: (Set of String) -  A list of user agent types the rule applies to.
        :param pulumi.Input[Union['SSLInspectionRulesUsersArgs', 'SSLInspectionRulesUsersArgsDict']] users: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesWorkloadGroupArgs', 'SSLInspectionRulesWorkloadGroupArgsDict']]]] workload_groups: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesZpaAppSegmentArgs', 'SSLInspectionRulesZpaAppSegmentArgsDict']]]] zpa_app_segments: (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: SSLInspectionRulesArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ### Action - DECRYPT

        ### Action - DO_NOT_DECRYPT - Bypass Rule (False)

        ### Action - DO_NOT_DECRYPT - Bypass Rule (True)

        ### Action - BLOCK

        :param str resource_name: The name of the resource.
        :param SSLInspectionRulesArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(SSLInspectionRulesArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesActionArgs', 'SSLInspectionRulesActionArgsDict']]]]] = None,
                 cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 departments: Optional[pulumi.Input[Union['SSLInspectionRulesDepartmentsArgs', 'SSLInspectionRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 dest_ip_groups: Optional[pulumi.Input[Union['SSLInspectionRulesDestIpGroupsArgs', 'SSLInspectionRulesDestIpGroupsArgsDict']]] = None,
                 device_groups: Optional[pulumi.Input[Union['SSLInspectionRulesDeviceGroupsArgs', 'SSLInspectionRulesDeviceGroupsArgsDict']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 devices: Optional[pulumi.Input[Union['SSLInspectionRulesDevicesArgs', 'SSLInspectionRulesDevicesArgsDict']]] = None,
                 groups: Optional[pulumi.Input[Union['SSLInspectionRulesGroupsArgs', 'SSLInspectionRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['SSLInspectionRulesLabelsArgs', 'SSLInspectionRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['SSLInspectionRulesLocationGroupsArgs', 'SSLInspectionRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['SSLInspectionRulesLocationsArgs', 'SSLInspectionRulesLocationsArgsDict']]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 platforms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 proxy_gateways: Optional[pulumi.Input[Union['SSLInspectionRulesProxyGatewaysArgs', 'SSLInspectionRulesProxyGatewaysArgsDict']]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 road_warrior_for_kerberos: Optional[pulumi.Input[builtins.bool]] = None,
                 source_ip_groups: Optional[pulumi.Input[Union['SSLInspectionRulesSourceIpGroupsArgs', 'SSLInspectionRulesSourceIpGroupsArgsDict']]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 time_windows: Optional[pulumi.Input[Union['SSLInspectionRulesTimeWindowsArgs', 'SSLInspectionRulesTimeWindowsArgsDict']]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['SSLInspectionRulesUsersArgs', 'SSLInspectionRulesUsersArgsDict']]] = None,
                 workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesWorkloadGroupArgs', 'SSLInspectionRulesWorkloadGroupArgsDict']]]]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesZpaAppSegmentArgs', 'SSLInspectionRulesZpaAppSegmentArgsDict']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = SSLInspectionRulesArgs.__new__(SSLInspectionRulesArgs)

            __props__.__dict__["actions"] = actions
            __props__.__dict__["cloud_applications"] = cloud_applications
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            __props__.__dict__["dest_ip_groups"] = dest_ip_groups
            __props__.__dict__["device_groups"] = device_groups
            __props__.__dict__["device_trust_levels"] = device_trust_levels
            __props__.__dict__["devices"] = devices
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["name"] = name
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            __props__.__dict__["platforms"] = platforms
            __props__.__dict__["proxy_gateways"] = proxy_gateways
            __props__.__dict__["rank"] = rank
            __props__.__dict__["road_warrior_for_kerberos"] = road_warrior_for_kerberos
            __props__.__dict__["source_ip_groups"] = source_ip_groups
            __props__.__dict__["state"] = state
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["url_categories"] = url_categories
            __props__.__dict__["user_agent_types"] = user_agent_types
            __props__.__dict__["users"] = users
            __props__.__dict__["workload_groups"] = workload_groups
            __props__.__dict__["zpa_app_segments"] = zpa_app_segments
            __props__.__dict__["rule_id"] = None
        super(SSLInspectionRules, __self__).__init__(
            'zia:index/sSLInspectionRules:SSLInspectionRules',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            actions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesActionArgs', 'SSLInspectionRulesActionArgsDict']]]]] = None,
            cloud_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            departments: Optional[pulumi.Input[Union['SSLInspectionRulesDepartmentsArgs', 'SSLInspectionRulesDepartmentsArgsDict']]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            dest_ip_groups: Optional[pulumi.Input[Union['SSLInspectionRulesDestIpGroupsArgs', 'SSLInspectionRulesDestIpGroupsArgsDict']]] = None,
            device_groups: Optional[pulumi.Input[Union['SSLInspectionRulesDeviceGroupsArgs', 'SSLInspectionRulesDeviceGroupsArgsDict']]] = None,
            device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            devices: Optional[pulumi.Input[Union['SSLInspectionRulesDevicesArgs', 'SSLInspectionRulesDevicesArgsDict']]] = None,
            groups: Optional[pulumi.Input[Union['SSLInspectionRulesGroupsArgs', 'SSLInspectionRulesGroupsArgsDict']]] = None,
            labels: Optional[pulumi.Input[Union['SSLInspectionRulesLabelsArgs', 'SSLInspectionRulesLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['SSLInspectionRulesLocationGroupsArgs', 'SSLInspectionRulesLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['SSLInspectionRulesLocationsArgs', 'SSLInspectionRulesLocationsArgsDict']]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            order: Optional[pulumi.Input[builtins.int]] = None,
            platforms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            proxy_gateways: Optional[pulumi.Input[Union['SSLInspectionRulesProxyGatewaysArgs', 'SSLInspectionRulesProxyGatewaysArgsDict']]] = None,
            rank: Optional[pulumi.Input[builtins.int]] = None,
            road_warrior_for_kerberos: Optional[pulumi.Input[builtins.bool]] = None,
            rule_id: Optional[pulumi.Input[builtins.int]] = None,
            source_ip_groups: Optional[pulumi.Input[Union['SSLInspectionRulesSourceIpGroupsArgs', 'SSLInspectionRulesSourceIpGroupsArgsDict']]] = None,
            state: Optional[pulumi.Input[builtins.str]] = None,
            time_windows: Optional[pulumi.Input[Union['SSLInspectionRulesTimeWindowsArgs', 'SSLInspectionRulesTimeWindowsArgsDict']]] = None,
            url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            users: Optional[pulumi.Input[Union['SSLInspectionRulesUsersArgs', 'SSLInspectionRulesUsersArgsDict']]] = None,
            workload_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesWorkloadGroupArgs', 'SSLInspectionRulesWorkloadGroupArgsDict']]]]] = None,
            zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesZpaAppSegmentArgs', 'SSLInspectionRulesZpaAppSegmentArgsDict']]]]] = None) -> 'SSLInspectionRules':
        """
        Get an existing SSLInspectionRules resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesActionArgs', 'SSLInspectionRulesActionArgsDict']]]] actions: (Block List) - Action taken when the traffic matches policy
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cloud_applications: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        :param pulumi.Input[Union['SSLInspectionRulesDepartmentsArgs', 'SSLInspectionRulesDepartmentsArgsDict']] departments: (Block List) - ID pairs of departments for which the rule is applied.
        :param pulumi.Input[builtins.str] description: (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Union['SSLInspectionRulesDestIpGroupsArgs', 'SSLInspectionRulesDestIpGroupsArgsDict']] dest_ip_groups: (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        :param pulumi.Input[Union['SSLInspectionRulesDeviceGroupsArgs', 'SSLInspectionRulesDeviceGroupsArgsDict']] device_groups: (Block List) - ID pairs of device groups for which the rule is applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] device_trust_levels: (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input[Union['SSLInspectionRulesDevicesArgs', 'SSLInspectionRulesDevicesArgsDict']] devices: (Block List) - ID pairs of devices for which the rule is applied
        :param pulumi.Input[Union['SSLInspectionRulesGroupsArgs', 'SSLInspectionRulesGroupsArgsDict']] groups: (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        :param pulumi.Input[Union['SSLInspectionRulesLabelsArgs', 'SSLInspectionRulesLabelsArgsDict']] labels: (Block List) - ID pairs of labels associated with the rule.
        :param pulumi.Input[Union['SSLInspectionRulesLocationGroupsArgs', 'SSLInspectionRulesLocationGroupsArgsDict']] location_groups: (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        :param pulumi.Input[Union['SSLInspectionRulesLocationsArgs', 'SSLInspectionRulesLocationsArgsDict']] locations: (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        :param pulumi.Input[builtins.str] name: The name of the SSL Inspection rule
        :param pulumi.Input[builtins.int] order: (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] platforms: (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        :param pulumi.Input[Union['SSLInspectionRulesProxyGatewaysArgs', 'SSLInspectionRulesProxyGatewaysArgsDict']] proxy_gateways: (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        :param pulumi.Input[builtins.int] rank: (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.bool] road_warrior_for_kerberos: (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        :param pulumi.Input[Union['SSLInspectionRulesSourceIpGroupsArgs', 'SSLInspectionRulesSourceIpGroupsArgsDict']] source_ip_groups: (Block List) - ID pairs of source IP address groups for which the rule is applied.
        :param pulumi.Input[builtins.str] state: (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input[Union['SSLInspectionRulesTimeWindowsArgs', 'SSLInspectionRulesTimeWindowsArgsDict']] time_windows: (Block List) - The time intervals during which the rule applies
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_agent_types: (Set of String) -  A list of user agent types the rule applies to.
        :param pulumi.Input[Union['SSLInspectionRulesUsersArgs', 'SSLInspectionRulesUsersArgsDict']] users: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesWorkloadGroupArgs', 'SSLInspectionRulesWorkloadGroupArgsDict']]]] workload_groups: (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SSLInspectionRulesZpaAppSegmentArgs', 'SSLInspectionRulesZpaAppSegmentArgsDict']]]] zpa_app_segments: (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _SSLInspectionRulesState.__new__(_SSLInspectionRulesState)

        __props__.__dict__["actions"] = actions
        __props__.__dict__["cloud_applications"] = cloud_applications
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["dest_ip_groups"] = dest_ip_groups
        __props__.__dict__["device_groups"] = device_groups
        __props__.__dict__["device_trust_levels"] = device_trust_levels
        __props__.__dict__["devices"] = devices
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["name"] = name
        __props__.__dict__["order"] = order
        __props__.__dict__["platforms"] = platforms
        __props__.__dict__["proxy_gateways"] = proxy_gateways
        __props__.__dict__["rank"] = rank
        __props__.__dict__["road_warrior_for_kerberos"] = road_warrior_for_kerberos
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["source_ip_groups"] = source_ip_groups
        __props__.__dict__["state"] = state
        __props__.__dict__["time_windows"] = time_windows
        __props__.__dict__["url_categories"] = url_categories
        __props__.__dict__["user_agent_types"] = user_agent_types
        __props__.__dict__["users"] = users
        __props__.__dict__["workload_groups"] = workload_groups
        __props__.__dict__["zpa_app_segments"] = zpa_app_segments
        return SSLInspectionRules(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Output[Optional[Sequence['outputs.SSLInspectionRulesAction']]]:
        """
        (Block List) - Action taken when the traffic matches policy
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="cloudApplications")
    def cloud_applications(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) -  The list of URL categories to which the DLP policy rule must be applied. For the complete list of supported file types refer to the  [ZIA API documentation](https://help.zscaler.com/zia/data-loss-prevention#/webDlpRules-post)
        """
        return pulumi.get(self, "cloud_applications")

    @property
    @pulumi.getter
    def departments(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesDepartments']]:
        """
        (Block List) - ID pairs of departments for which the rule is applied.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) -  Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesDestIpGroups']]:
        """
        (Block List) - ID pairs of destination IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "dest_ip_groups")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesDeviceGroups']]:
        """
        (Block List) - ID pairs of device groups for which the rule is applied.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String)  - List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        """
        return pulumi.get(self, "device_trust_levels")

    @property
    @pulumi.getter
    def devices(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesDevices']]:
        """
        (Block List) - ID pairs of devices for which the rule is applied
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesGroups']]:
        """
        (Block List) - ID pairs of groups for which the rule is applied. If not set, rule is applied for all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesLabels']]:
        """
        (Block List) - ID pairs of labels associated with the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesLocationGroups']]:
        """
        (Block List) - ID pairs of location groups to which the rule is applied. When empty, it implies applying to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesLocations']]:
        """
        (Block List) - ID pairs of locations to which the rule is applied. When empty, it implies applying to all locations.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        The name of the SSL Inspection rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> pulumi.Output[builtins.int]:
        """
        (String) -  Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def platforms(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) -  Zscaler Client Connector device platforms for which this rule is applied. Supported Values: `SCAN_IOS`, `SCAN_ANDROID`, `SCAN_MACOS`, `SCAN_WINDOWS`, `NO_CLIENT_CONNECTOR`, `SCAN_LINUX`
        """
        return pulumi.get(self, "platforms")

    @property
    @pulumi.getter(name="proxyGateways")
    def proxy_gateways(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesProxyGateways']]:
        """
        (Block List) - When using ZPA Gateway forwarding, name-ID pairs of ZPA Application Segments for which the rule is applicable.
        """
        return pulumi.get(self, "proxy_gateways")

    @property
    @pulumi.getter
    def rank(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        (Integer) - The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="roadWarriorForKerberos")
    def road_warrior_for_kerberos(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        (Boolean) - Indicates whether this rule is applied to remote users that use PAC with Kerberos authentication.
        """
        return pulumi.get(self, "road_warrior_for_kerberos")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[builtins.int]:
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesSourceIpGroups']]:
        """
        (Block List) - ID pairs of source IP address groups for which the rule is applied.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) - The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesTimeWindows']]:
        """
        (Block List) - The time intervals during which the rule applies
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) -  The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (Set of String) -  A list of user agent types the rule applies to.
        """
        return pulumi.get(self, "user_agent_types")

    @property
    @pulumi.getter
    def users(self) -> pulumi.Output[Optional['outputs.SSLInspectionRulesUsers']]:
        """
        (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="workloadGroups")
    def workload_groups(self) -> pulumi.Output[Sequence['outputs.SSLInspectionRulesWorkloadGroup']]:
        """
        (Block List) - The list of preconfigured workload groups to which the policy must be applied.
        """
        return pulumi.get(self, "workload_groups")

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> pulumi.Output[Sequence['outputs.SSLInspectionRulesZpaAppSegment']]:
        """
        (Block List) - The list of ZPA Application Segments for which this rule is applicable (applicable only for ZPA Gateway forwarding).
        """
        return pulumi.get(self, "zpa_app_segments")


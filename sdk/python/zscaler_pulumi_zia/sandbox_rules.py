# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['SandboxRulesArgs', 'SandboxRules']

@pulumi.input_type
class SandboxRulesArgs:
    def __init__(__self__, *,
                 file_types: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 order: pulumi.Input[builtins.int],
                 protocols: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 ba_policy_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ba_rule_action: Optional[pulumi.Input[builtins.str]] = None,
                 by_threat_score: Optional[pulumi.Input[builtins.int]] = None,
                 departments: Optional[pulumi.Input['SandboxRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 first_time_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 first_time_operation: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input['SandboxRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['SandboxRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['SandboxRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['SandboxRulesLocationsArgs']] = None,
                 ml_action_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['SandboxRulesUsersArgs']] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]]] = None):
        """
        The set of arguments for constructing a SandboxRules resource.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ba_policy_categories: The threat categories to which the rule applies
        :param pulumi.Input[builtins.str] ba_rule_action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        :param pulumi.Input[builtins.int] by_threat_score: (Integer)
        :param pulumi.Input['SandboxRulesDepartmentsArgs'] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[builtins.bool] first_time_enable: (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        :param pulumi.Input[builtins.str] first_time_operation: (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        :param pulumi.Input['SandboxRulesGroupsArgs'] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input['SandboxRulesLabelsArgs'] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input['SandboxRulesLocationGroupsArgs'] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input['SandboxRulesLocationsArgs'] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.bool] ml_action_enabled: (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.int] rank: (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.str] state: (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input['SandboxRulesUsersArgs'] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]] zpa_app_segments: (List of Objects) The ZPA application segments to which the rule applies
        """
        pulumi.set(__self__, "file_types", file_types)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "protocols", protocols)
        if ba_policy_categories is not None:
            pulumi.set(__self__, "ba_policy_categories", ba_policy_categories)
        if ba_rule_action is not None:
            pulumi.set(__self__, "ba_rule_action", ba_rule_action)
        if by_threat_score is not None:
            pulumi.set(__self__, "by_threat_score", by_threat_score)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if first_time_enable is not None:
            pulumi.set(__self__, "first_time_enable", first_time_enable)
        if first_time_operation is not None:
            pulumi.set(__self__, "first_time_operation", first_time_operation)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if ml_action_enabled is not None:
            pulumi.set(__self__, "ml_action_enabled", ml_action_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if zpa_app_segments is not None:
            pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "file_types", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[builtins.int]:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Protocol for the given rule. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="baPolicyCategories")
    def ba_policy_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The threat categories to which the rule applies
        """
        return pulumi.get(self, "ba_policy_categories")

    @ba_policy_categories.setter
    def ba_policy_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ba_policy_categories", value)

    @property
    @pulumi.getter(name="baRuleAction")
    def ba_rule_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        """
        return pulumi.get(self, "ba_rule_action")

    @ba_rule_action.setter
    def ba_rule_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ba_rule_action", value)

    @property
    @pulumi.getter(name="byThreatScore")
    def by_threat_score(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer)
        """
        return pulumi.get(self, "by_threat_score")

    @by_threat_score.setter
    def by_threat_score(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "by_threat_score", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['SandboxRulesDepartmentsArgs']]:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['SandboxRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="firstTimeEnable")
    def first_time_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        """
        return pulumi.get(self, "first_time_enable")

    @first_time_enable.setter
    def first_time_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "first_time_enable", value)

    @property
    @pulumi.getter(name="firstTimeOperation")
    def first_time_operation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        """
        return pulumi.get(self, "first_time_operation")

    @first_time_operation.setter
    def first_time_operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "first_time_operation", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['SandboxRulesGroupsArgs']]:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['SandboxRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['SandboxRulesLabelsArgs']]:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['SandboxRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['SandboxRulesLocationGroupsArgs']]:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['SandboxRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['SandboxRulesLocationsArgs']]:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['SandboxRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="mlActionEnabled")
    def ml_action_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        """
        return pulumi.get(self, "ml_action_enabled")

    @ml_action_enabled.setter
    def ml_action_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ml_action_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The File Type Control policy rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['SandboxRulesUsersArgs']]:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['SandboxRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]]]:
        """
        (List of Objects) The ZPA application segments to which the rule applies
        """
        return pulumi.get(self, "zpa_app_segments")

    @zpa_app_segments.setter
    def zpa_app_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]]]):
        pulumi.set(self, "zpa_app_segments", value)


@pulumi.input_type
class _SandboxRulesState:
    def __init__(__self__, *,
                 ba_policy_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ba_rule_action: Optional[pulumi.Input[builtins.str]] = None,
                 by_threat_score: Optional[pulumi.Input[builtins.int]] = None,
                 departments: Optional[pulumi.Input['SandboxRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 first_time_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 first_time_operation: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input['SandboxRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['SandboxRulesLabelsArgs']] = None,
                 location_groups: Optional[pulumi.Input['SandboxRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['SandboxRulesLocationsArgs']] = None,
                 ml_action_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 rule_id: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input['SandboxRulesUsersArgs']] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]]] = None):
        """
        Input properties used for looking up and filtering SandboxRules resources.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ba_policy_categories: The threat categories to which the rule applies
        :param pulumi.Input[builtins.str] ba_rule_action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        :param pulumi.Input[builtins.int] by_threat_score: (Integer)
        :param pulumi.Input['SandboxRulesDepartmentsArgs'] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.bool] first_time_enable: (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        :param pulumi.Input[builtins.str] first_time_operation: (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        :param pulumi.Input['SandboxRulesGroupsArgs'] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input['SandboxRulesLabelsArgs'] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input['SandboxRulesLocationGroupsArgs'] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input['SandboxRulesLocationsArgs'] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.bool] ml_action_enabled: (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.str] state: (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input['SandboxRulesUsersArgs'] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]] zpa_app_segments: (List of Objects) The ZPA application segments to which the rule applies
        """
        if ba_policy_categories is not None:
            pulumi.set(__self__, "ba_policy_categories", ba_policy_categories)
        if ba_rule_action is not None:
            pulumi.set(__self__, "ba_rule_action", ba_rule_action)
        if by_threat_score is not None:
            pulumi.set(__self__, "by_threat_score", by_threat_score)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if first_time_enable is not None:
            pulumi.set(__self__, "first_time_enable", first_time_enable)
        if first_time_operation is not None:
            pulumi.set(__self__, "first_time_operation", first_time_operation)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if ml_action_enabled is not None:
            pulumi.set(__self__, "ml_action_enabled", ml_action_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if zpa_app_segments is not None:
            pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter(name="baPolicyCategories")
    def ba_policy_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The threat categories to which the rule applies
        """
        return pulumi.get(self, "ba_policy_categories")

    @ba_policy_categories.setter
    def ba_policy_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ba_policy_categories", value)

    @property
    @pulumi.getter(name="baRuleAction")
    def ba_rule_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        """
        return pulumi.get(self, "ba_rule_action")

    @ba_rule_action.setter
    def ba_rule_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ba_rule_action", value)

    @property
    @pulumi.getter(name="byThreatScore")
    def by_threat_score(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer)
        """
        return pulumi.get(self, "by_threat_score")

    @by_threat_score.setter
    def by_threat_score(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "by_threat_score", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['SandboxRulesDepartmentsArgs']]:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['SandboxRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "file_types", value)

    @property
    @pulumi.getter(name="firstTimeEnable")
    def first_time_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        """
        return pulumi.get(self, "first_time_enable")

    @first_time_enable.setter
    def first_time_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "first_time_enable", value)

    @property
    @pulumi.getter(name="firstTimeOperation")
    def first_time_operation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        """
        return pulumi.get(self, "first_time_operation")

    @first_time_operation.setter
    def first_time_operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "first_time_operation", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['SandboxRulesGroupsArgs']]:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['SandboxRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['SandboxRulesLabelsArgs']]:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['SandboxRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['SandboxRulesLocationGroupsArgs']]:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['SandboxRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['SandboxRulesLocationsArgs']]:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['SandboxRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="mlActionEnabled")
    def ml_action_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        """
        return pulumi.get(self, "ml_action_enabled")

    @ml_action_enabled.setter
    def ml_action_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ml_action_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The File Type Control policy rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Protocol for the given rule. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['SandboxRulesUsersArgs']]:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['SandboxRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]]]:
        """
        (List of Objects) The ZPA application segments to which the rule applies
        """
        return pulumi.get(self, "zpa_app_segments")

    @zpa_app_segments.setter
    def zpa_app_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SandboxRulesZpaAppSegmentArgs']]]]):
        pulumi.set(self, "zpa_app_segments", value)


@pulumi.type_token("zia:index/sandboxRules:SandboxRules")
class SandboxRules(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ba_policy_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ba_rule_action: Optional[pulumi.Input[builtins.str]] = None,
                 by_threat_score: Optional[pulumi.Input[builtins.int]] = None,
                 departments: Optional[pulumi.Input[Union['SandboxRulesDepartmentsArgs', 'SandboxRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 first_time_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 first_time_operation: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input[Union['SandboxRulesGroupsArgs', 'SandboxRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['SandboxRulesLabelsArgs', 'SandboxRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['SandboxRulesLocationGroupsArgs', 'SandboxRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['SandboxRulesLocationsArgs', 'SandboxRulesLocationsArgsDict']]] = None,
                 ml_action_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['SandboxRulesUsersArgs', 'SandboxRulesUsersArgsDict']]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SandboxRulesZpaAppSegmentArgs', 'SandboxRulesZpaAppSegmentArgsDict']]]]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-sandbox)
        * [API documentation](https://help.zscaler.com/zia/sandbox-policy-settings#/sandboxRules-get)

        The **zia_sandbox_rules** resource allows the creation and management of SAndbox rules in the Zscaler Internet Access.

        ## Example Usage

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        **zia_sandbox_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/sandboxRules:SandboxRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/sandboxRules:SandboxRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ba_policy_categories: The threat categories to which the rule applies
        :param pulumi.Input[builtins.str] ba_rule_action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        :param pulumi.Input[builtins.int] by_threat_score: (Integer)
        :param pulumi.Input[Union['SandboxRulesDepartmentsArgs', 'SandboxRulesDepartmentsArgsDict']] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.bool] first_time_enable: (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        :param pulumi.Input[builtins.str] first_time_operation: (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        :param pulumi.Input[Union['SandboxRulesGroupsArgs', 'SandboxRulesGroupsArgsDict']] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[Union['SandboxRulesLabelsArgs', 'SandboxRulesLabelsArgsDict']] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input[Union['SandboxRulesLocationGroupsArgs', 'SandboxRulesLocationGroupsArgsDict']] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input[Union['SandboxRulesLocationsArgs', 'SandboxRulesLocationsArgsDict']] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.bool] ml_action_enabled: (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.str] state: (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input[Union['SandboxRulesUsersArgs', 'SandboxRulesUsersArgsDict']] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SandboxRulesZpaAppSegmentArgs', 'SandboxRulesZpaAppSegmentArgsDict']]]] zpa_app_segments: (List of Objects) The ZPA application segments to which the rule applies
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: SandboxRulesArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zia/about-sandbox)
        * [API documentation](https://help.zscaler.com/zia/sandbox-policy-settings#/sandboxRules-get)

        The **zia_sandbox_rules** resource allows the creation and management of SAndbox rules in the Zscaler Internet Access.

        ## Example Usage

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZIA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        **zia_sandbox_rules** can be imported by using `<RULE ID>` or `<RULE NAME>` as the import ID.

        For example:

        ```sh
        $ pulumi import zia:index/sandboxRules:SandboxRules example <rule_id>
        ```

        or

        ```sh
        $ pulumi import zia:index/sandboxRules:SandboxRules example <rule_name>
        ```

        :param str resource_name: The name of the resource.
        :param SandboxRulesArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(SandboxRulesArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ba_policy_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ba_rule_action: Optional[pulumi.Input[builtins.str]] = None,
                 by_threat_score: Optional[pulumi.Input[builtins.int]] = None,
                 departments: Optional[pulumi.Input[Union['SandboxRulesDepartmentsArgs', 'SandboxRulesDepartmentsArgsDict']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 first_time_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 first_time_operation: Optional[pulumi.Input[builtins.str]] = None,
                 groups: Optional[pulumi.Input[Union['SandboxRulesGroupsArgs', 'SandboxRulesGroupsArgsDict']]] = None,
                 labels: Optional[pulumi.Input[Union['SandboxRulesLabelsArgs', 'SandboxRulesLabelsArgsDict']]] = None,
                 location_groups: Optional[pulumi.Input[Union['SandboxRulesLocationGroupsArgs', 'SandboxRulesLocationGroupsArgsDict']]] = None,
                 locations: Optional[pulumi.Input[Union['SandboxRulesLocationsArgs', 'SandboxRulesLocationsArgsDict']]] = None,
                 ml_action_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order: Optional[pulumi.Input[builtins.int]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rank: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Union['SandboxRulesUsersArgs', 'SandboxRulesUsersArgsDict']]] = None,
                 zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SandboxRulesZpaAppSegmentArgs', 'SandboxRulesZpaAppSegmentArgsDict']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = SandboxRulesArgs.__new__(SandboxRulesArgs)

            __props__.__dict__["ba_policy_categories"] = ba_policy_categories
            __props__.__dict__["ba_rule_action"] = ba_rule_action
            __props__.__dict__["by_threat_score"] = by_threat_score
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            if file_types is None and not opts.urn:
                raise TypeError("Missing required property 'file_types'")
            __props__.__dict__["file_types"] = file_types
            __props__.__dict__["first_time_enable"] = first_time_enable
            __props__.__dict__["first_time_operation"] = first_time_operation
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["ml_action_enabled"] = ml_action_enabled
            __props__.__dict__["name"] = name
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            if protocols is None and not opts.urn:
                raise TypeError("Missing required property 'protocols'")
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["rank"] = rank
            __props__.__dict__["state"] = state
            __props__.__dict__["url_categories"] = url_categories
            __props__.__dict__["users"] = users
            __props__.__dict__["zpa_app_segments"] = zpa_app_segments
            __props__.__dict__["rule_id"] = None
        super(SandboxRules, __self__).__init__(
            'zia:index/sandboxRules:SandboxRules',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ba_policy_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            ba_rule_action: Optional[pulumi.Input[builtins.str]] = None,
            by_threat_score: Optional[pulumi.Input[builtins.int]] = None,
            departments: Optional[pulumi.Input[Union['SandboxRulesDepartmentsArgs', 'SandboxRulesDepartmentsArgsDict']]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            file_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            first_time_enable: Optional[pulumi.Input[builtins.bool]] = None,
            first_time_operation: Optional[pulumi.Input[builtins.str]] = None,
            groups: Optional[pulumi.Input[Union['SandboxRulesGroupsArgs', 'SandboxRulesGroupsArgsDict']]] = None,
            labels: Optional[pulumi.Input[Union['SandboxRulesLabelsArgs', 'SandboxRulesLabelsArgsDict']]] = None,
            location_groups: Optional[pulumi.Input[Union['SandboxRulesLocationGroupsArgs', 'SandboxRulesLocationGroupsArgsDict']]] = None,
            locations: Optional[pulumi.Input[Union['SandboxRulesLocationsArgs', 'SandboxRulesLocationsArgsDict']]] = None,
            ml_action_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            order: Optional[pulumi.Input[builtins.int]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            rank: Optional[pulumi.Input[builtins.int]] = None,
            rule_id: Optional[pulumi.Input[builtins.int]] = None,
            state: Optional[pulumi.Input[builtins.str]] = None,
            url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            users: Optional[pulumi.Input[Union['SandboxRulesUsersArgs', 'SandboxRulesUsersArgsDict']]] = None,
            zpa_app_segments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['SandboxRulesZpaAppSegmentArgs', 'SandboxRulesZpaAppSegmentArgsDict']]]]] = None) -> 'SandboxRules':
        """
        Get an existing SandboxRules resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ba_policy_categories: The threat categories to which the rule applies
        :param pulumi.Input[builtins.str] ba_rule_action: (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        :param pulumi.Input[builtins.int] by_threat_score: (Integer)
        :param pulumi.Input[Union['SandboxRulesDepartmentsArgs', 'SandboxRulesDepartmentsArgsDict']] departments: (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        :param pulumi.Input[builtins.str] description: (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] file_types: (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        :param pulumi.Input[builtins.bool] first_time_enable: (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        :param pulumi.Input[builtins.str] first_time_operation: (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        :param pulumi.Input[Union['SandboxRulesGroupsArgs', 'SandboxRulesGroupsArgsDict']] groups: (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[Union['SandboxRulesLabelsArgs', 'SandboxRulesLabelsArgsDict']] labels: (List of Objects) Labels that are applicable to the rule.
        :param pulumi.Input[Union['SandboxRulesLocationGroupsArgs', 'SandboxRulesLocationGroupsArgsDict']] location_groups: (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        :param pulumi.Input[Union['SandboxRulesLocationsArgs', 'SandboxRulesLocationsArgsDict']] locations: (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        :param pulumi.Input[builtins.bool] ml_action_enabled: (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        :param pulumi.Input[builtins.str] name: The File Type Control policy rule name.
        :param pulumi.Input[builtins.int] order: (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: Protocol for the given rule. This field is not applicable to the Lite API.
        :param pulumi.Input[builtins.int] rank: (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        :param pulumi.Input[builtins.str] state: (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] url_categories: (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        :param pulumi.Input[Union['SandboxRulesUsersArgs', 'SandboxRulesUsersArgsDict']] users: (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        :param pulumi.Input[Sequence[pulumi.Input[Union['SandboxRulesZpaAppSegmentArgs', 'SandboxRulesZpaAppSegmentArgsDict']]]] zpa_app_segments: (List of Objects) The ZPA application segments to which the rule applies
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _SandboxRulesState.__new__(_SandboxRulesState)

        __props__.__dict__["ba_policy_categories"] = ba_policy_categories
        __props__.__dict__["ba_rule_action"] = ba_rule_action
        __props__.__dict__["by_threat_score"] = by_threat_score
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["file_types"] = file_types
        __props__.__dict__["first_time_enable"] = first_time_enable
        __props__.__dict__["first_time_operation"] = first_time_operation
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["ml_action_enabled"] = ml_action_enabled
        __props__.__dict__["name"] = name
        __props__.__dict__["order"] = order
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["rank"] = rank
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["state"] = state
        __props__.__dict__["url_categories"] = url_categories
        __props__.__dict__["users"] = users
        __props__.__dict__["zpa_app_segments"] = zpa_app_segments
        return SandboxRules(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="baPolicyCategories")
    def ba_policy_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        The threat categories to which the rule applies
        """
        return pulumi.get(self, "ba_policy_categories")

    @property
    @pulumi.getter(name="baRuleAction")
    def ba_rule_action(self) -> pulumi.Output[builtins.str]:
        """
        (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
        """
        return pulumi.get(self, "ba_rule_action")

    @property
    @pulumi.getter(name="byThreatScore")
    def by_threat_score(self) -> pulumi.Output[builtins.int]:
        """
        (Integer)
        """
        return pulumi.get(self, "by_threat_score")

    @property
    @pulumi.getter
    def departments(self) -> pulumi.Output[Optional['outputs.SandboxRulesDepartments']]:
        """
        (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.
        """
        return pulumi.get(self, "file_types")

    @property
    @pulumi.getter(name="firstTimeEnable")
    def first_time_enable(self) -> pulumi.Output[builtins.bool]:
        """
        (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
        """
        return pulumi.get(self, "first_time_enable")

    @property
    @pulumi.getter(name="firstTimeOperation")
    def first_time_operation(self) -> pulumi.Output[builtins.str]:
        """
        (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
        """
        return pulumi.get(self, "first_time_operation")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional['outputs.SandboxRulesGroups']]:
        """
        (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional['outputs.SandboxRulesLabels']]:
        """
        (List of Objects) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output[Optional['outputs.SandboxRulesLocationGroups']]:
        """
        (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional['outputs.SandboxRulesLocations']]:
        """
        (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="mlActionEnabled")
    def ml_action_enabled(self) -> pulumi.Output[builtins.bool]:
        """
        (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
        """
        return pulumi.get(self, "ml_action_enabled")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        The File Type Control policy rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> pulumi.Output[builtins.int]:
        """
        (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Protocol for the given rule. This field is not applicable to the Lite API.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> pulumi.Output[builtins.int]:
        """
        (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[builtins.int]:
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[builtins.str]:
        """
        (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
        """
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter
    def users(self) -> pulumi.Output[Optional['outputs.SandboxRulesUsers']]:
        """
        (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> pulumi.Output[Sequence['outputs.SandboxRulesZpaAppSegment']]:
        """
        (List of Objects) The ZPA application segments to which the rule applies
        """
        return pulumi.get(self, "zpa_app_segments")


# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'GetForwardingControlRuleResult',
    'AwaitableGetForwardingControlRuleResult',
    'get_forwarding_control_rule',
    'get_forwarding_control_rule_output',
]

@pulumi.output_type
class GetForwardingControlRuleResult:
    """
    A collection of values returned by getForwardingControlRule.
    """
    def __init__(__self__, departments=None, description=None, dest_addresses=None, dest_countries=None, dest_ip_categories=None, dest_ip_groups=None, dest_ipv6_groups=None, device_groups=None, devices=None, ec_groups=None, forward_method=None, groups=None, id=None, labels=None, location_groups=None, locations=None, name=None, nw_application_groups=None, nw_applications=None, nw_service_groups=None, nw_services=None, order=None, proxy_gateways=None, rank=None, res_categories=None, src_ip_groups=None, src_ips=None, src_ipv6_groups=None, state=None, type=None, users=None, zpa_app_segments=None, zpa_application_segment_groups=None, zpa_application_segments=None, zpa_broker_rule=None, zpa_gateways=None):
        if departments and not isinstance(departments, list):
            raise TypeError("Expected argument 'departments' to be a list")
        pulumi.set(__self__, "departments", departments)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if dest_addresses and not isinstance(dest_addresses, list):
            raise TypeError("Expected argument 'dest_addresses' to be a list")
        pulumi.set(__self__, "dest_addresses", dest_addresses)
        if dest_countries and not isinstance(dest_countries, list):
            raise TypeError("Expected argument 'dest_countries' to be a list")
        pulumi.set(__self__, "dest_countries", dest_countries)
        if dest_ip_categories and not isinstance(dest_ip_categories, list):
            raise TypeError("Expected argument 'dest_ip_categories' to be a list")
        pulumi.set(__self__, "dest_ip_categories", dest_ip_categories)
        if dest_ip_groups and not isinstance(dest_ip_groups, list):
            raise TypeError("Expected argument 'dest_ip_groups' to be a list")
        pulumi.set(__self__, "dest_ip_groups", dest_ip_groups)
        if dest_ipv6_groups and not isinstance(dest_ipv6_groups, list):
            raise TypeError("Expected argument 'dest_ipv6_groups' to be a list")
        pulumi.set(__self__, "dest_ipv6_groups", dest_ipv6_groups)
        if device_groups and not isinstance(device_groups, list):
            raise TypeError("Expected argument 'device_groups' to be a list")
        pulumi.set(__self__, "device_groups", device_groups)
        if devices and not isinstance(devices, list):
            raise TypeError("Expected argument 'devices' to be a list")
        pulumi.set(__self__, "devices", devices)
        if ec_groups and not isinstance(ec_groups, list):
            raise TypeError("Expected argument 'ec_groups' to be a list")
        pulumi.set(__self__, "ec_groups", ec_groups)
        if forward_method and not isinstance(forward_method, str):
            raise TypeError("Expected argument 'forward_method' to be a str")
        pulumi.set(__self__, "forward_method", forward_method)
        if groups and not isinstance(groups, list):
            raise TypeError("Expected argument 'groups' to be a list")
        pulumi.set(__self__, "groups", groups)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if labels and not isinstance(labels, list):
            raise TypeError("Expected argument 'labels' to be a list")
        pulumi.set(__self__, "labels", labels)
        if location_groups and not isinstance(location_groups, list):
            raise TypeError("Expected argument 'location_groups' to be a list")
        pulumi.set(__self__, "location_groups", location_groups)
        if locations and not isinstance(locations, list):
            raise TypeError("Expected argument 'locations' to be a list")
        pulumi.set(__self__, "locations", locations)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if nw_application_groups and not isinstance(nw_application_groups, list):
            raise TypeError("Expected argument 'nw_application_groups' to be a list")
        pulumi.set(__self__, "nw_application_groups", nw_application_groups)
        if nw_applications and not isinstance(nw_applications, list):
            raise TypeError("Expected argument 'nw_applications' to be a list")
        pulumi.set(__self__, "nw_applications", nw_applications)
        if nw_service_groups and not isinstance(nw_service_groups, list):
            raise TypeError("Expected argument 'nw_service_groups' to be a list")
        pulumi.set(__self__, "nw_service_groups", nw_service_groups)
        if nw_services and not isinstance(nw_services, list):
            raise TypeError("Expected argument 'nw_services' to be a list")
        pulumi.set(__self__, "nw_services", nw_services)
        if order and not isinstance(order, int):
            raise TypeError("Expected argument 'order' to be a int")
        pulumi.set(__self__, "order", order)
        if proxy_gateways and not isinstance(proxy_gateways, list):
            raise TypeError("Expected argument 'proxy_gateways' to be a list")
        pulumi.set(__self__, "proxy_gateways", proxy_gateways)
        if rank and not isinstance(rank, int):
            raise TypeError("Expected argument 'rank' to be a int")
        pulumi.set(__self__, "rank", rank)
        if res_categories and not isinstance(res_categories, list):
            raise TypeError("Expected argument 'res_categories' to be a list")
        pulumi.set(__self__, "res_categories", res_categories)
        if src_ip_groups and not isinstance(src_ip_groups, list):
            raise TypeError("Expected argument 'src_ip_groups' to be a list")
        pulumi.set(__self__, "src_ip_groups", src_ip_groups)
        if src_ips and not isinstance(src_ips, list):
            raise TypeError("Expected argument 'src_ips' to be a list")
        pulumi.set(__self__, "src_ips", src_ips)
        if src_ipv6_groups and not isinstance(src_ipv6_groups, list):
            raise TypeError("Expected argument 'src_ipv6_groups' to be a list")
        pulumi.set(__self__, "src_ipv6_groups", src_ipv6_groups)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)
        if users and not isinstance(users, list):
            raise TypeError("Expected argument 'users' to be a list")
        pulumi.set(__self__, "users", users)
        if zpa_app_segments and not isinstance(zpa_app_segments, list):
            raise TypeError("Expected argument 'zpa_app_segments' to be a list")
        pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)
        if zpa_application_segment_groups and not isinstance(zpa_application_segment_groups, list):
            raise TypeError("Expected argument 'zpa_application_segment_groups' to be a list")
        pulumi.set(__self__, "zpa_application_segment_groups", zpa_application_segment_groups)
        if zpa_application_segments and not isinstance(zpa_application_segments, list):
            raise TypeError("Expected argument 'zpa_application_segments' to be a list")
        pulumi.set(__self__, "zpa_application_segments", zpa_application_segments)
        if zpa_broker_rule and not isinstance(zpa_broker_rule, bool):
            raise TypeError("Expected argument 'zpa_broker_rule' to be a bool")
        pulumi.set(__self__, "zpa_broker_rule", zpa_broker_rule)
        if zpa_gateways and not isinstance(zpa_gateways, list):
            raise TypeError("Expected argument 'zpa_gateways' to be a list")
        pulumi.set(__self__, "zpa_gateways", zpa_gateways)

    @property
    @pulumi.getter
    def departments(self) -> Sequence['outputs.GetForwardingControlRuleDepartmentResult']:
        """
        (list) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        (string) - Additional information about the forwarding rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destAddresses")
    def dest_addresses(self) -> Sequence[str]:
        """
        ** - (list) -  IP addresses and fully qualified domain names (FQDNs), if the domain has multiple destination IP addresses or if its IP addresses may change. For IP addresses, you can enter individual IP addresses, subnets, or address ranges. If adding multiple items, hit Enter after each entry.
        """
        return pulumi.get(self, "dest_addresses")

    @property
    @pulumi.getter(name="destCountries")
    def dest_countries(self) -> Sequence[str]:
        """
        ** - (list) estination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries. Provide a 2 letter [ISO3166 Alpha2 Country code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes).
        """
        return pulumi.get(self, "dest_countries")

    @property
    @pulumi.getter(name="destIpCategories")
    def dest_ip_categories(self) -> Sequence[str]:
        """
        ** - (list) identify destinations based on the URL category of the domain, select Any to apply the rule to all categories or select the specific categories you want to control.
        """
        return pulumi.get(self, "dest_ip_categories")

    @property
    @pulumi.getter(name="destIpGroups")
    def dest_ip_groups(self) -> Sequence['outputs.GetForwardingControlRuleDestIpGroupResult']:
        """
        ** - (list) Any number of destination IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "dest_ip_groups")

    @property
    @pulumi.getter(name="destIpv6Groups")
    def dest_ipv6_groups(self) -> Sequence['outputs.GetForwardingControlRuleDestIpv6GroupResult']:
        return pulumi.get(self, "dest_ipv6_groups")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Sequence['outputs.GetForwardingControlRuleDeviceGroupResult']:
        """
        (list) Name-ID pairs of device groups for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter
    def devices(self) -> Sequence['outputs.GetForwardingControlRuleDeviceResult']:
        """
        (list) Name-ID pairs of devices for which the rule must be applied. Specifies devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="ecGroups")
    def ec_groups(self) -> Sequence['outputs.GetForwardingControlRuleEcGroupResult']:
        """
        (list) - Name-ID pairs of the Zscaler Cloud Connector groups to which the forwarding rule applies
        """
        return pulumi.get(self, "ec_groups")

    @property
    @pulumi.getter(name="forwardMethod")
    def forward_method(self) -> str:
        """
        (string) - The type of traffic forwarding method selected from the available options.
        """
        return pulumi.get(self, "forward_method")

    @property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetForwardingControlRuleGroupResult']:
        """
        (list) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        (int) Identifier that uniquely identifies an entity
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetForwardingControlRuleLabelResult']:
        """
        (list) Labels that are applicable to the rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Sequence['outputs.GetForwardingControlRuleLocationGroupResult']:
        """
        (Optional) You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetForwardingControlRuleLocationResult']:
        """
        (Optional) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (string) The configured name of the entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nwApplicationGroups")
    def nw_application_groups(self) -> Sequence['outputs.GetForwardingControlRuleNwApplicationGroupResult']:
        """
        (list) Any number of application groups that you want to control with this rule. The service provides predefined applications that you can group, but not modify
        """
        return pulumi.get(self, "nw_application_groups")

    @property
    @pulumi.getter(name="nwApplications")
    def nw_applications(self) -> Sequence[str]:
        """
        (Optional) When not used it applies the rule to all applications. The service provides predefined applications, which you can group, but not modify.
        """
        return pulumi.get(self, "nw_applications")

    @property
    @pulumi.getter(name="nwServiceGroups")
    def nw_service_groups(self) -> Sequence['outputs.GetForwardingControlRuleNwServiceGroupResult']:
        """
        (list) Any number of predefined or custom network service groups to which the rule applies.
        """
        return pulumi.get(self, "nw_service_groups")

    @property
    @pulumi.getter(name="nwServices")
    def nw_services(self) -> Sequence['outputs.GetForwardingControlRuleNwServiceResult']:
        """
        (list) When not used it applies the rule to all network services or you can select specific network services. The Zscaler firewall has predefined services and you can configure up to `1,024` additional custom services.
        """
        return pulumi.get(self, "nw_services")

    @property
    @pulumi.getter
    def order(self) -> int:
        """
        (string) - The order of execution for the forwarding rule order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="proxyGateways")
    def proxy_gateways(self) -> Sequence['outputs.GetForwardingControlRuleProxyGatewayResult']:
        """
        (set) The proxy gateway for which the rule is applicable. This field is applicable only for the `PROXYCHAIN` forwarding method.
        """
        return pulumi.get(self, "proxy_gateways")

    @property
    @pulumi.getter
    def rank(self) -> int:
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="resCategories")
    def res_categories(self) -> Sequence[str]:
        """
        ** - (list) List of destination domain categories to which the rule applies.
        """
        return pulumi.get(self, "res_categories")

    @property
    @pulumi.getter(name="srcIpGroups")
    def src_ip_groups(self) -> Sequence['outputs.GetForwardingControlRuleSrcIpGroupResult']:
        """
        (list) Any number of source IP address groups that you want to control with this rule.
        """
        return pulumi.get(self, "src_ip_groups")

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Sequence[str]:
        """
        (Optional) You can enter individual IP addresses, subnets, or address ranges.
        """
        return pulumi.get(self, "src_ips")

    @property
    @pulumi.getter(name="srcIpv6Groups")
    def src_ipv6_groups(self) -> Sequence['outputs.GetForwardingControlRuleSrcIpv6GroupResult']:
        return pulumi.get(self, "src_ipv6_groups")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        (string) - Indicates whether the forwarding rule is enabled or disabled.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        (string) -  The rule type selected from the available options
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetForwardingControlRuleUserResult']:
        """
        (list) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Sequence['outputs.GetForwardingControlRuleZpaAppSegmentResult']:
        """
        (set) The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the `ZPA` Gateway forwarding method.
        """
        return pulumi.get(self, "zpa_app_segments")

    @property
    @pulumi.getter(name="zpaApplicationSegmentGroups")
    def zpa_application_segment_groups(self) -> Sequence['outputs.GetForwardingControlRuleZpaApplicationSegmentGroupResult']:
        """
        (set) List of ZPA Application Segment Groups for which this rule is applicable. This field is applicable only for the `ECZPA` forwarding method (used for Zscaler Cloud Connector).
        """
        return pulumi.get(self, "zpa_application_segment_groups")

    @property
    @pulumi.getter(name="zpaApplicationSegments")
    def zpa_application_segments(self) -> Sequence['outputs.GetForwardingControlRuleZpaApplicationSegmentResult']:
        """
        (set) List of ZPA Application Segments for which this rule is applicable. This field is applicable only for the `ECZPA` forwarding method (used for Zscaler Cloud Connector).
        """
        return pulumi.get(self, "zpa_application_segments")

    @property
    @pulumi.getter(name="zpaBrokerRule")
    def zpa_broker_rule(self) -> bool:
        return pulumi.get(self, "zpa_broker_rule")

    @property
    @pulumi.getter(name="zpaGateways")
    def zpa_gateways(self) -> Sequence['outputs.GetForwardingControlRuleZpaGatewayResult']:
        """
        (set) The ZPA Gateway for which this rule is applicable. This field is applicable only for the `ZPA` forwarding method.
        """
        return pulumi.get(self, "zpa_gateways")


class AwaitableGetForwardingControlRuleResult(GetForwardingControlRuleResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetForwardingControlRuleResult(
            departments=self.departments,
            description=self.description,
            dest_addresses=self.dest_addresses,
            dest_countries=self.dest_countries,
            dest_ip_categories=self.dest_ip_categories,
            dest_ip_groups=self.dest_ip_groups,
            dest_ipv6_groups=self.dest_ipv6_groups,
            device_groups=self.device_groups,
            devices=self.devices,
            ec_groups=self.ec_groups,
            forward_method=self.forward_method,
            groups=self.groups,
            id=self.id,
            labels=self.labels,
            location_groups=self.location_groups,
            locations=self.locations,
            name=self.name,
            nw_application_groups=self.nw_application_groups,
            nw_applications=self.nw_applications,
            nw_service_groups=self.nw_service_groups,
            nw_services=self.nw_services,
            order=self.order,
            proxy_gateways=self.proxy_gateways,
            rank=self.rank,
            res_categories=self.res_categories,
            src_ip_groups=self.src_ip_groups,
            src_ips=self.src_ips,
            src_ipv6_groups=self.src_ipv6_groups,
            state=self.state,
            type=self.type,
            users=self.users,
            zpa_app_segments=self.zpa_app_segments,
            zpa_application_segment_groups=self.zpa_application_segment_groups,
            zpa_application_segments=self.zpa_application_segments,
            zpa_broker_rule=self.zpa_broker_rule,
            zpa_gateways=self.zpa_gateways)


def get_forwarding_control_rule(id: Optional[int] = None,
                                name: Optional[str] = None,
                                type: Optional[str] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetForwardingControlRuleResult:
    """
    Use the **forwarding_control_rule** data source to get information about a forwarding control rule which is used to forward selective Zscaler traffic to specific destinations based on your needs.For example, if you want to forward specific web traffic to a third-party proxy service or if you want to forward source IP anchored application traffic to a specific Zscaler Private Access (ZPA) App Connector or internal application traffic through ZIA threat and data protection engines, use forwarding control by configuring appropriate rules.

    ## Example Usage

    <!--Start PulumiCodeChooser -->
    ```python
    import pulumi
    import pulumi_zia as zia

    this = zia.get_forwarding_control_rule(name="FWD_RULE01")
    ```
    <!--End PulumiCodeChooser -->


    :param int id: A unique identifier assigned to the forwarding rule.
    :param str name: The name of the forwarding rule.
    :param str type: (string) -  The rule type selected from the available options
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['type'] = type
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getForwardingControlRule:getForwardingControlRule', __args__, opts=opts, typ=GetForwardingControlRuleResult).value

    return AwaitableGetForwardingControlRuleResult(
        departments=pulumi.get(__ret__, 'departments'),
        description=pulumi.get(__ret__, 'description'),
        dest_addresses=pulumi.get(__ret__, 'dest_addresses'),
        dest_countries=pulumi.get(__ret__, 'dest_countries'),
        dest_ip_categories=pulumi.get(__ret__, 'dest_ip_categories'),
        dest_ip_groups=pulumi.get(__ret__, 'dest_ip_groups'),
        dest_ipv6_groups=pulumi.get(__ret__, 'dest_ipv6_groups'),
        device_groups=pulumi.get(__ret__, 'device_groups'),
        devices=pulumi.get(__ret__, 'devices'),
        ec_groups=pulumi.get(__ret__, 'ec_groups'),
        forward_method=pulumi.get(__ret__, 'forward_method'),
        groups=pulumi.get(__ret__, 'groups'),
        id=pulumi.get(__ret__, 'id'),
        labels=pulumi.get(__ret__, 'labels'),
        location_groups=pulumi.get(__ret__, 'location_groups'),
        locations=pulumi.get(__ret__, 'locations'),
        name=pulumi.get(__ret__, 'name'),
        nw_application_groups=pulumi.get(__ret__, 'nw_application_groups'),
        nw_applications=pulumi.get(__ret__, 'nw_applications'),
        nw_service_groups=pulumi.get(__ret__, 'nw_service_groups'),
        nw_services=pulumi.get(__ret__, 'nw_services'),
        order=pulumi.get(__ret__, 'order'),
        proxy_gateways=pulumi.get(__ret__, 'proxy_gateways'),
        rank=pulumi.get(__ret__, 'rank'),
        res_categories=pulumi.get(__ret__, 'res_categories'),
        src_ip_groups=pulumi.get(__ret__, 'src_ip_groups'),
        src_ips=pulumi.get(__ret__, 'src_ips'),
        src_ipv6_groups=pulumi.get(__ret__, 'src_ipv6_groups'),
        state=pulumi.get(__ret__, 'state'),
        type=pulumi.get(__ret__, 'type'),
        users=pulumi.get(__ret__, 'users'),
        zpa_app_segments=pulumi.get(__ret__, 'zpa_app_segments'),
        zpa_application_segment_groups=pulumi.get(__ret__, 'zpa_application_segment_groups'),
        zpa_application_segments=pulumi.get(__ret__, 'zpa_application_segments'),
        zpa_broker_rule=pulumi.get(__ret__, 'zpa_broker_rule'),
        zpa_gateways=pulumi.get(__ret__, 'zpa_gateways'))


@_utilities.lift_output_func(get_forwarding_control_rule)
def get_forwarding_control_rule_output(id: Optional[pulumi.Input[Optional[int]]] = None,
                                       name: Optional[pulumi.Input[Optional[str]]] = None,
                                       type: Optional[pulumi.Input[Optional[str]]] = None,
                                       opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetForwardingControlRuleResult]:
    """
    Use the **forwarding_control_rule** data source to get information about a forwarding control rule which is used to forward selective Zscaler traffic to specific destinations based on your needs.For example, if you want to forward specific web traffic to a third-party proxy service or if you want to forward source IP anchored application traffic to a specific Zscaler Private Access (ZPA) App Connector or internal application traffic through ZIA threat and data protection engines, use forwarding control by configuring appropriate rules.

    ## Example Usage

    <!--Start PulumiCodeChooser -->
    ```python
    import pulumi
    import pulumi_zia as zia

    this = zia.get_forwarding_control_rule(name="FWD_RULE01")
    ```
    <!--End PulumiCodeChooser -->


    :param int id: A unique identifier assigned to the forwarding rule.
    :param str name: The name of the forwarding rule.
    :param str type: (string) -  The rule type selected from the available options
    """
    ...

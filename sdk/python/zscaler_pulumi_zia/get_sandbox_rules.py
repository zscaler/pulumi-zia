# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetSandboxRulesResult',
    'AwaitableGetSandboxRulesResult',
    'get_sandbox_rules',
    'get_sandbox_rules_output',
]

@pulumi.output_type
class GetSandboxRulesResult:
    """
    A collection of values returned by getSandboxRules.
    """
    def __init__(__self__, ba_policy_categories=None, ba_rule_action=None, by_threat_score=None, departments=None, description=None, file_types=None, first_time_enable=None, first_time_operation=None, groups=None, id=None, labels=None, last_modified_bies=None, last_modified_time=None, location_groups=None, locations=None, ml_action_enabled=None, name=None, order=None, protocols=None, rank=None, state=None, url_categories=None, users=None, zpa_app_segments=None):
        if ba_policy_categories and not isinstance(ba_policy_categories, list):
            raise TypeError("Expected argument 'ba_policy_categories' to be a list")
        pulumi.set(__self__, "ba_policy_categories", ba_policy_categories)
        if ba_rule_action and not isinstance(ba_rule_action, str):
            raise TypeError("Expected argument 'ba_rule_action' to be a str")
        pulumi.set(__self__, "ba_rule_action", ba_rule_action)
        if by_threat_score and not isinstance(by_threat_score, int):
            raise TypeError("Expected argument 'by_threat_score' to be a int")
        pulumi.set(__self__, "by_threat_score", by_threat_score)
        if departments and not isinstance(departments, list):
            raise TypeError("Expected argument 'departments' to be a list")
        pulumi.set(__self__, "departments", departments)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if file_types and not isinstance(file_types, list):
            raise TypeError("Expected argument 'file_types' to be a list")
        pulumi.set(__self__, "file_types", file_types)
        if first_time_enable and not isinstance(first_time_enable, bool):
            raise TypeError("Expected argument 'first_time_enable' to be a bool")
        pulumi.set(__self__, "first_time_enable", first_time_enable)
        if first_time_operation and not isinstance(first_time_operation, str):
            raise TypeError("Expected argument 'first_time_operation' to be a str")
        pulumi.set(__self__, "first_time_operation", first_time_operation)
        if groups and not isinstance(groups, list):
            raise TypeError("Expected argument 'groups' to be a list")
        pulumi.set(__self__, "groups", groups)
        if id and not isinstance(id, int):
            raise TypeError("Expected argument 'id' to be a int")
        pulumi.set(__self__, "id", id)
        if labels and not isinstance(labels, list):
            raise TypeError("Expected argument 'labels' to be a list")
        pulumi.set(__self__, "labels", labels)
        if last_modified_bies and not isinstance(last_modified_bies, list):
            raise TypeError("Expected argument 'last_modified_bies' to be a list")
        pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if last_modified_time and not isinstance(last_modified_time, int):
            raise TypeError("Expected argument 'last_modified_time' to be a int")
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        if location_groups and not isinstance(location_groups, list):
            raise TypeError("Expected argument 'location_groups' to be a list")
        pulumi.set(__self__, "location_groups", location_groups)
        if locations and not isinstance(locations, list):
            raise TypeError("Expected argument 'locations' to be a list")
        pulumi.set(__self__, "locations", locations)
        if ml_action_enabled and not isinstance(ml_action_enabled, bool):
            raise TypeError("Expected argument 'ml_action_enabled' to be a bool")
        pulumi.set(__self__, "ml_action_enabled", ml_action_enabled)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if order and not isinstance(order, int):
            raise TypeError("Expected argument 'order' to be a int")
        pulumi.set(__self__, "order", order)
        if protocols and not isinstance(protocols, list):
            raise TypeError("Expected argument 'protocols' to be a list")
        pulumi.set(__self__, "protocols", protocols)
        if rank and not isinstance(rank, int):
            raise TypeError("Expected argument 'rank' to be a int")
        pulumi.set(__self__, "rank", rank)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if url_categories and not isinstance(url_categories, list):
            raise TypeError("Expected argument 'url_categories' to be a list")
        pulumi.set(__self__, "url_categories", url_categories)
        if users and not isinstance(users, list):
            raise TypeError("Expected argument 'users' to be a list")
        pulumi.set(__self__, "users", users)
        if zpa_app_segments and not isinstance(zpa_app_segments, list):
            raise TypeError("Expected argument 'zpa_app_segments' to be a list")
        pulumi.set(__self__, "zpa_app_segments", zpa_app_segments)

    @property
    @pulumi.getter(name="baPolicyCategories")
    def ba_policy_categories(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "ba_policy_categories")

    @property
    @pulumi.getter(name="baRuleAction")
    def ba_rule_action(self) -> builtins.str:
        return pulumi.get(self, "ba_rule_action")

    @property
    @pulumi.getter(name="byThreatScore")
    def by_threat_score(self) -> builtins.int:
        return pulumi.get(self, "by_threat_score")

    @property
    @pulumi.getter
    def departments(self) -> Sequence['outputs.GetSandboxRulesDepartmentResult']:
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "file_types")

    @property
    @pulumi.getter(name="firstTimeEnable")
    def first_time_enable(self) -> builtins.bool:
        return pulumi.get(self, "first_time_enable")

    @property
    @pulumi.getter(name="firstTimeOperation")
    def first_time_operation(self) -> builtins.str:
        return pulumi.get(self, "first_time_operation")

    @property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetSandboxRulesGroupResult']:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> builtins.int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetSandboxRulesLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Sequence['outputs.GetSandboxRulesLastModifiedByResult']:
        return pulumi.get(self, "last_modified_bies")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> builtins.int:
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Sequence['outputs.GetSandboxRulesLocationGroupResult']:
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetSandboxRulesLocationResult']:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="mlActionEnabled")
    def ml_action_enabled(self) -> builtins.bool:
        return pulumi.get(self, "ml_action_enabled")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> builtins.int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def protocols(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> builtins.int:
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetSandboxRulesUserResult']:
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="zpaAppSegments")
    def zpa_app_segments(self) -> Sequence['outputs.GetSandboxRulesZpaAppSegmentResult']:
        return pulumi.get(self, "zpa_app_segments")


class AwaitableGetSandboxRulesResult(GetSandboxRulesResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetSandboxRulesResult(
            ba_policy_categories=self.ba_policy_categories,
            ba_rule_action=self.ba_rule_action,
            by_threat_score=self.by_threat_score,
            departments=self.departments,
            description=self.description,
            file_types=self.file_types,
            first_time_enable=self.first_time_enable,
            first_time_operation=self.first_time_operation,
            groups=self.groups,
            id=self.id,
            labels=self.labels,
            last_modified_bies=self.last_modified_bies,
            last_modified_time=self.last_modified_time,
            location_groups=self.location_groups,
            locations=self.locations,
            ml_action_enabled=self.ml_action_enabled,
            name=self.name,
            order=self.order,
            protocols=self.protocols,
            rank=self.rank,
            state=self.state,
            url_categories=self.url_categories,
            users=self.users,
            zpa_app_segments=self.zpa_app_segments)


def get_sandbox_rules(id: Optional[builtins.int] = None,
                      name: Optional[builtins.str] = None,
                      url_categories: Optional[Sequence[builtins.str]] = None,
                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetSandboxRulesResult:
    """
    Use the **zia_sandbox_rules** data source to get information about a sandbox rule in the Zscaler Internet Access.

    ## Example Usage

    ## Read-Only

    In addition to all arguments above, the following attributes are exported:

    * `description` - (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
    * `order` - (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
    * `state` - (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
    * `rank` - (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
    * `ba_rule_action` - (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
    * `first_time_enable` - (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
    * `first_time_operation` - (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
    * `ml_action_enabled` - (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
    * `by_threat_score` - (Integer)
    * `default_rule` - (Boolean) Value that indicates whether the rule is the Default Cloud IPS Rule or not

    * `url_categories` - (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
    * `file_types` - (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.

    `Who, Where and When` supports the following attributes:

    * `locations` - (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `location_groups` - (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `users` - (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `groups` - (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `departments` - (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        - `id` - (Integer) Identifier that uniquely identifies an entity

    * `labels` (List of Objects) Labels that are applicable to the rule.
        - `id` - (Integer) Identifier that uniquely identifies an entity

    * `zpa_app_segments` (List of Objects) The ZPA application segments to which the rule applies
        - `id` - (Integer) Identifier that uniquely identifies an entity


    :param builtins.int id: Unique identifier for the Sandbox rule
    :param builtins.str name: Name of the Sandbox rule
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['urlCategories'] = url_categories
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zia:index/getSandboxRules:getSandboxRules', __args__, opts=opts, typ=GetSandboxRulesResult).value

    return AwaitableGetSandboxRulesResult(
        ba_policy_categories=pulumi.get(__ret__, 'ba_policy_categories'),
        ba_rule_action=pulumi.get(__ret__, 'ba_rule_action'),
        by_threat_score=pulumi.get(__ret__, 'by_threat_score'),
        departments=pulumi.get(__ret__, 'departments'),
        description=pulumi.get(__ret__, 'description'),
        file_types=pulumi.get(__ret__, 'file_types'),
        first_time_enable=pulumi.get(__ret__, 'first_time_enable'),
        first_time_operation=pulumi.get(__ret__, 'first_time_operation'),
        groups=pulumi.get(__ret__, 'groups'),
        id=pulumi.get(__ret__, 'id'),
        labels=pulumi.get(__ret__, 'labels'),
        last_modified_bies=pulumi.get(__ret__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__ret__, 'last_modified_time'),
        location_groups=pulumi.get(__ret__, 'location_groups'),
        locations=pulumi.get(__ret__, 'locations'),
        ml_action_enabled=pulumi.get(__ret__, 'ml_action_enabled'),
        name=pulumi.get(__ret__, 'name'),
        order=pulumi.get(__ret__, 'order'),
        protocols=pulumi.get(__ret__, 'protocols'),
        rank=pulumi.get(__ret__, 'rank'),
        state=pulumi.get(__ret__, 'state'),
        url_categories=pulumi.get(__ret__, 'url_categories'),
        users=pulumi.get(__ret__, 'users'),
        zpa_app_segments=pulumi.get(__ret__, 'zpa_app_segments'))
def get_sandbox_rules_output(id: Optional[pulumi.Input[Optional[builtins.int]]] = None,
                             name: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                             url_categories: Optional[pulumi.Input[Optional[Sequence[builtins.str]]]] = None,
                             opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetSandboxRulesResult]:
    """
    Use the **zia_sandbox_rules** data source to get information about a sandbox rule in the Zscaler Internet Access.

    ## Example Usage

    ## Read-Only

    In addition to all arguments above, the following attributes are exported:

    * `description` - (String) Enter additional notes or information. The description cannot exceed 10,240 characters.
    * `order` - (Integer) Policy rules are evaluated in ascending numerical order (Rule 1 before Rule 2, and so on), and the Rule Order reflects this rule's place in the order.
    * `state` - (String) The state of the rule indicating whether it is enabled or disabled. Supported values: `ENABLED` or `DISABLED`
    * `rank` - (Integer) The admin rank specified for the rule based on your assigned admin rank. Admin rank determines the rule order that can be specified for the rule. Admin rank can be configured if it is enabled in the Advanced Settings.
    * `ba_rule_action` - (String) The action configured for the rule that must take place if the traffic matches the rule criteria. Supported Values: `ALLOW` or `BLOCK`
    * `first_time_enable` - (Boolean) A Boolean value indicating whether a First-Time Action is specifically configured for the rule. The First-Time Action takes place when users download unknown files. The action to be applied is specified using the firstTimeOperation field.
    * `first_time_operation` - (String) The action that must take place when users download unknown files for the first time. Supported Values: `ALLOW_SCAN`, `QUARANTINE`, `ALLOW_NOSCAN`, `QUARANTINE_ISOLATE`
    * `ml_action_enabled` - (Boolean) A Boolean value indicating whether to enable or disable the AI Instant Verdict option to have the Zscaler service use AI analysis to instantly assign threat scores to unknown files. This option is available to use only with specific rule actions such as Quarantine and Allow and Scan for First-Time Action.
    * `by_threat_score` - (Integer)
    * `default_rule` - (Boolean) Value that indicates whether the rule is the Default Cloud IPS Rule or not

    * `url_categories` - (List of Strings) The list of URL categories to which the DLP policy rule must be applied.
    * `file_types` - (List of Strings) File type categories for which the policy is applied. If not set, the rule is applied across all file types.

    `Who, Where and When` supports the following attributes:

    * `locations` - (List of Objects) You can manually select up to `8` locations. When not used it implies `Any` to apply the rule to all groups.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `location_groups` - (List of Objects)You can manually select up to `32` location groups. When not used it implies `Any` to apply the rule to all location groups.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `users` - (List of Objects) You can manually select up to `4` general and/or special users. When not used it implies `Any` to apply the rule to all users.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `groups` - (List of Objects) You can manually select up to `8` groups. When not used it implies `Any` to apply the rule to all groups.
        - `id` - (Integer) Identifier that uniquely identifies an entity
    * `departments` - (List of Objects) Apply to any number of departments When not used it implies `Any` to apply the rule to all departments.
        - `id` - (Integer) Identifier that uniquely identifies an entity

    * `labels` (List of Objects) Labels that are applicable to the rule.
        - `id` - (Integer) Identifier that uniquely identifies an entity

    * `zpa_app_segments` (List of Objects) The ZPA application segments to which the rule applies
        - `id` - (Integer) Identifier that uniquely identifies an entity


    :param builtins.int id: Unique identifier for the Sandbox rule
    :param builtins.str name: Name of the Sandbox rule
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['urlCategories'] = url_categories
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zia:index/getSandboxRules:getSandboxRules', __args__, opts=opts, typ=GetSandboxRulesResult)
    return __ret__.apply(lambda __response__: GetSandboxRulesResult(
        ba_policy_categories=pulumi.get(__response__, 'ba_policy_categories'),
        ba_rule_action=pulumi.get(__response__, 'ba_rule_action'),
        by_threat_score=pulumi.get(__response__, 'by_threat_score'),
        departments=pulumi.get(__response__, 'departments'),
        description=pulumi.get(__response__, 'description'),
        file_types=pulumi.get(__response__, 'file_types'),
        first_time_enable=pulumi.get(__response__, 'first_time_enable'),
        first_time_operation=pulumi.get(__response__, 'first_time_operation'),
        groups=pulumi.get(__response__, 'groups'),
        id=pulumi.get(__response__, 'id'),
        labels=pulumi.get(__response__, 'labels'),
        last_modified_bies=pulumi.get(__response__, 'last_modified_bies'),
        last_modified_time=pulumi.get(__response__, 'last_modified_time'),
        location_groups=pulumi.get(__response__, 'location_groups'),
        locations=pulumi.get(__response__, 'locations'),
        ml_action_enabled=pulumi.get(__response__, 'ml_action_enabled'),
        name=pulumi.get(__response__, 'name'),
        order=pulumi.get(__response__, 'order'),
        protocols=pulumi.get(__response__, 'protocols'),
        rank=pulumi.get(__response__, 'rank'),
        state=pulumi.get(__response__, 'state'),
        url_categories=pulumi.get(__response__, 'url_categories'),
        users=pulumi.get(__response__, 'users'),
        zpa_app_segments=pulumi.get(__response__, 'zpa_app_segments')))
